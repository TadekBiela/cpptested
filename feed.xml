<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-11-22T19:47:55+01:00</updated><id>/feed.xml</id><title type="html">CppTested</title><subtitle>Blog o TDD, unit testach, nowoczesnym C++ i wielowątkowości. Jak pisać lepszy, bezpieczniejszy i bardziej przewidywalny kod.</subtitle><author><name>Tadeusz Biela</name></author><entry><title type="html">DRY, YAGNI, KISS i inne. Uniwersalne zasady dla każdego programisty.</title><link href="/clean%20code/dry-and-other-principles/" rel="alternate" type="text/html" title="DRY, YAGNI, KISS i inne. Uniwersalne zasady dla każdego programisty." /><published>2025-11-17T00:00:00+01:00</published><updated>2025-11-17T00:00:00+01:00</updated><id>/clean%20code/dry-and-other-principles</id><content type="html" xml:base="/clean%20code/dry-and-other-principles/"><![CDATA[<p>Te tajemnicze akronimy skrywają w sobie dekady doświadczeń naszych programistycznych poprzedników. Choć brzmi to nieco patetycznie, tak właśnie jest. Zasady, opisane w tym wpisie, to dziedzictwo wielu błędów, obserwacji i celnych spostrzeżeń, zbieranych latami przez bardzo doświadczonych ludzi dla ich następców. Te zasady działają jak sita. Przesiany przez nie kod staje się znacznie lepszy, bardziej czytelny, odporny na błędy i łatwiejszy w utrzymaniu.</p>

<h3 id="po-co-nam-zasady">Po co nam zasady?</h3>

<p>Zasady w programowaniu wytyczają nam szlak - kierunek, w jakim powinniśmy podążać, aby uzyskać kod wysokiej jakości. Każda z poniższych reguł, o których wspominam w tym wpisie, dotyka nieco innych aspektów wytwarzanego przez nas oprogramowania. Tworzą one niejako pewien standard. Można oczywiście pisać kod i bez nich, tylko po co? DRY i inne zasady to ogrom doświadczenia naszych poprzedników, z którego powinniśmy korzystać, ucząc się na ich błędach i kto wie, może formułować nowe? Czemu by nie!</p>

<p>Co daje nam trzymanie się dobrych zasad programowania?</p>
<ol>
  <li>Ułatwiają utrzymanie kodu.</li>
  <li>Zmniejszają ryzyko wystąpienia błędów.</li>
  <li>Umożliwiają dobrą współpracę między twórcami i odbiorcami kodu.</li>
  <li>Tworzą bardziej uporządkowany projekt.</li>
  <li>Pomagają podejmować odpowiedzialne decyzje.</li>
</ol>

<p>A teraz przejdźmy już do konkretów.</p>

<h3 id="dry---jedno-źródło-informacji">DRY - jedno źródło informacji</h3>

<p>DRY - Don’t Repeat Yourself - unikaj powielania wiedzy. Zasada ta jest prosta, jeśli widzisz w swoim kodzie ciągle powtarzające się linijki, to należy je odpowiednio nazwać i przenieść do funkcji lub metody, w zależności od kontekstu. Dzięki temu, gdy przyjdzie czas na zmianę (a z pewnością przyjdzie), będziemy musieli edytować tylko jedno miejsce, a nie wiele. Unikniemy sytuacji, gdy trzeba zmienić kod w kilku miejscach i o którymś zapomnimy. Daje nam to również możliwość zwiększenia czytelności naszego kodu. Nowa funkcja czy metoda musi mieć nazwę, warto, by była ona wyjaśniająca, tłumaczyła w krótki sposób, co robi wewnątrz.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Money</span> <span class="nf">calculateSalary</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="mi">18</span> <span class="o">&lt;=</span> <span class="n">employee</span><span class="p">.</span><span class="n">getAge</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">freeDays</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="mi">18</span> <span class="o">&lt;=</span> <span class="n">employee</span><span class="p">.</span><span class="n">getAge</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Widać tutaj powtórzenie, <strong>“18 &lt;= employee.getAge()”</strong>. Jest to pewien element wiedzy biznesowej. Jeśli pracownik jest niepełnoletni, to jego wynagrodzenie i liczba dni wolnych jest inna. Spróbujmy to lepiej wyrazić i zastosować DRY.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isAdult</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">adultAge</span> <span class="p">{</span> <span class="mi">18</span> <span class="p">};</span>
    <span class="k">return</span> <span class="n">adultAge</span> <span class="o">&lt;=</span> <span class="n">employee</span><span class="p">.</span><span class="n">getAge</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Money</span> <span class="n">calculateSalary</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">isAdult</span><span class="p">(</span><span class="n">employee</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">freeDays</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">isAdult</span><span class="p">(</span><span class="n">employee</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To tylko prosty przykład, jak możemy stosować DRY. Należy jednak pamiętać, że ta zasada, jak i wszystkie następne, mają nam pomagać tworzyć kod wysokiej jakości. Jak ze wszystkim, tak z DRY, też da się przesadzić. Zauważyłem, że często w unit testach DRY nie do końca się sprawdza.</p>

<p>Mamy klasę <strong>UserService</strong>, która odpowiada za logowanie (pomińmy na razie aspekty security ;) ).</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserService</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">login</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">username</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">password</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">username</span> <span class="o">==</span> <span class="s">"admin"</span> <span class="o">&amp;&amp;</span> <span class="n">password</span> <span class="o">==</span> <span class="s">"1234"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">checkLogin</span><span class="p">(</span><span class="n">UserService</span><span class="o">&amp;</span> <span class="n">service</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">user</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pass</span><span class="p">,</span>
                <span class="kt">bool</span> <span class="n">expected</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">service</span><span class="p">.</span><span class="n">login</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">pass</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">UserServiceTest</span><span class="p">,</span> <span class="n">AllLogins</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UserService</span> <span class="n">service</span><span class="p">;</span>
    <span class="n">checkLogin</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="s">"admin"</span><span class="p">,</span> <span class="s">"1234"</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="n">checkLogin</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="s">"admin"</span><span class="p">,</span> <span class="s">"wrong"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">checkLogin</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="s">"user"</span><span class="p">,</span> <span class="s">"1234"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>W tym przykładzie testujemy różne sposoby logowania. Wygląda prosto. Nie ma powtórzeń, ale jest tutaj jeden zasadniczy problem - czytelność, a raczej jej brak. Mamy tylko jeden test sprawdzający tę samą jednostkę, ale już w różnych scenariuszach. Nie spełnia on standardu <a href="https://cpptested.com/unit%20testing/AAA-golden-standard/" target="_blank" rel="noopener">AAA</a>. Gdy coś pójdzie nie tak, dużo trudniej będzie dowiedzieć się, który scenariusz nie działa poprawnie.</p>

<p>Teraz porównaj to z poniższymi testami.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST</span><span class="p">(</span><span class="n">UserServiceTest</span><span class="p">,</span> <span class="n">login_ValidCredentials_ReturnTrue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UserService</span> <span class="n">service</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">service</span><span class="p">.</span><span class="n">login</span><span class="p">(</span><span class="s">"admin"</span><span class="p">,</span> <span class="s">"1234"</span><span class="p">);</span>

    <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">UserServiceTest</span><span class="p">,</span> <span class="n">login_WrongPassword_ReturnFalse</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UserService</span> <span class="n">service</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">service</span><span class="p">.</span><span class="n">login</span><span class="p">(</span><span class="s">"admin"</span><span class="p">,</span> <span class="s">"wrong"</span><span class="p">);</span>

    <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">UserServiceTest</span><span class="p">,</span> <span class="n">login_UnknownUser_ReturnFalse</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UserService</span> <span class="n">service</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">service</span><span class="p">.</span><span class="n">login</span><span class="p">(</span><span class="s">"user"</span><span class="p">,</span> <span class="s">"1234"</span><span class="p">);</span>

    <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To klasyczny przykład, gdzie czytelność jest wyżej niż DRY. Don’t Repeat Yourself to świetna reguła. Pomaga uporządkować kod, ułatwia wprowadzanie zmian i zrozumienie logiki kodu. W testach również ma swoje zastosowanie, lecz nie powinna być regułą wiodącą w nich prym.</p>

<p>DRY to jednak coś znacznie więcej, niż tylko ograniczanie powielania kodu, jak dla mnie najlepiej opisuję tę zasadę Robert C. Martin w swojej bardzo znanej książce - <a href="https://lubimyczytac.pl/ksiazka/83492/czysty-kod-podrecznik-dobrego-programisty" target="_blank" rel="noopener">Czysty Kod. Podręcznik dobrego programisty</a>, którą z czystym sumieniem polecam ;)</p>

<h3 id="yagni---potrzebne-ponad-możliwe">YAGNI - potrzebne ponad możliwe</h3>

<p>YAGNI - You Aren’t Gonna Need It, ta zasada mówi o tym, że jeśli w danym momencie rozwoju oprogramowania nie potrzebujesz jakiejś funkcjonalności, to jej nie dodawaj. Czasem chcemy wychodzić naprzeciw oczekiwaniom użytkowników naszego kodu, lub staramy się przewidzieć, co jeszcze będzie potrzebne. Zapominamy jednak o czymś bardzo istotnym. Założenia się zmieniają. To, co wydawało nam się być potrzebne, choć nie planowane, po chwili może wylądować w gitowej historii.</p>

<p>W tej regule nie chodzi o to, by nie myśleć o przyszłości, o architekturze. Projekt jest ważny, umożliwia rozwój oprogramowania w jasno określonym kierunku i określony sposób. Bierze pod uwagę różne aspekty, takie jak elastyczność, łatwość utrzymania, koszty wytworzenia i wiele innych.</p>

<p>YAGNI nie mówi o tym, byś nie planował, nie przewidywał. Mówi o tym, byś nie implementował czegoś, co może okazać się niepotrzebne.</p>

<p>Wróćmy do <strong>UserService</strong>. Założenie jest proste, klasa odpowiada za logowanie. Można by przewidzieć, co będzie jeszcze potrzebne do logowania i nasza klasa rozrośnie się.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserService</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">login</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">username</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">password</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">username</span> <span class="o">==</span> <span class="s">"admin"</span> <span class="o">&amp;&amp;</span> <span class="n">password</span> <span class="o">==</span> <span class="s">"1234"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">logout</span><span class="p">()</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">resetPassword</span><span class="p">()</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">twoFactorAuth</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Tylko na tym etapie nie wiemy jeszcze, co tak naprawdę się przyda. Jak mamy zastosować TDD, gdy brak jest założeń? Co zrobić z kodem, którego nikt nie używa?</p>

<p>Nie traćmy czasu i zasobów na tworzenie kodu, którego nikt w danym momencie nie potrzebuje. Ogranicza to również koszty, które taki nadmiarowy kod generuje. Trzeba do niego napisać testy (choć w przykładzie dodaliśmy tylko puste metody, więc testów nie napiszemy), utrzymywać, aktualizować, gdy interfejs się zmienia. To są koszty, koszty, które ponosisz Ty, Twój zespół i Twoja firma. Ogranicz zakres zmian do minimum. YAGNI to istota minimalizmu w programistycznym świecie.</p>

<h3 id="kiss---prosto-ale-skutecznie">KISS - prosto ale skutecznie</h3>

<p>KISS - Keep It Simple, Stupid, dość wymowna nazwa. Kultura w branży IT wydaje mi się na całkiem wysokim poziomie, i nikt raczej nie wyzywa nikogo od idiotów :). Zasada ta mówi o tym, aby nie dodawać nadmiernej złożoności do naszego kodu. Kod prosty, to taki kod, który nie tylko łatwo napisać, ale przede wszystkim zrozumieć i zmienić, gdy będzie to potrzebne. Prosty kod też łatwiej się testuje.</p>

<p>Tutaj chcę zaznaczyć, że sama złożoność kodu nie jest zła, jeśli wynika ze złożoności problemu, który rozwiązuje. KISS trochę łączy się z YAGNI, bo możemy dodać więcej kodu, tworząc bardziej elastyczne rozwiązanie, potencjalnie łatwiejsze w rozszerzaniu. Może stosując jakiś wzorzec projektowy.</p>

<p>Tylko decyzja o użyciu wzorca powinna być podejmowana na poziomie architektury. Nie mówię tu o tym, żeby najpierw mieć cały projekt, a potem kod. W Agile tak się nie dzieje. Całe oprogramowanie tworzymy przyrostowo. Mówię o tym, by nie komplikować kodu bez potrzeby i bez planu.</p>

<p>Spójrz na poniższy przykład. Widać w nim pewien zamysł, może plany na przyszłość. Jednak kod jest zbyt zawiły w stosunku do tego, za co jest odpowiedzialny.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">IValidator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IValidator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">validate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">EmailValidator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IValidator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">validate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">'@'</span><span class="p">)</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">PasswordValidator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IValidator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">validate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">8</span> <span class="o">&lt;=</span> <span class="n">value</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">UserService</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">UserService</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IValidator</span><span class="o">&gt;</span> <span class="n">inputEmailValidator</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IValidator</span><span class="o">&gt;</span> <span class="n">inputPasswordValidator</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">emailValidator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">inputEmailValidator</span><span class="p">)),</span>
          <span class="n">passwordValidator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">inputPasswordValidator</span><span class="p">))</span>
    <span class="p">{}</span>

    <span class="kt">bool</span> <span class="n">registerUser</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">email</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">password</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">emailValidator</span><span class="o">-&gt;</span><span class="n">validate</span><span class="p">(</span><span class="n">email</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">passwordValidator</span><span class="o">-&gt;</span><span class="n">validate</span><span class="p">(</span><span class="n">password</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IValidator</span><span class="o">&gt;</span> <span class="n">emailValidator</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IValidator</span><span class="o">&gt;</span> <span class="n">passwordValidator</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Widać tutaj zdecydowany overengineering. Tyle konstrukcji tylko po to, by sprawdzić dwa proste warunki. Z KISS kod wyglądałby mniej więcej tak.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserService</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">registerUser</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">email</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">password</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">email</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">'@'</span><span class="p">)</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">password</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Zdecydowanie, w takim przypadku prostota wygrywa. KISS pomaga nam trzymać w ryzach złożoność naszego kodu.</p>

<p>KISS to świetna zasada w połączeniu z TDD. Każda zmiana w kodzie ma sprawić by nowy test przeszedł, nic więcej. TDD zakłada właśnie to, żeby tworzyć kod, który tylko sprawi, że nasz nowy test przejdzie i nie wprowadzi regresji do poprzednich.</p>

<p>Zasada KISS łamana jest najczęściej w trzech przypadkach:</p>

<ol>
  <li>
    <p>Przedwczesna optymalizacja - stosujemy sztuczki w kodzie, które potencjalnie mogą zwiększyć wydajność kodu. Sprawić, że będzie on działał szybciej. Jednak praktycznie nigdy się tego nie mierzy, a sama optymalizacja jest tak naprawdę znikoma lub pozorna. Kompilator nie raz jest w stanie czysty kod lepiej sam zoptymalizować niż z naszymi “sprytnymi” sztuczkami.</p>
  </li>
  <li>
    <p>Nadużywanie wzorców projektowych - sam się na tym złapałem kilka lat temu, gdy poznałem wzorce. Chęć ich wykorzystania była tak duża, że przy jednym z zadań rekrutacyjnych od razu chciałem zastosować fabrykę, a wystarczyłby jeden prosty <strong>if</strong>.</p>
  </li>
  <li>
    <p>Magia w kodzie - metaprogramowanie, refleksje, wiele poziomów abstrakcji. Te wszystkie rzeczy mają swoje zastosowanie, ale są to narzędzia do konkretnych celów. Nie należy ich stosować wszędzie, gdzie popadnie, bo akurat nam pasuje.</p>
  </li>
</ol>

<p>Jak stosować KISS w codziennej pracy? Najpierw zrób tak, aby działało, potem uprość kod, a na samym końcu optymalizuj, jeśli jest to potrzebne.</p>

<h3 id="pola---to-oczywiste">POLA - to oczywiste!</h3>

<p>POLA - Principle Of Least Astonishment, to nic innego jak zasada najmniejszego zaskoczenia. Gdy widzimy nazwę funkcji lub metody klasy, która mówi <strong>A</strong>, to powinna robić <strong>A</strong>, a nie <strong>ABC</strong> plus jeszcze <strong>Z</strong>. Albo w ogóle nie robi <strong>A</strong>, tylko <strong>F</strong>. W tej zasadzie musimy pamiętać, że tworząc kod, należy dobrze opisywać, co on robi, poprzez nadawanie odpowiednich nazw zmiennym, stałym, metodom, funkcjom itp. Kluczem do zachowania POLA jest dobre nazewnictwo. Zwiększa ono czytelność i łatwość zrozumienia naszego kodu, a to bezpośrednio przekłada się na niższy koszt jego utrzymania. Pamiętajmy, że kod zazwyczaj piszemy raz, czytamy natomiast wielokrotnie.</p>

<p>POLA mówi o tym, by nasz kod, był intuicyjny i spójny w zachowaniu. Jeśli metody naszej klasy robią coś innego niż to, na co wskazuje ich nazwa, łatwo popełnić błąd, trudniej korzystać z takiej klasy, jest to bardziej czasochłonne, bo musimy zapoznać się z jej implementacją. Naruszenie tej zasady bywa nieraz bardzo subtelne, dlatego tym bardziej powinniśmy o niej pamiętać.</p>

<p>Mamy tutaj klasę <strong>FileWriter</strong> z jedną metodą <strong>write</strong>. Pozornie wszystko wygląda ok.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FileWriter</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">file</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directories</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="p">(</span><span class="n">path</span><span class="p">).</span><span class="n">parent_path</span><span class="p">());</span>
            <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">retry</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="n">retry</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Metoda <strong>write</strong> próbuje otworzyć podany w <strong>path</strong> plik. Jeśli się nie uda, utworzy go wraz z wszystkimi katalogami prowadzącymi do pliku. Tylko czy ta metoda powinna to robić? Co jeżeli, ktoś w <strong>path</strong> popełni tylko literówkę? Nazwa <strong>write</strong> nie mówi o tym, że metoda coś tworzy. Jak w takim razie powinna wyglądać?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FileWriter</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">file</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Cannot open file: "</span> <span class="o">+</span> <span class="n">path</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Myślę, że rzucenie wyjątku jak najbardziej jest dobrym rozwiązaniem, jeżeli tylko nasz projekt zakłada ich użycie. Jeśli chcesz poznać więcej szczegółów dotyczących sytuacji wyjątkowych, to odsyłam do mojego wpisu o <a href="https://cpptested.com/multithreading/exception-in-thread/" target="_blank" rel="noopener">wyjątkach</a>.</p>

<p>W takiej formie, użytkownik klasy <strong>FileWriter</strong> nie powinien być zaskoczony wyrzuceniem wyjątku, gdy poda złą ścieżkę do pliku, zwłaszcza, iż metoda <strong>write</strong> nie jest oznaczona jako <strong>noexcept</strong>.</p>

<h3 id="lod---im-mniej-wiesz-tym-lepiej">LoD - im mniej wiesz, tym lepiej</h3>

<p>LoD - Law of Demeter, czyli inaczej Principle of Least Knowledge. Zasada najmniejszej wiedzy mówi o tym, by metoda wykorzystywała tylko to, co sama “wie”.</p>

<p>Metoda w klasie powinna komunikować się tylko z obiektami, które zna bezpośrednio. Sprowadza się to do używania tylko własnych pól klasy, przekazanych argumentów, stworzonych przez tę metodę obiektów i ewentualnie elementów globalnych (tak, tak, te ostatnie to zazwyczaj oznaka problemów projektowych, choć nie zawsze. Może napiszę osobny post, jak radzić sobie z globalami w testach).</p>

<p>Przyjrzyjmy się metodzie <strong>sendReport</strong> klasy <strong>ReportService</strong>. Metoda ta korzysta z wszystkich rodzajów dostępnej wiedzy, zachowując jednocześnie LoD.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Report</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">generate</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">"Daily report data"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">EmailClient</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">send</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">recipient</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">content</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Sending email to "</span> <span class="o">&lt;&lt;</span> <span class="n">recipient</span> <span class="o">&lt;&lt;</span> <span class="s">" with content:</span><span class="se">\n</span><span class="s">"</span>
                  <span class="o">&lt;&lt;</span> <span class="n">content</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Config</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getDefaultRecipient</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">"admin@example.com"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ReportService</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">sendReport</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">customRecipient</span> <span class="o">=</span> <span class="s">""</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// użycie argumentu metody</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">recipient</span> <span class="o">=</span> <span class="n">customRecipient</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span>
            <span class="o">?</span> <span class="n">Config</span><span class="o">::</span><span class="n">getDefaultRecipient</span><span class="p">()</span>  <span class="c1">// globalne źródło wiedzy</span>
            <span class="o">:</span> <span class="n">customRecipient</span><span class="p">;</span>

        <span class="c1">// stworzenie i użycie obiektu lokalnego</span>
        <span class="n">Report</span> <span class="n">report</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">content</span> <span class="o">=</span> <span class="n">report</span><span class="p">.</span><span class="n">generate</span><span class="p">();</span>

        <span class="c1">// wysłanie raportu przez własne pole emailClient</span>
        <span class="n">emailClient</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">recipient</span><span class="p">,</span> <span class="n">reportTitle</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span> <span class="o">+</span> <span class="n">content</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">EmailClient</span> <span class="n">emailClient</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">reportTitle</span> <span class="p">{</span> <span class="s">"Daily Report"</span> <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p>W Law od Demeter chodzi o ograniczanie łańcuchów wywołań.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">order</span><span class="p">.</span><span class="n">getCustomer</span><span class="p">().</span><span class="n">getAddress</span><span class="p">().</span><span class="n">getCity</span><span class="p">().</span><span class="n">getName</span><span class="p">();</span>
</code></pre></div></div>

<p>Zamiast takiego łańcuszka powinniśmy dążyć do tego, aby klasa order udostępniła nazwę miasta klienta bezpośrednio.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">order</span><span class="p">.</span><span class="n">getCustomerCityName</span><span class="p">();</span>
</code></pre></div></div>

<p>Wewnątrz tej metody nie powinno być kolejnego, nieco krótszego łańcucha tylko coś w tym rodzaju.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Order</span><span class="o">::</span><span class="n">getCustomerCityName</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">customer</span><span class="p">.</span><span class="n">getCityName</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Zaletą stosowania LoD jest zmniejszenie sprzężenia między klasami. Poprawia się również czytelność kodu.</p>

<h3 id="coi---niczym-klocki-lego">COI - niczym klocki Lego</h3>

<p>COI - Composition Over Inheritance, dziedziczenie to potężny mechanizm niosący za sobą bardzo cenną mechanikę - polimorfizm. Jednak ma ono też drugie oblicze, łatwo można przesadzić. Hierarchia dziedziczenia powinna odzwierciedlać zależności typu “jest”, a nie “ma”. Jeśli klasa dziedziczy po innej tylko dlatego, że część jej funkcjonalności by się przydała, to należy dodać potrzebny obiekt jako nowe pole klasy zamiast po niej dziedziczyć.</p>

<p>Ta zasada nie mówi o tym, by z dziedziczenia nie korzystać, lecz o tym, by korzystać z niego mądrze. Kompozycja daje nam większą elastyczność kodu. Elementy, jako że są to pola klasy, można łatwo dodawać, usuwać czy wymieniać. Wewnętrzna implementacja klasy rodzica, może się zmienić i dużo łatwiej ta zmiana może negatywnie odbić się na naszej klasie, gdy po niej dziedziczy, niż gdy jest tylko polem.</p>

<p>Kompozycja ułatwia też testowanie naszej klasy. Tworząc testy, możemy łatwo zastąpić pola klasy mockami poprzez wstrzykiwanie zależności (Dependency Injection). W ten sposób będziemy mogli skupić się na przetestowaniu logiki tylko naszej klasy. W przypadku dziedziczenia, nie możemy już w tak łatwy sposób oddzielić logiki naszej klasy od logiki rodzica. Musimy nie jako przetestować całość, mimo iż klasa rodzica ma swoje testy.</p>

<p>Dziedziczenie dużo mocniej wiąże ze sobą klasy, co utrudnia ich ponowne użycie. Jeśli nie tworzą spójnej całości, może się okazać, że zamiast ponownie skorzystać z już napisanego kodu, musimy nie jako napisać go od nowa. Boleśnie się o tym przekonałem, gdy zacząłem pisanie swojej drugiej gry. W pierwszej, mocno korzystałem z dziedziczenia, co sprawiło, że nie mogłem w prosty sposób przenieść fragmentu kodu. Musiałbym przenieść kilka klas na raz. To doprowadziło do tego, że zamiast użyć kod ponownie, stał się on tylko przykładem, do którego zaglądam, implementując nową grę.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Shape</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Rectangle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Drawing rectangle</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ColoredRectangle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Rectangle</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ColoredRectangle</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">inputColor</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">color</span><span class="p">(</span><span class="n">inputColor</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Drawing "</span> <span class="o">&lt;&lt;</span> <span class="n">color</span> <span class="o">&lt;&lt;</span> <span class="s">" rectangle</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">color</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Mamy tutaj interfejs <strong>Shape</strong>. Klasa <strong>Rectangle</strong> dziedziczy po interfejsie i to jest jak najbardziej ok. Problem zaczyna się w klasie <strong>ColoredRectangle</strong>, która dziedziczy po <strong>Rectangle</strong>. Co się stanie, jeżeli zaczniemy potrzebować klasy kwadratu z obramowaniem albo animacją? Idąc za dziedziczeniem, utworzymy <strong>BorderedRectangle</strong> i <strong>AnimatedRectangle</strong>. A jeśli będziemy potrzebować kolorowego kwadratu z obramowaniem? Kolejna klasa. A teraz dołóżmy trójkąt. Co wtedy? <strong>Triangle</strong>, <strong>ColoredTriangle</strong>, <strong>BorderedTriangle</strong>, <strong>AnimatedTriangle</strong>? Klasy mnożą się w zastraszającym tempie! Spróbujmy zastosować COI w tym przypadku.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ColoredShape</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ColoredShape</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;</span> <span class="n">inputShape</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">inputColor</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">shape</span><span class="p">(</span><span class="n">inputShape</span><span class="p">),</span> <span class="n">color</span><span class="p">(</span><span class="n">inputColor</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Drawing "</span> <span class="o">&lt;&lt;</span> <span class="n">color</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="n">shape</span><span class="p">.</span><span class="n">draw</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">Shape</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">color</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Teraz mamy ogólną klasę <strong>ColoredShape</strong>, niezwiązaną bezpośrednio z <strong>Rectangle</strong>. Obie klasy mogą być przetestowane osobno. Dodanie nowego kształtu sprowadza się do utworzenia tylko jednej klasy. Dodanie nowego atrybutu również. Oczywiście i z tym można by powalczyć, tworząc jeszcze bardziej uniwersalne rozwiązanie, ale to tylko przykład.</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>I to już wszystkie najważniejsze zasady programowania, które każdy programista powinien znać i stosować, aby jego kod był wysokiej jakości. Celowo nie poruszyłem tutaj zestawu zasad SOLID, gdyż one bardziej tyczą się projektowania. Przyjdzie i na to czas :). Tymczasem dziękuję Ci za dotrwanie do końca wpisu. Mam nadzieję, że przekazana tutaj wiedza pomoże Ci w codziennych bataliach z kodem. Jeśli masz pomysły na inne tematy, które mógłbym poruszyć na blogu - napisz w komentarzu.</p>

<p>Mój blog oparty jest na GitHub’ie, stąd trzeba się zalogować do niego, ale spokojnie, to jest odizolowany fragment strony, do którego nie mam bezpośredniego dostępu ;). Podobał Ci się ten wpis? Zapraszam do podzielenia się swoją opinią w komentarzu!</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="clean code" /><category term="clean code" /><category term="code quality" /><category term="developer practices" /><category term="software" /><summary type="html"><![CDATA[Te tajemnicze akronimy skrywają w sobie dekady doświadczeń naszych programistycznych poprzedników. Choć brzmi to nieco patetycznie, tak właśnie jest. Zasady, opisane w tym wpisie, to dziedzictwo wielu błędów, obserwacji i celnych spostrzeżeń, zbieranych latami przez bardzo doświadczonych ludzi dla ich następców. Te zasady działają jak sita. Przesiany przez nie kod staje się znacznie lepszy, bardziej czytelny, odporny na błędy i łatwiejszy w utrzymaniu.]]></summary></entry><entry><title type="html">Wątki i wyjątki. Jak radzić sobie z nieoczekiwanymi zachowaniami w wielowątkowym kodzie.</title><link href="/multithreading/exception-in-thread/" rel="alternate" type="text/html" title="Wątki i wyjątki. Jak radzić sobie z nieoczekiwanymi zachowaniami w wielowątkowym kodzie." /><published>2025-10-13T00:00:00+02:00</published><updated>2025-10-13T00:00:00+02:00</updated><id>/multithreading/exception-in-thread</id><content type="html" xml:base="/multithreading/exception-in-thread/"><![CDATA[<p>Nieoczekiwane zachowanie czyli wyjątek to sytuacja, w której nasz kod zachował się w sposób, który normalnie nie występuje. Może być to wywołane problemami z zasobami jak brak pamięci podręcznej lub brak dostępu do pliku. Powodów może być wiele, najczęściej nie zależą od nas. Jednak możemy się na takie sytuacje przygotować i pomimo wystąpienia wyjątków, nasz program nie przerwie działania.</p>

<h3 id="rodzaje-wyjątków">Rodzaje wyjątków</h3>

<p>Rodzajów wyjątków w STL mamy całkiem sporo i są one pogrupowane w podklasy dziedziczące po <strong>std::exception</strong>. I tak mamy na przykład <strong>std::runtime_error</strong>, który sam w sobie nie jest zgłaszany, jest jednak klasą bazową dla innych, między innymi <strong>std::range_error</strong>, <strong>std::overflow_error</strong>, <strong>std::underflow_error</strong>. Część wyjątków dodana została w późniejszych wersjach C++.</p>

<p>Wyjątki dotyczą różnych problemów, na które nasz program może natrafić, brak elementu w kontenerze - <strong>std::out_of_range</strong>, rzutowanie referencji typów niepołączonych hierarchią - <strong>std::bad_cast</strong> (przy wskaźnikach dostaniemy <strong>nullptr</strong>, a wyjątek nie jest rzucany) czy problemy z alokowaniem pamięci - <strong>std::bad_alloc</strong>. To tylko kilka przykładów, po dokładne szczegóły odsyłam do dokumentacji: <a href="https://en.cppreference.com/w/cpp/error/exception.html" target="_blank" rel="noopener">“std::exception”</a>.</p>

<p>Prócz standardowych wyjątków, możemy również zdefiniować własne, po prostu dziedzicząc po <strong>std::exception</strong> lub jej klasie pochodnej.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ReadFileException</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">ReadFileException</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">inputFileName</span><span class="p">)</span>
	 <span class="o">:</span> <span class="n">fileName</span><span class="p">(</span><span class="n">inputFileName</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">fileName</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
	<span class="p">}</span>

<span class="nl">private:</span>
	<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fileName</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="rzucanie-iłapanie-wyjątków">Rzucanie i łapanie wyjątków</h3>

<p>Rzucanie wyjątków w C++ jest banalnie proste, wystarczy użyć słowa kluczowego <strong>throw</strong> na obiekcie klasy wyjątka. Najczęściej będzie to obiekt tymczasowy. Jeszcze nie spotkałem się, z potrzebą składowania obiektów wyjątków, niemniej jest to jak najbardziej możliwe.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">throw</span> <span class="nf">ReadFileException</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">);</span>
</code></pre></div></div>

<p>Jak widać, rzucanie wyjątków jest proste, łatwe i czytelne. Inaczej jest z ich łapaniem. Obsługa wyjątków C++ jest już bardziej złożona. Do przechwytywania wyjątków służy blok <strong>try/catch</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fileHandler</span><span class="p">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">fileContent</span><span class="p">{</span> <span class="n">fileHandler</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">};</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadFileException</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cannot read file: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Block <strong>try</strong> jest prosty, to w nim umieszczamy kod, który może rzucić wyjątek. Block <strong>catch</strong> służy do przechwytywania wyjątków określonego typu oraz ich obsługi, na przykład zwolnienie zasobów takich jak pamięć czy mutex. Po opuszczeniu bloku <strong>catch</strong>, praca programu będzie kontynuowana. Bloków <strong>catch</strong> może być wiele, w zależności od tego jakie operacje muszą zostać wykonane w stosunku do typu rzuconego wyjątku.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fileHandler</span><span class="p">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">fileContent</span><span class="p">{</span> <span class="n">fileHandler</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">};</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadFileException</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cannot read file: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" with code: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dodatkowo wyjątki łapane są według hierarchii dziedziczenia, to znaczy, że jeśli nie zdefiniujemy w bloku <strong>catch</strong> określonego typu wyjątku, ale jego rodzica już tak, to ten wyjątek również zostanie obsłużony.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fileHandler</span><span class="p">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">fileContent</span><span class="p">{</span> <span class="n">fileHandler</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">};</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" with code: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="c1">// ReadFileException zostanie tutaj przechwycony</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cannot read file: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Należy zwrócić uwagę na hierarchię dziedziczenia, jeśli pierwszy blok <strong>catch</strong> będzie ustawiony na klasę bazową, a następny na klasę pochodną, to wyjątek nigdy nie zostanie złapany przez drugi blok <strong>catch</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fileHandler</span><span class="p">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">fileContent</span><span class="p">{</span> <span class="n">fileHandler</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">};</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="c1">// Wyjątek typu std::system_error dziedziczy po std::exception i&amp;nbsp;zostanie tutaj przechwycony</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cannot read file: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="c1">// Ten kod nigdy się nie wykona</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" with code: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Kompilator może nas poinformować ostrzeżeniem w stylu:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main.cpp:71:1: warning: exception of <span class="nb">type</span> ‘std::system_error’ will be caught by earlier handler <span class="o">[</span><span class="nt">-Wexceptions</span><span class="o">]</span>
   71 | catch<span class="o">(</span>const std::system_error&amp; ex<span class="o">)</span>
      | ^~~~~
main.cpp:66:1: note: <span class="k">for </span><span class="nb">type</span> ‘std::exception’
   66 | catch<span class="o">(</span>const std::exception&amp; ex<span class="o">)</span>
      | ^~~~~
</code></pre></div></div>

<p>Bywają jednak takie sytuacje, gdy chcemy, by każdy wyjątek obsłużyć tak samo i nie ma dla nas znaczenia jaki to typ. Jest na to sposób. C++ nieczęsto stosuje składnię z użyciem wielokropka (<strong>…</strong>). To właśnie jeden z tych przypadków.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fileHandler</span><span class="p">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">fileContent</span><span class="p">{</span> <span class="n">fileHandler</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">};</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(...)</span> <span class="c1">// Łapiemy wszystkie wyjątki lecz kosztem braku informacji z&amp;nbsp;metody what()</span>
<span class="p">{</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wielokropek powinien być używany jako ostatni blok <strong>catch</strong>. Nie zalecałbym takiej obsługi wyjątków jako domyślny sposób. Niemniej, warto wiedzieć o jego istnieniu ;).</p>

<p>Wszystkie te sposoby obsługi wyjątków się łączą. Możemy dowolnie definiować liczbę i rodzaje bloków <strong>catch</strong> (zgodnie z hierarchią dziedziczenia). Możemy także zagnieżdżać całe bloki <strong>try/catch</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fileHandler</span><span class="p">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="k">auto</span> <span class="n">fileContent</span><span class="p">{</span> <span class="n">fileHandler</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">};</span>
            <span class="c1">//...</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadFileException</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cannot read file: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" with code: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(...)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Something unexpected happened!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Trzeba jednak zachować umiar bo możemy skończyć z bardzo nieczytelnym kodem, w którym ciężko w szybki sposób zweryfikować, w który blok <strong>catch</strong> wyjątek zostanie złapany.</p>

<p>C++11 udostępnia nam też słowo kluczowe <strong>noexcept</strong>, którym możemy oznaczyć funkcje i metody nierzucające wyjątków. Czyli takie, które używają operacji bezpiecznych pod względem wyjątków i/lub same je obsługują. Słowo kluczowe <strong>noexcept</strong> możemy także zastosować do konstruktorów i destruktora klasy.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">&amp;</span><span class="n">nbsp</span><span class="p">;</span><span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">FileHandler</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">FileHandler</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="o">~</span><span class="n">FileHandler</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">openFile</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fileName</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">read</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">closeFile</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="n">File</span> <span class="n">file</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Żeby móc oznaczyć funkcję lub metodę jako <strong>noexcept</strong>. Wszystkie operacje i wywoływane funkcje/metody także powinny być oznaczone jako <strong>noexcept</strong>, by zachować bezpieczeństwo w kontekście wyjątków. Niestety kompilator nas nie poinformuje, jeżeli ten warunek nie jest spełniony. 
Co jeśli oznaczymy naszą funkcję/metodę jako <strong>noexcept</strong>, a z jakiegoś powodu jednak rzuci wyjątek? Specyfikacja podpowiada, że zostanie wywołana funkcja <strong>std::terminate()</strong>, która zakończy działanie naszego programu niezależnie od tego czy dany kod był w bloku <strong>try/catch</strong> czy nie.</p>

<p><strong>noexcept</strong> jest równoznaczne z <strong>noexcept(true)</strong>. Natomiast domyślnie wszystkie funkcje i metody oznaczone są jako <strong>noexcept(false)</strong>. Dlaczego dodano osobno <strong>noexcept</strong> oraz <strong>noexcept(true/false)</strong>? Głównie ze względu na szablony i metaprogramowanie, gdzie o tym czy funkcja lub metoda może lub nie może rzucać wyjątków kompilator dowiaduje się dopiero w trakcje kompilacji i konkretyzacji szablonów.</p>

<p><strong>noexcept</strong> jest traktowane jako część typu funkcji. To znaczy, że jeśli mamy wskaźniki na funkcje, które różnią się tylko <strong>noexcept</strong>, to będą one traktowane jako osobne typy. Tak samo jeżeli chodzi o parametry szablonu.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">funcPtr1</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">using</span> <span class="n">funcPtr2</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>noexcept</strong> nie można za to stosować do przeciążania funkcji, gdyż nie wchodzi w skład jej sygnatury.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// Błąd kompilacji, redefinicja funkcji "add"</span>
</code></pre></div></div>

<p>Zaletą <strong>noexcept</strong> jest przede wszystkim optymalizacja. Kompilator nie musi generować dodatkowego kodu do zwijania stosu po wystąpieniu wyjątku. Może także dobrać bardziej optymalne algorytmy STL. Łatwiej jest kompilatorowi inline’ować funkcję/metodę. Binarka wynikowa, również ma mniejszy rozmiar.</p>

<h3 id="przechwytywanie-wyjątku-wewnątrz-wątku">Przechwytywanie wyjątku wewnątrz wątku</h3>

<p>Przejdźmy teraz do wielowątkowego przechwytywania wyjątków. Nie jest to rzecz taka prosta. Spójrz na ten kod, czy jest on bezpieczny pod względem wyjątków?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">calucalteSumThread</span><span class="p">;</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">calucalteSumThread</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([]()</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"calculation error!"</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(...)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Something unexpected happened!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">calucalteSumThread</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">calucalteSumThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wydawać by się mogło, że tak. Przecież mamy blok <strong>catch</strong> zarówno na wyrzucany wyjątek <strong>std::runtime_error</strong> jak i <strong>…</strong>. Jednak tak nie jest. Po uruchomieniu tego kodu w prostej funkcji <strong>main</strong> zostanie wywołany <strong>std::terminate()</strong>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>terminate called after throwing an instance of <span class="s1">'std::runtime_error'</span>
  what<span class="o">()</span>:  calculation error!
</code></pre></div></div>

<p>Dzieje się tak dlatego, że wątek traktowany jest jako osobny proces pomimo, iż należy do głównego wątku naszej aplikacji. Jednym z rozwiązań tego problemu jest obsługa wyjątków wewnątrz wątku i nie wyrzucanie ich na zewnątrz, tworząc wątek bezpieczny względem wyjątków.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">calucalteSumThread</span><span class="p">;</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">calucalteSumThread</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([]()</span>
    <span class="p">{</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"calculation error!"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(...)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Something unexpected happened!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">calucalteSumThread</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">calucalteSumThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wynikiem będzie tylko komunikat przechwyconego wyjątku, a nasz program będzie kontynuował pracę:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>calculation error!
</code></pre></div></div>

<h3 id="przekierowanie-wyjątku-do-wątku-głównego">Przekierowanie wyjątku do wątku głównego</h3>

<p>Tworzenie osobnego bloku <strong>try/catch</strong> w wątku i poza nim może doprowadzić do niepotrzebnej złożoności. Możemy też potrzebować obsłużyć wyjątek w głównym wątku naszej aplikacji, gdy wyjątek wystąpi wewnątrz wątku, aby poprawnie zareagować na taką sytuację. C++ od wersji 11 wraz z całą obsługą wyjątków daje nam kilka narzędzi, które rozwiązują ten problem: <strong>std::async</strong>, <strong>std::packaged_task</strong> i <strong>promise</strong>. Każde z nich umożliwia przekierowanie wyjątków z wątku pobocznego do wątku głównego.</p>

<p>Zacznijmy od <strong>std::async</strong>. To szablon funkcji o zmiennej liczbie parametrów umożliwiający uruchomienie przekazanej funkcji lub metody w osobnym wątku. Zwraca obiekt <strong>std::future</strong>, który po wywołaniu metody <strong>get()</strong> zwróci wynik lub wyjątek jeśli wystąpił.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">exceptionFutureObj</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]()</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"calculation error!"</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">exceptionFutureObj</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Widać tutaj prostotę tego rozwiązania. Wątek poboczny nie zawiera już bloku <strong>try/catch</strong>. Cała obsługa wyjątku dzieje się pod spodem <strong>std::async</strong>. Kod jest czysty i zrozumiały. By mieć pewność, że funkcja przekazana jako parametr uruchomi się w osobnym wątku, trzeba ustawić tryb uruchamiania na <strong>std::launch::async</strong>. W trybie <strong>std::launch::deffered</strong> funkcja zostanie uruchomiona w tym samym wątku dopiero w momencie wywołania metody <strong>get()</strong> lub <strong>wait()</strong> na zwróconym przez <strong>async</strong> obiekcie <strong>future</strong>. Domyślnie, to implementacja decyduje jaki tryb uruchamiania zostanie wykorzystany.</p>

<p>Drugim narzędziem, którym możemy przekazać wyjątki z wątku pobocznego do głównego jest <strong>std::packaged_task</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">([]()</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"calculation error!"</span><span class="p">);</span>
<span class="p">});</span>
<span class="k">auto</span> <span class="n">exceptionFutureObj</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">exceptionTaskThread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">exceptionFutureObj</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">exceptionTaskThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div>

<p>Pod względem przechwytywania wyjątków <strong>async</strong> i <strong>std::packaged_task</strong> działają tak samo. Oba zwracają obiekt typu <strong>future</strong> i w momencie pobierania wartości zwracanej (<strong>get()</strong>), wyjątek może zostać przechwycony. Zasadnicza różnica pomiędzy nimi jest moment, w którym wątek zostaje uruchomiony. Przy <strong>async</strong>  (z ustawionym <strong>std::launch::async</strong>), w momencie wywoływania. Przy <strong>std::packaged_task</strong>, dopiero, gdy task zostanie przekazany do nowego wątku.</p>

<p>Ostatni sposób na przekazanie wyjątków z wątku pobocznego do głównego, to <strong>std::promise</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">exceptionPromise</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">exceptionFutureObj</span> <span class="o">=</span> <span class="n">exceptionPromise</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">exceptionTaskThread</span><span class="p">([</span><span class="o">&amp;</span><span class="n">exceptionPromise</span><span class="p">]()</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"calculation error!"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(...)</span>
    <span class="p">{</span>
        <span class="n">exceptionPromise</span><span class="p">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">exceptionFutureObj</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">exceptionTaskThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div>

<p>Widać tutaj od razu, że blok <strong>try/catch</strong> powrócił do ciała naszego wątku pobocznego. Mimo to, jedynym dla nas potrzebnym blokiem <strong>catch</strong> jest ten z wielokropkiem, gdyż zależy nam na przekazywaniu wyjątków do wątku głównego. <strong>promise</strong> daje nam największą kontrolę nad tym, kiedy wątek zostanie uruchomiony, kiedy i jaki wyjątek zostanie przekazany wyżej. Możemy także przekazać jakąś wartość w <strong>std::promise</strong>, w polu <strong>value</strong>. Może w celu debuggowym albo jako wartość domyślną. Zależy od tego co będzie nam potrzebne.</p>

<h3 id="wielokrotne-przechwytywanie-wyjątków">Wielokrotne przechwytywanie wyjątków</h3>

<p>Na koniec jeszcze kwestia przechwytywania wyjątków z różnych wątków pobocznych w wątku głównym. Gdy przy użyciu <strong>std::async</strong>, uruchomimy dwa wątki i w obu zostaną wyrzucone wyjątki to musimy zadbać o to, by każdy został poprawnie obsłużony.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">exceptionFutureObj1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"First thread</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"calculation error!"</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">auto</span> <span class="n">exceptionFutureObj2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Second thread</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_error_code</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">errc</span><span class="p">(</span><span class="n">EDEADLK</span><span class="p">)),</span> <span class="s">"system error!"</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">exceptionFutureObj2</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="c1">// Rzucenie wyjątku std::system_error, przejście do bloku catch</span>
    <span class="n">exceptionFutureObj1</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" with code: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A tutaj wynik działania powyższego fragmentu kodu:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>First thread
Second thread
system error!: Resource deadlock avoided with code: generic:35
</code></pre></div></div>

<p>W tym przypadku, pomimo, iż oba wątki zostały uruchomione, i oba z pewnością rzuciły wyjątki to tylko jeden zostanie przechwycony. Nie liczy się moment rzucenia wyjątku, a moment odebrania wyniku z obiektu <strong>future</strong>. Dopiero wtedy wyjątek rzucany jest w wątku głównym. Dlatego w powyższym przykładzie, wyjątek <strong>std::runtime_error</strong> nie został przechwycony. Drugi <strong>get()</strong> po prostu się nie wykonał.</p>

<p>Aby uniknąć takich sytuacji należy każdą próbę odebrania wyniku z <strong>future</strong> opakować blokiem <strong>try/catch</strong> osobno. Możemy do tego utworzyć szablonowy handler.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Future</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">exceptionHandler</span><span class="p">(</span><span class="n">Future</span><span class="o">&amp;</span> <span class="n">future</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">future</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">numOfThreads</span><span class="p">{</span> <span class="mi">5</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">futures</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">numOfThreads</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">futures</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[</span><span class="n">idx</span><span class="p">]()</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Thread nr: "</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"error from thread: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
        <span class="p">}));</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">future</span> <span class="o">:</span> <span class="n">futures</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">exceptionHandler</span><span class="p">(</span><span class="n">future</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A oto wynik:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Thread nr: 0Thread nr: 1
Thread nr: 2

Thread nr: 4
Thread nr: 3
error from thread: 0
error from thread: 1
error from thread: 2
error from thread: 3
error from thread: 4
</code></pre></div></div>

<p>Jak widać wszystkie wyjątki zostały przechwycone. Widać też asynchroniczność w logowaniu do <strong>std::cout</strong>. W takim przypadku lepiej użyć jakiegoś własnego loggera bezpiecznego dla wątków.</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>W tym wpisie, starałem się zebrać wszystkie najważniejsze informacje dotyczące wyjątków w C++. Od tego jakie wyjątki są dostępne w tym języku programowania, poprzez ich rzucanie i obsługę, kończąc na przekazywaniu ich pomiędzy wątkami. C++ wciąż się zmienia i ewoluuje. Może w przyszłości dojdą nowe mechanizmy związane z wyjątkami. Choć trzeba przyznać, że już teraz mamy spory wachlarz narzędzi do radzenia sobie z nimi :).</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="multithreading" /><category term="cpp" /><category term="exceptions" /><category term="multithreading" /><category term="software" /><summary type="html"><![CDATA[Nieoczekiwane zachowanie czyli wyjątek to sytuacja, w której nasz kod zachował się w sposób, który normalnie nie występuje. Może być to wywołane problemami z zasobami jak brak pamięci podręcznej lub brak dostępu do pliku. Powodów może być wiele, najczęściej nie zależą od nas. Jednak możemy się na takie sytuacje przygotować i pomimo wystąpienia wyjątków, nasz program nie przerwie działania.]]></summary></entry><entry><title type="html">AAA - złoty standard unit testów.</title><link href="/unit%20testing/AAA-golden-standard/" rel="alternate" type="text/html" title="AAA - złoty standard unit testów." /><published>2025-09-15T00:00:00+02:00</published><updated>2025-09-15T00:00:00+02:00</updated><id>/unit%20testing/AAA-golden-standard</id><content type="html" xml:base="/unit%20testing/AAA-golden-standard/"><![CDATA[<p>Arrange Act Assert – to game changer dla jakości unit testów. Dzięki tym prostym zasadom testy stają się nie tylko bardziej czytelne, lecz mogą stanowić doskonałą dokumentację przypadków użycia naszego kodu. Dzielimy nazwę, jak i kod naszego unit testu, na trzy jasno określone bloki.</p>

<p>A czym jest to całe AAA? Zacznijmy od początku.</p>

<h3 id="aaa---złoty-standard">AAA - złoty standard</h3>

<p>O zasadzie AAA (triple A) piszę w swojej świetnej książce: <a href="https://lubimyczytac.pl/ksiazka/243300/testy-jednostkowe-swiat-niezawodnych-aplikacji" target="_blank" rel="noopener">“Testy jednostkowe. Świat niezawodnych aplikacji”</a> (The Art of Unit Testing) - Roy Osherove. Nie jest on wprawdzie jej bezpośrednim autorem, lecz wielkim fanem, zresztą nie tylko on ;). AAA wywodzi się ze środowiska .NET, niemniej, nie jest zależna od użytej technologii. Świetnie sprawdza się również w świecie C++.</p>

<p>No dobrze, ale czym ta zasada jest i o czym mówi?</p>

<p>AAA - mówi o tym, by podzielić test na trzy logiczne bloki: Arrange, Act i Assert.</p>

<h3 id="arrange">Arrange</h3>

<p>W pierwszym bloku kodu naszego testu przygotowujemy wszystko, co niezbędne, aby naszą testowaną metodę lub funkcję sprawdzić. Przygotowujemy dane wejściowe oraz oczekiwane dane wyjściowe. Tworzymy stuby i mocki oraz ustawiamy ich niezbędne zachowanie względem naszej testowanej jednostki. W tym bloku możemy także wywołać inne metody testowanej klasy, jeśli są nam potrzebne do uzyskania odpowiedniego stanu obiektu. Oczywiście te metody również powinny być zweryfikowane w osobnych testach.</p>

<h3 id="act">Act</h3>

<p>Drugim blokiem jest uruchomienie naszej testowanej metody/funkcji. Najczęściej będzie to pojedyncza linijka kodu, ale nie zawsze. Czasem bywa tak, że działanie naszej testowanej metody jest inne, gdy wywołamy ją kilkukrotnie. Jeśli to jest przedmiotem naszego unit testu, to wtedy jak najbardziej również umieszczamy wszystkie wywołania w bloku <strong>Act</strong>.</p>

<h3 id="assert">Assert</h3>

<p>Trzecim i ostatnim blokiem jest weryfikacja. Tutaj sprawdzamy, czy wartości zwracane przez naszą jednostkę są zgodne z oczekiwanymi. Również tutaj weryfikujemy stan obiektu, jeśli jest to oczekiwane zachowanie testowanej metody. Można spotkać się z zasadą “jedna asercja na test”. Jeśli potraktujemy ją dosłownie, to powielimy testy tylko po to, by zachować tę zasadę i wywoływać pojedynczy ASSERT w teście. Lecz nie o to w niej chodzi, tylko o spójny kontekst asercji. Samych wywołań może być więcej, jeśli tylko są one ściśle powiązane.</p>

<h3 id="przykład-użycia-triplea">Przykład użycia triple A</h3>

<p>Spójrz na poniższy przykład testu niekorzystającego z AAA, czy potrafisz odgadnąć co jest w zasadzie testowane?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">testCollectingTemperatures</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TemperatureSensorManager</span> <span class="n">manager</span><span class="p">;</span>

    <span class="n">TemperatureSensorFactoryStub</span> <span class="n">factory</span><span class="p">;</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">expectedSensorName1</span><span class="p">{</span> <span class="s">"temp_core_1"</span> <span class="p">};</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">addSensor</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">expectedSensorName1</span><span class="p">,</span> <span class="mf">47.3</span><span class="p">));</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">expectedSensorName2</span><span class="p">{</span> <span class="s">"temp_core_2"</span> <span class="p">};</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">addSensor</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">expectedSensorName2</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.0</span><span class="p">));</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">expectedSensorName3</span><span class="p">{</span> <span class="s">"temp_board_0"</span> <span class="p">};</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">addSensor</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">expectedSensorName3</span><span class="p">,</span> <span class="mf">65.1</span><span class="p">));</span>

    <span class="k">auto</span> <span class="n">temps</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">getTemps</span><span class="p">();</span>
    <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedSensorName1</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getName</span><span class="p">());</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedSensorName2</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">getName</span><span class="p">());</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedSensorName3</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">getName</span><span class="p">());</span>

    <span class="n">EXPECT_FLOAT_EQ</span><span class="p">(</span><span class="mf">34.13</span><span class="p">,</span> <span class="n">manager</span><span class="p">.</span><span class="n">getAvgTemp</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A teraz ten sam test, tylko sformatowany zgodnie z triple A(na co dzień nie dodaję takich komentarzy ;) ):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">testCollectingTemperatures</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//Arrange</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">expectedSensorName1</span><span class="p">{</span> <span class="s">"temp_core_1"</span> <span class="p">};</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">expectedSensorName2</span><span class="p">{</span> <span class="s">"temp_core_2"</span> <span class="p">};</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">expectedSensorName3</span><span class="p">{</span> <span class="s">"temp_board_0"</span> <span class="p">};</span>
    <span class="n">TemperatureSensorFactoryStub</span> <span class="n">factory</span><span class="p">;</span>
    <span class="n">TemperatureSensorManager</span> <span class="n">manager</span><span class="p">;</span>

    <span class="c1">//Act</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">addSensor</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">expectedSensorName1</span><span class="p">,</span> <span class="mf">47.3</span><span class="p">));</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">addSensor</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">expectedSensorName2</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.0</span><span class="p">));</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">addSensor</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">expectedSensorName3</span><span class="p">,</span> <span class="mf">65.1</span><span class="p">));</span>

    <span class="c1">//Assert</span>
    <span class="k">auto</span> <span class="n">temps</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">getTemps</span><span class="p">();</span>
    <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedSensorName1</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getName</span><span class="p">());</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedSensorName2</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">getName</span><span class="p">());</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedSensorName3</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">getName</span><span class="p">());</span>
    <span class="n">EXPECT_FLOAT_EQ</span><span class="p">(</span><span class="mf">34.13</span><span class="p">,</span> <span class="n">manager</span><span class="p">.</span><span class="n">getAvgTemp</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Od razu widać, co jest przedmiotem testu, co jest wymagane na początku oraz jaki wynik będzie oczekiwany. Mimo iż sama nazwa testu nie mówi nam wiele, szybkie spojrzenie na kod daje jednak jasny obraz tego, co unit test sprawdza. No właśnie, nazwa testu… czy można coś z tym zrobić?</p>

<h3 id="nazwa-testu">Nazwa testu</h3>

<p>Standard AAA możemy również wykorzystać przy nadawaniu nazw unit testów. Główną zaletą AAA jest poprawa czytelności testów. Dobra nazwa to nie taka prosta sprawa, jeśli nie zna się przydatnych wytycznych.
Dla przykładu zwykła lub “zła” nazwa testu:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorTests</span><span class="p">,</span> <span class="n">test_no_avg_temp</span><span class="p">)</span>
</code></pre></div></div>

<p>Czy domyślasz się, co jest testowane? W jakich warunkach? Co jest wynikiem testu?
Jeśli się domyślasz, ale tego nie wiesz, już po samej nazwie, to nie jest ona do końca trafiona, prawda?</p>

<p>Ok, spróbujmy teraz z taką nazwą:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorTests</span><span class="p">,</span> <span class="n">calculateAverageTemp_emptyTemperatureInput_ReturnZero</span><span class="p">)</span>
</code></pre></div></div>

<p>Lepiej? Nie wiem jak dla Ciebie, ale dla mnie, tak! Zdecydowanie widać co jest testowane, jak i co będzie wynikiem.
Tym właśnie jest AAA - trzy części nazwy unit testu, w skrócie, schemat budowy nazwy testów wygląda tak:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TestowanaKlasaTest</span><span class="p">,</span> <span class="n">nazwaTestowanejMetody_ScenariuszTestowyZawieraj</span><span class="err">ą</span><span class="n">cyDaneWej</span><span class="err">ś</span><span class="n">ciowe_WynikCzyliToCoMaSi</span><span class="err">ę</span><span class="n">Sta</span><span class="err">ć</span><span class="n">PoWykonaniuTestowanejMetody</span><span class="p">)</span>
</code></pre></div></div>

<p>Powróćmy do naszego przykładowego unit testu i zastosujmy AAA do jego nazwy. Znając wytyczne, zamiast takiej nazwy:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">testCollectingTemperatures</span><span class="p">)</span>
</code></pre></div></div>

<p>Powinniśmy otrzymać coś w tym rodzaju:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">addSensor_AddThreeValidSensors_StoreAllSensorsAndReturnCorrectAverageTemperature</span><span class="p">)</span>
</code></pre></div></div>

<p>Teraz, nie znając ciała testu, łatwo możemy określić co on robi. A dlaczego taki format, a nie inny? Dla przykładu zróbmy listę kilku takich nazw:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">addSensor_AddOneValidSensor_StoreSensorAndReturnAverageTemperatureSameAsSensorTemperature</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">addSensor_AddTwoSensorsOneValid_StoreOneSensorAndReturnAverageTemperatureSameAsSensorTemperature</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">addSensor_AddThreeSensorsAllNoValid_NotStoreAnySensorAndReturnZeroAsAverageTemperature</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">getTemps_NoAddedSensors_ReturnsEmptyContainer</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">getTemps_ThreeSensorsAdded_ReturnsThreeSensors</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">getAvgTemp_NoAddedSensors_ReturnsZero</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">getAvgTemp_AddedOneSensor_ReturnsSameTemperatureAsSensor</span><span class="p">)</span>
</code></pre></div></div>

<p>Przeglądając taki zestaw nazw, szybko zweryfikujemy, czy i jakie metody naszej klasy są przetestowane oraz w jakich warunkach. To miałem na myśli, pisząc o przypadkach użycia. Wystarczy nam lista nazw unit testów i mamy nie tylko zakres testowania, ale także funkcjonalne i zawsze aktualne sposoby użycia naszej klasy. Nawet osoba nietechniczna będzie w stanie ogarnąć, co jest testowane i w jakim zakresie. Nie musi analizować kodu testów.</p>

<h3 id="wyjątki-od-aaa">Wyjątki od AAA</h3>

<p>Od podziału na 3 bloki są pewne wyjątki. Możemy mieć sytuację, gdy chcemy, na przykład przetestować domyślne zachowanie konstruktora i w tym przypadku akurat nie mamy nic do zainicjalizowania. Wtedy po prostu bloku <strong>Arrange</strong> nie ma w teście i to jest ok.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">DoorsLockTests</span><span class="p">,</span> <span class="n">constructor_DefaultBehavior_ShouldReturnEmptyTemps</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TemperatureSensorManager</span> <span class="n">manager</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">temps</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">getTemps</span><span class="p">();</span>
    <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Inny przykład, gdy jedynym oczekiwanym wynikiem naszej testowanej metody jest wartość przez nią zwrócona. Wtedy <strong>Act</strong> i <strong>Assert</strong> występują razem.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">getAvgTemp_NoAddedSensors_ReturnsZero</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TemperatureSensorManager</span> <span class="n">manager</span><span class="p">;</span>

    <span class="n">EXPECT_FLOAT_EQ</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">manager</span><span class="p">.</span><span class="n">getAvgTemp</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Możemy również dodać zmienną wynikową, by zachować podział na 3 bloki. Takie rozwiązanie też jest dobre.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">getAvgTemp_NoAddedSensors_ReturnsZero</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TemperatureSensorManager</span> <span class="n">manager</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">result</span><span class="p">{</span> <span class="n">manager</span><span class="p">.</span><span class="n">getAvgTemp</span><span class="p">()</span> <span class="p">};</span>

    <span class="n">EXPECT_FLOAT_EQ</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ostatnim przykładem może być test zawierający tylko jedną linijkę kodu.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">constructor_DefaultBehavior_ShouldNoThrowAnyException</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">EXPECT_NO_THROW</span><span class="p">(</span><span class="n">TemperatureSensorManager</span><span class="p">{});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Zauważ, że we wszystkich przykładach nazwa wciąż zawiera podział zgodny z AAA. Mimo, że samych bloków może brakować, to wciąż test jest czytelny i łatwy do zrozumienia.</p>

<h3 id="gwt">GWT</h3>

<p>W Internecie możesz spotkać się z nazwą GWT. To w zasadzie to samo.
GWT czyli Give(Arrnage) When(Act) Then(Assert). Ja osobiście wolę triple A ;)</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>I to już cały opis triple A. Mam nadzieję, że znajomość złotego standardu podniesie jakość także w Twoich testach. Jak dla mnie AAA naprawdę sporo wnosi i nie widzę żadnych przeciwwskazań do jego stosowania. Po prostu spróbuj!</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="unit testing" /><category term="clean code" /><category term="code quality" /><category term="developer practices" /><category term="refactoring" /><category term="software testing" /><summary type="html"><![CDATA[Arrange Act Assert – to game changer dla jakości unit testów. Dzięki tym prostym zasadom testy stają się nie tylko bardziej czytelne, lecz mogą stanowić doskonałą dokumentację przypadków użycia naszego kodu. Dzielimy nazwę, jak i kod naszego unit testu, na trzy jasno określone bloki.]]></summary></entry><entry><title type="html">Czym jest TDD i czy warto je stosować?</title><link href="/tdd/about-tdd/" rel="alternate" type="text/html" title="Czym jest TDD i czy warto je stosować?" /><published>2025-08-26T00:00:00+02:00</published><updated>2025-08-26T00:00:00+02:00</updated><id>/tdd/about-tdd</id><content type="html" xml:base="/tdd/about-tdd/"><![CDATA[<p>Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem.</p>

<h3 id="czym-jest-tdd">Czym jest TDD.</h3>

<p>Dla niektórych TDD to zasada, najpierw test (<strong>test first</strong>), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi jednak przyjrzyjmy się jej bliżej.</p>

<p>Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada <strong>test first</strong> to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie.</p>

<p>Metodologia TDD jest jedną z technik programowania ekstremalnego (<a href="https://en.wikipedia.org/wiki/Extreme_programming" target="_blank" rel="noopener">XP</a> - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować.</p>

<h3 id="cykl-pracy-wtdd">Cykl pracy w TDD</h3>

<p>We wpisie o <a href="https://cpptested.com/unit%20testing/first-reguly-ut/" target="_blank" rel="noopener">F.I.R.S.T.</a> wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządzmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe.</p>

<p><strong>Red</strong> - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach.</p>

<p><strong>Green</strong> - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”.</p>

<p><strong>Refactor</strong> - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post).</p>

<p>Pracując w cyklach, częstu uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla progamistów - “pustego ekranu” :) ).</p>

<h3 id="zalety-tdd">Zalety TDD</h3>

<p>Podczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii.</p>

<p><strong>1)</strong> Praca w TDD prowadzi do generowania kodu łatwego w testowaniu.
W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować.</p>

<p><strong>2)</strong> Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone.
Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni.</p>

<p><strong>3)</strong> Zyskujemy zaufanie, że nasza implementacja działa.
Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”.</p>

<p><strong>4)</strong> Konkretyzujemy wymagania, zanim kod jest napisany.
W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać.</p>

<p><strong>5)</strong> Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy.
Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty.</p>

<p><strong>6)</strong> Poczucie ciągłego postępu - zwiększona satysfakcja.
Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza.</p>

<h3 id="wady-tdd">Wady TDD</h3>

<p>TDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować.</p>

<p><strong>1)</strong> W mojej ocenie TDD nie jest łatwe do nauki.
Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nie raz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą.</p>

<p><strong>2)</strong> Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste.
Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać.</p>

<p><strong>3)</strong> Dodatkowy narzut czasowy.
Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem.</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>Porównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę.</p>

<p>W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - <a href="https://lubimyczytac.pl/ksiazka/223586/tdd-sztuka-tworzenia-dobrego-kodu" target="_blank" rel="noopener">TDD. Sztuka tworzenia dobrego kodu</a></p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="tdd" /><category term="clean code" /><category term="code quality" /><category term="developer practices" /><category term="refactoring" /><category term="test driven development" /><summary type="html"><![CDATA[Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem. Czym jest TDD. Dla niektórych TDD to zasada, najpierw test (test first), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi jednak przyjrzyjmy się jej bliżej. Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada test first to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie. Metodologia TDD jest jedną z technik programowania ekstremalnego (XP - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować. Cykl pracy w TDD We wpisie o F.I.R.S.T. wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządzmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe. Red - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach. Green - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”. Refactor - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post). Pracując w cyklach, częstu uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla progamistów - “pustego ekranu” :) ). Zalety TDD Podczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii. 1) Praca w TDD prowadzi do generowania kodu łatwego w testowaniu. W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować. 2) Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone. Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni. 3) Zyskujemy zaufanie, że nasza implementacja działa. Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”. 4) Konkretyzujemy wymagania, zanim kod jest napisany. W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać. 5) Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy. Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty. 6) Poczucie ciągłego postępu - zwiększona satysfakcja. Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza. Wady TDD TDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować. 1) W mojej ocenie TDD nie jest łatwe do nauki. Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nie raz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą. 2) Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste. Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać. 3) Dodatkowy narzut czasowy. Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem. Podsumowanie Porównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę. W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - TDD. Sztuka tworzenia dobrego kodu Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn]]></summary></entry><entry><title type="html">F.I.R.S.T. - jak pisać unit testy lepiej.</title><link href="/unit%20testing/first-reguly-ut/" rel="alternate" type="text/html" title="F.I.R.S.T. - jak pisać unit testy lepiej." /><published>2025-07-28T00:00:00+02:00</published><updated>2025-07-28T00:00:00+02:00</updated><id>/unit%20testing/first-reguly-ut</id><content type="html" xml:base="/unit%20testing/first-reguly-ut/"><![CDATA[<p>F.I.R.S.T. to pewien standard, jaki unit testy powinny spełniać. To zbiór założeń, które wyznaczają kierunek, jaki powinniśmy obierać, pisząc testy.</p>

<h3 id="f-jak-fast">F jak Fast</h3>

<p>Czas oczekiwania na wynik naszych unit testów powinien być jak najkrótszy.</p>

<p>Znani i cenieni specjaliści, jak Robert C. Martin czy Kent Beck, w swoich książkach przytaczają związek między czasem wykonywania testów, a ich regularnym uruchamianiem.
Jeśli testy “kręcą się” kilka lub kilkanaście minut, często zniechęca to programistów do regularnego ich uruchamiania. Dodatkowo,  gdy weźmiemy pod uwagę Test Driven Development, to praktycznie paraliżuje to rozwój kodu i rodzi sporo frustracji.</p>

<p>Kiedy testy “kręcą się” za długo? Tutaj sprawa już nie jest taka prosta. Czy 5 s jest OK? Myślę, że tak. 30 s – jeszcze akceptowalne. 1–2 min? Tutaj już może pojawić się myśl: “Czy zdążę zrobić sobie kawę/herbatę?”
Gdy zaczynamy myśleć o zrobieniu czegoś innego, oczekując na wyniki unit testów, to już jest znak, że trwa to za długo. Gdy pracujemy w TDD, to zmiany często są minimalne, trwające kilka sekund. Nie możemy pozwolić, by ich weryfikacja trwała kilkukrotnie dłużej, bo wybije nas to z rytmu.</p>

<p>Przyczyn długiego oczekiwania na zakończenie unit testów może być kilka:</p>

<p><strong>1)</strong> Sleepy w testach.
   Jeśli w naszych unit testach korzystamy z czasowych opóźnień, to często jest to związane z timerami użytymi w logice naszego kodu.</p>

<p><strong>2)</strong> Dostęp do plików.
   Pojedynczy przypadek raczej nie wpłynie znacząco na czas wykonywania unit testów. Gdy takich odczytów jest więcej, zaczynają one mieć znaczenie.</p>

<p><strong>3)</strong> Zewnętrzny framework do przesyłania message’y/eventów.
   Jeśli nasz kod produkcyjny korzysta z takich rozwiązań, może to w testach doprowadzić do opóźnień. Na przykład, gdy  message nie przyjdzie na czas z powodu obciążenia sprzętu, na którym uruchamiamy testy (współdzielony serwer).</p>

<p>Z pewnością każdy z Was może znaleźć też inne przyczyny opóźnień. Najczęstszym rozwiązaniem jest wprowadzenie warstwy pośredniej, rodzaj interfejsu, aby móc zastąpić implementację problematycznych zależności mockami.</p>

<p>Warto pamiętać i dążyć do tego, aby czas oczekiwania na wyniki unit testów był jak najkrótszy. Podnosi to nie tylko jakość kodu, ale też satysfakcję z samej pracy z nim.</p>

<h3 id="i-jak-independent">I jak Independent</h3>

<p>Unit testy powinny być niezależne od siebie nawzajem, tak aby można było uruchomić je w dowolnej kolejności.</p>

<p>Sytuacja, w której jeden test nie przechodzi tylko dlatego, że inny również nie przeszedł, nie należy do zbyt komfortowych. Tracimy wtedy wiarę w wiarygodność testów. Dodatkowo zmiana w jednym teście wymusza zmianę również w innym.
Framework testowy Google Test domyślnie uruchamia testy w sposób losowy, dzięki czemu złamanie tej reguły powinno wyjść bardzo szybko.</p>

<p>Częstym powodem zależności między testami są zmienne globalne. Istnieją techniki odcinania zależności od zmiennych globalnych czy wolnych funkcji (niezwiązanych z żadnym obiektem).
W mojej ocenie jedną z najlepszych jest opakowanie użycia zmiennej globalnej (czy też funkcji) w metodę klasy w sekcji protected. Tak, aby można było przysłonić jej zachowanie w testach, tworząc klasę Testable.</p>

<p>Technik radzenia sobie ze zmiennymi globalnymi jest więcej i można je znaleźć w tak świetnych książkach jak “Praca z zastanym kodem” czy “Refaktoryzacja. Ulepszanie struktury istniejącego kodu”.</p>

<h3 id="r-jak-repeatable">R jak Repeatable</h3>

<p>Testy powinny być powtarzalne, niezależnie od środowiska, w którym je uruchomimy. Czy to będzie mój laptop, czy serwer firmowy – wyniki testów powinny być takie same.
Esencją braku tej zasady jest znane przez chyba wszystkich programistów zdanie: “U mnie działa.”
Świetnie, ale testy powinny działać wszędzie tam, gdzie się je uruchomi, i zwracać to samo.
Gdy unit test zwraca jeden wynik w środowisku A, a inny wynik w środowisku B – to znak, że ma on jakąś zależność, która powinna zostać odcięta.</p>

<p>Tutaj znów przyczyną może być dostęp do systemu plików. Gdy w jednym środowisku pliki istnieją, a w innym nie – testy zachowują się inaczej.</p>

<p>Inną przyczyną może być korzystanie ze zmiennych środowiskowych.
Tak czy inaczej – takie praktyki przeczą idei unit testów, jaką jest izolacja: odcięcie zewnętrznych zależności i testowanie małego fragmentu w przygotowanym do tego środowisku i scenariuszu.</p>

<p>W mojej ocenie korzystanie z zewnętrznych zależności w testach to droga na skróty, która w dłuższej perspektywie rodzi więcej problemów, niż daje korzyści.</p>

<h3 id="s-jak-self-validating">S jak Self-Validating</h3>

<p>Unit test powinien zwracać jednoznaczny wynik – test się powiódł lub nie.
Testy jednostkowe to jedno z wielu zautomatyzowanych narzędzi wspierających naszą pracę z kodem i podnoszących jego jakość.</p>

<p>Gdy musimy ręcznie weryfikować wyniki testów, marnujemy sporo czasu lub co gorasze, możemy błędnie odczytać ich wynik – dostarczając wadliwy kod lub niepotrzebnie debuggując go, gdy jednak jest poprawny, szukając błędu, który nie istnieje.
Jeśli test wymaga ręcznego sprawdzenia logów, by potwierdzić, czy testowany kod działa, to znaczy, że coś jest nie tak.</p>

<p>Czy możemy wtedy mówić o zautomatyzowanym teście? Zdecydowanie nie.
Informacja zwrotna powinna być jasna – Twój kod działa/nie działa.
Myślę, że ten punkt jest jasny i bez niego nie możemy mówić o cyklu TDD: Red → Green → Refactor. Bez jasnego sygnału, jak zakończyły się testy, nie możemy płynnie pracować w tym rytmie.</p>

<h3 id="t-jak-timely">T jak Timely</h3>

<p>Unit testy powinny być uruchamiane w odpowiednim czasie. W tym punkcie nie mówię o czasie wykonywania, ale o momencie, w którym uruchamiamy testy.</p>

<p>W Test Driven Development (TDD) mamy cykl Red → Green → Refactor, o którym już wspomniałem. Każdy cykl rozpoczyna się od napisania testu i od razu próby jego uruchomienia. Najczęściej kończy się on błędem kompilacji, gdyż nowa metoda, którą chcemy przetestować, jeszcze nie powstała. To też jest wynik “Red”.</p>

<p>Testy uruchamiamy tak często, jak to możliwe, i wprowadzamy zmiany iteracyjnie, małymi krokami. Dzięki takim krótkim cyklom szybko możemy wykryć regresję, a zakres zmian jest minimalny i łatwo możemy dojść do tego, gdzie popełniliśmy błąd.
Timely nie odnosi się już do tego, jak pisać unit testy, tylko jak ich używać - często :)</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>W tym wpisie starałem się przybliżyć pięć cech dobrych unit testów. Są to drogowskazy pomagające nam nie tylko pisać testy lepiej, ale przede wszystkim pracować z nimi na co dzień.
Trzymając się tych reguł, z pewnością odczujemy różnicę w codziennej pracy – zyskując kontrolę nad zmianami, większe zaufanie do kodu i pewność, że nie wprowadzimy regresji.</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="unit testing" /><category term="clean code" /><category term="software testing" /><category term="code quality" /><category term="refactoring" /><category term="developer practices" /><summary type="html"><![CDATA[F.I.R.S.T. to pewien standard, jaki unit testy powinny spełniać. To zbiór założeń, które wyznaczają kierunek, jaki powinniśmy obierać, pisząc testy.]]></summary></entry></feed>