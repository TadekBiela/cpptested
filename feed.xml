<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://cpptested.com/feed.xml" rel="self" type="application/atom+xml" /><link href="https://cpptested.com/" rel="alternate" type="text/html" /><updated>2026-02-24T09:20:13+01:00</updated><id>https://cpptested.com/feed.xml</id><title type="html">CppTested</title><subtitle>Blog o TDD, unit testach, nowoczesnym C++ i wielowątkowości. Jak pisać lepszy, bezpieczniejszy i bardziej przewidywalny kod.</subtitle><author><name>Tadeusz Biela</name></author><entry><title type="html">Fundamenty myślenia wielowątkowego</title><link href="https://cpptested.com/multithreading/multithreading-fundamentals/" rel="alternate" type="text/html" title="Fundamenty myślenia wielowątkowego" /><published>2026-02-24T00:00:00+01:00</published><updated>2026-02-24T00:00:00+01:00</updated><id>https://cpptested.com/multithreading/multithreading-fundamentals</id><content type="html" xml:base="https://cpptested.com/multithreading/multithreading-fundamentals/"><![CDATA[<p>Podstawy są ważne, bez nich nie możemy ruszyć dalej z nauką, szczególnie, gdy chcemy opanować rzeczy o dużo większej złożoności, jak na przykład wielowątkowość i przetwarzanie współbieżne. Zacznijmy więc od fundamentów, pojęć bez, których opanowanie sztuki tworzenia wielowątkowego kodu się nie powiedzie. Żeby pisać kod uruchamiany w więcej niż jednym wątku, wpierw trzeba nauczyć się samego myślenia w sposób wielowątkowy i właśnie od tego zaczniemy.</p>

<h3 id="współbieżność-iwielowątkowość">Współbieżność i wielowątkowość</h3>

<p>Rozpoczniemy od rozróżnienia, czym jest współbieżność, a czym wielowątkowość. Zrozumienie obu zagadnień umożliwi Ci zbudowanie solidnych podstaw myślenia, jak wygląda przetwarzanie zadań przez komputer.</p>

<p>Współbieżność to wykonywanie zadań w tym samym czasie przez jedną jednostkę CPU. To znaczy, że nasz procesor otrzymuje kilka zadań i sekwencyjnie wykonuje po trochu każde z nich, przełączając konteksty między nimi. Zadania sumarycznie są wykonywane w tym samym czasie, ale tak naprawdę, to CPU jest w stanie pracować tylko nad jednym zadaniem na raz. Dlatego, by  każde zadanie posuwało się do przodu, CPU przełącza się miedzy nimi, aż do ich zakończenia. Proces ten nazywamy przełączaniem kontekstów. To daje nam wrażenie, że wszystko co się dzieje na ekranie komputera, wykonuje się niejako jednocześnie. To sprytna sztuczka, oszukiwanie ludzkiego oka i percepcji.</p>

<p>Wielowątkowość to również przetwarzanie wielu zadań na raz, ale już bez przełączania kontekstu, ponieważ każdy wątek dostaje swoje zasoby może wykonywać przydzielone zadanie równocześnie z innymi wątkami. W tym przypadku możemy mówić o przynajmniej dwóch CPU (to uproszczenie), które nie przełączają się między zadaniami, tylko dostają po jednym i wykonują je bez przerwy, aż do zakończenia.</p>

<p>By jeszcze lepiej to zrozumieć, posłużmy się prostą analogią. Współbieżność jest jak gotowanie w kuchni, przez chwilę mieszasz gotujący się makaron, potem wrzucasz kotlet na patelnię, by  za chwilę kroić warzywa na sałatkę. Nie kroisz jedną ręką warzyw, a drugą nie mieszasz makaronu, obracając stopą kotleta :) (no może niektórzy tak potrafią). Przeskakujesz między czynnościami, aby  wszystkie zakończyć w podobnym czasie i móc podać gotowy obiad. Wielowątkowość to po prostu większa liczba kucharzy w kuchni, którzy nie wchodzą sobie w drogę. Obiad powstaje szybciej, ale wymaga więcej ludzi.</p>

<p>Oba podejścia można oczywiście łączyć, otrzymując wielozadaniowe wątki i jednostki przetwarzania. Obecnie architektury sprzętowe mogą być bardzo różne i rozbudowane, od procesora jednordzeniowego, poprzez wielordzeniowe CPU, a kończąc na wielu procesorach wielordzeniowych.</p>

<p>Z przetwarzaniem współbieżnym i wielowątkowym wiążą się również spore wyzwania i ograniczenia. Nie jest to remedium na wszystko, ale potrafią (gdy są odpowiednio użyte) mocno przyśpieszyć działanie naszego programu.</p>

<h3 id="operacje-wlinijce-kodu">Operacje w linijce kodu</h3>

<p>Kiedy znamy już różnicę między współbieżnością, a wielowątkowością, przejdźmy do najbardziej podstawowego pojmowanie kodu właśnie w tym kontekście.</p>

<p>Gdy widzisz taką linijkę kodu, to co myślisz?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">+=</span> <span class="mi">42</span><span class="p">;</span>
</code></pre></div></div>

<p>Niby jedna operacja, nic bardziej mylnego! Tak naprawdę dzieją się tam trzy rzeczy:</p>

<ol>
  <li>Odczytanie zmiennej <strong>x</strong>.</li>
  <li>Modyfikacja tej zmiennej</li>
  <li>Zapis zmiennej <strong>x</strong> w pamięci.</li>
</ol>

<p>Każda ta operacja przedstawia inny stan zmiennej <strong>x</strong>. Pomiędzy lub nawet w trakcie tych operacji, inny wątek może też chcieć skorzystać z naszej zmiennej. Pytanie w jakim stanie powinna się ona znajdować? By odpowiedzieć na to pytanie musimy najpierw zrozumieć czym są <strong>niezmienniki</strong>.</p>

<h3 id="niezmienniki">Niezmienniki</h3>

<p><strong>Niezmiennik</strong> to stan zmiennej/obiektu/modułu/systemu, który musi być prawdą w każdym momencie jego obserwacji.</p>

<p>Kluczowymi słowami w tej definicji są <strong>stan</strong>, <strong>prawda</strong> i <strong>obserwacja</strong>. Rozłóżmy to na czynniki pierwsze. Jeśli chcesz nauczyć się dobrze programować wielowątkowo to wpierw naucz się myśleć, nie w kategoriach zmiennych czy obiektów, ale ich stanu w jakim się obecnie znajdują, w jakim będą się znajdować za chwilę itd.</p>

<p>Mamy metodę klasy <strong>Account</strong>, która ma taką implementację metody <strong>transfer</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">transfer</span><span class="p">(</span><span class="n">Account</span><span class="o">&amp;</span> <span class="n">account</span><span class="p">,</span> <span class="n">Money</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span>
<span class="p">{</span>
    <span class="n">account</span><span class="p">.</span><span class="n">withdraw</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">balance</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Niezmiennikami mogą być, w takim przypadku, poniższe założenia:</p>

<ol>
  <li>Saldo każdego konta jest zawsze ≥ 0.</li>
  <li>Suma środków <strong>account.balance</strong> i <strong>this-&gt;balance</strong> jest taka sama w każdym obserwowanym momencie.</li>
  <li>Metoda transfer jest niepodzielną zmianą systemu.</li>
  <li>Jeśli zmniejszone zostało <strong>account.balance</strong> to zwiększone zostało <strong>this-&gt;balance</strong>.</li>
</ol>

<p>Powyższe 4 punkty to są założenia, które metoda <strong>transfer</strong> powinna spełniać. Czy tak jest? No niestety nie. W wyniku wykonywania tej metody, nie ma żadnych ograniczeń w tym, by  inny wątek odwołał się do tych obiektów.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="nf">transfer</span><span class="p">(</span><span class="n">Account</span><span class="o">&amp;</span> <span class="n">account</span><span class="p">,</span> <span class="n">Money</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span>
<span class="p">{</span>
    <span class="n">account</span><span class="p">.</span><span class="n">withdraw</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="c1">// W&amp;nbsp;tym momencie obserwacji, część niezmienników nie jest prawdziwa</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">balance</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Aby temu zaradzić należałoby dodać <strong>mutex</strong>. Czym są mutexy? O tym trochę później. Skupmy się na fundamentach. By dobrze określić niezmienniki należy zadać sobie odpowiednie pytania. Weźmy przykład prostej klasy <strong>Counter</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Counter</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">auto</span> <span class="n">increment</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span>
    <span class="p">{</span>
        <span class="n">value</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">getValue</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">int</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<ol>
  <li>Co jest stanem naszego obiektu klasy <strong>Counter</strong>?</li>
</ol>

<p>Stanem jest zmienna <strong>value</strong>, a raczej to jaką wartość posiada w każdym momencie obserwacji.</p>

<ol>
  <li>Kto może obserwować stan obiektu klasy <strong>Colunter</strong>?</li>
</ol>

<p>Każdy inny wątek w dowolnym momencie. Nie tylko przed i po wywołaniu metod.</p>

<ol>
  <li>Jaki stan jest niedozwolony? Sprawia, że obiekt klasy <strong>Counter</strong> jest niespójny?</li>
</ol>

<p><strong>value</strong> jest ujemne.</p>

<p>Naszym niezmiennikiem będzie więc: “Stan zmiennej <strong>value</strong> jest nieujemny w każdym momencie obserwacji.”</p>

<p>Zastanówmy się, czy jest w ogóle możliwość, aby  ten niezmiennik był złamany? Dla przykładu metoda <strong>increment</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">increment</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span>
<span class="p">{</span>
    <span class="n">value</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Czy istnieje moment, w którym <strong>value</strong> może być ujemny? Weź pod uwagę dowolny przeplot wątków. Zakładamy brak synchronizacji i wiele wątków korzystających z tego samego obiektu klasy <strong>Counter</strong>. Wartość <strong>value</strong> jest inicjalizowana jako 0.</p>

<p>Odpowiedź brzmi: tak.</p>

<p>Intuicyjnie jest to przecież niemożliwe, prawda? Przecież zaczynamy od 0 i tylko inkrementujemy. Tak, to prawda, jednak przy przetwarzaniu wielowątkowym, w przypadku naszej klasy <strong>Counter</strong>, mamy do czynienia z <strong>data race</strong>. Wątki konkurują ze sobą o dostęp do <strong>value</strong>. Gdy jeden z wątków właśnie pracuje nad zwiększeniem <strong>value</strong>, inny, w dowolnym momencie może zaobserwować <strong>value</strong> i odczytać jej stan jako dowolny ciąg bitów. <strong>value</strong> może być jeszcze w rejestrze CPU, może zawierać starą wartość, może zawierać tylko fragment nowej wartości (w reprezentacji bitowej). Standard C++ określa <strong>data race</strong> jako Undefined Behavior. Po dokładne szczegóły <a href="https://cppreference.net/cpp/language/multithread.html" target="_blank" rel="noopener">odsyłam do oficjalnej dokumentacji</a>.</p>

<p>Wyznaczanie niezmienników nie jest rzeczą trywialną i wymaga ćwiczeń, niemniej znając ich definicje i założenia będzie to znacznie prostsze.</p>

<h3 id="sekcja-krytyczna">Sekcja krytyczna</h3>

<p>Wiedząc już czym są niezmienniki, czas przejść do ich spełniania w naszym kodzie. Wspominałem wcześniej o <strong>mutexie</strong>. To narzędzie do synchronizacji pomiędzy wątkami. Jest ich jeszcze kilka, ale ważniejsze jest teraz to, co ze sobą niosą. Sekcja krytyczna to taki fragment kodu/systemu, który nie może być obserwowalny przez inne wątki, aby  zachować niezmienniki.</p>

<p>Wiedząc już jaki stan jest niedopuszczalny w naszym kodzie, musimy nauczyć się wydzielać te miejsca, które do takiego stanu doprowadzają i zablokować możliwość ich obserwacji przez inne wątki. Do tego, między innymi, służy <strong>mutex</strong>. Gdy jest zablokowany, nie dopuszcza innych wątków do momentu jego zwolnienia, a ich dostęp jest kolejkowany.</p>

<p>Wróćmy do przykładu z funkcją <strong>transfer</strong> i dodajmy do niej <strong>mutex</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">transfer</span><span class="p">(</span><span class="n">Account</span><span class="o">&amp;</span> <span class="n">account</span><span class="p">,</span> <span class="n">Money</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">transferLock</span> <span class="p">{</span> <span class="n">transferMutex</span> <span class="p">};</span>
    <span class="n">account</span><span class="o">-&gt;</span><span class="n">withdraw</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">balance</span> <span class="o">+=</span> <span class="n">value</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>std::lock_guard</strong> to narzędzie typu <a href="https://pl.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization" target="_blank" rel="noopener">RAII</a>, samo blokuje <strong>mutex</strong> w chwili tworzenia i odblokowuje w momencie destrukcji. Teraz funkcja <strong>transfer</strong> zachowuje niezmiennik:</p>

<ol>
  <li>Jeśli zmniejszone zostało <strong>account.balance</strong> to zwiększone zostało <strong>this-&gt;balance</strong>.</li>
</ol>

<p>Obserwowalny moment jest tylko przed zablokowaniem <strong>mutexa</strong> i po jego odblokowaniu, czyli całe ciało funkcji <strong>transfer</strong> nie jest dostępne dla innych wątków. Nie zawsze sekcja krytyczna to występujące po sobie linijki kodu. Najważniejsze są <strong>niezmienniki</strong>. Należy zawsze, przy analizie kodu wielowątkowego, zadawać sobie pytanie o poprawny stan naszej zmiennej czy obiektu.</p>

<p>Dla klasy <strong>Counter</strong> sekcją krytyczną będą wszystkie operacje na zmiennej <strong>value</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Counter</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">auto</span> <span class="n">increment</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">valueLock</span><span class="p">{</span><span class="n">valueMutex</span><span class="p">};</span>
        <span class="n">value</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">getValue</span><span class="p">()</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="kt">int</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">valueLock</span><span class="p">{</span><span class="n">valueMutex</span><span class="p">};</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">value</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
    <span class="k">mutable</span> <span class="n">std</span><span class="o">::</span><span class="n">mutex</span> <span class="n">valueMutex</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>To że blokujemy <strong>mutex</strong> osobno w metodzie <strong>increment</strong> i osobno w <strong>getValue</strong> to dalej jest to jedna i ta sama sekcja krytyczna, bo tyczy się stanu tej samej zmiennej czyli tych samych niezmienników.</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>Znasz już najważniejsze koncepty myślenia wielowątkowego. Dzięki nim poznawanie świata programowania wielowątkowego będzie znacznie łatwiejsze. W następnym wpisie z tego cyklu poruszę najważniejsze zagrożenia płynące z wielowątkowości. Jeżeli chcesz poznać więcej szczegółów przetwarzania wielowątkowego, polecam zapoznać się z tytułem <a href="https://lubimyczytac.pl/ksiazka/4946367/jezyk-c-i-przetwarzanie-wspolbiezne-w-akcji-wydanie-ii" target="_blank" rel="noopener">“Język C++ i przetwarzanie współbieżne w akcji.”</a> - Anthony Williams. Jest to świetna pozycja, by  dobrze zrozumieć wielowątkowość i zastosować ją w swoich projektach. Książka tak zawiera również bardzo zaawansowaną wiedzę na temat szeregowania dostępu do pamięci oraz tworzenia struktur bez blokad (mutexów), co może być po prostu zbyt trudne do przyswojenia, jeżeli dopiero zaczynasz naukę tej dziedziny. Warto wtedy ostanie kilka rozdziałów zostawić sobie na później :)</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="multithreading" /><category term="multithreading" /><category term="developer practices" /><category term="software" /><summary type="html"><![CDATA[Podstawy są ważne, bez nich nie możemy ruszyć dalej z nauką, szczególnie, gdy chcemy opanować rzeczy o dużo większej złożoności, jak na przykład wielowątkowość i przetwarzanie współbieżne. Zacznijmy więc od fundamentów, pojęć bez, których opanowanie sztuki tworzenia wielowątkowego kodu się nie powiedzie. Żeby pisać kod uruchamiany w więcej niż jednym wątku, wpierw trzeba nauczyć się samego myślenia w sposób wielowątkowy i właśnie od tego zaczniemy.]]></summary></entry><entry><title type="html">6 najczęstszych błędów z Google Test.</title><link href="https://cpptested.com/clean%20code/gtest-mistakes/" rel="alternate" type="text/html" title="6 najczęstszych błędów z Google Test." /><published>2026-01-26T00:00:00+01:00</published><updated>2026-01-26T00:00:00+01:00</updated><id>https://cpptested.com/clean%20code/gtest-mistakes</id><content type="html" xml:base="https://cpptested.com/clean%20code/gtest-mistakes/"><![CDATA[<p>Google Test to chyba najbardziej znany i używany framework testowy w projektach C++. Zawiera w sobie masę przydatnych narzędzi do tworzenia różnych rodzajów testów. Ja osobiście stosuję go w swoich projektach pisząc unit testy, ale nic nie stoi na przeszkodzie by tworzyć testy modułowe czy komponentowe (typu black box). Ceniony za swą uniwersalność oraz rozbudowany system asercji jest narzędziem bardzo potężnym. Mimo to nie jest również bez wad. Im bardziej złożone jest narzędzie tym trudniej się go nauczyć i korzystać z niego poprawnie.</p>

<p>Popełniamy błędy. To normalne, ważne jest co z tym zrobimy. Warto wyciągnąć z nich lekcje na przyszłość. Poniższa lista to nic innego jak moje własne obserwacje, jak programiści C++(w tym ja) wykorzystują <strong>GTest</strong> i gdzie najczęściej popełniają błędy.</p>

<h3 id="kolejność-parametrów-asercji">Kolejność parametrów asercji</h3>

<p>Czy kolejność w asercji typu EXPECT_EQ jest ważna? Owszem! Choć nie wynika ona z samej definicji makra w nagłówku <strong>gtest.h</strong>. Wspomniana definicja wygląda następująco.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define EXPECT_EQ(val1, val2) \
  EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
</span></code></pre></div></div>

<p>Sam Google Test nie informuje gdzie ma być umieszczona wartość oczekiwania, a gdzie wynikowa. Skąd więc założenie, że wartość <strong>expected</strong> powinna być pierwsza? Głównie z przykładów z repozytorium Google Test.</p>

<p>Przykład z folderu <strong>samples</strong> repozytorium Google Test, a dokładnie ten <a href="https://github.com/google/googletest/blob/main/googletest/samples/sample4_unittest.cc" target="_blank" rel="noopener">“sample4_unittest”</a>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST</span><span class="p">(</span><span class="n">Counter</span><span class="p">,</span> <span class="n">Increment</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Counter</span> <span class="n">c</span><span class="p">;</span>

  <span class="c1">// Test that counter 0 returns 0</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">Decrement</span><span class="p">());</span>

  <span class="c1">// EXPECT_EQ() evaluates its arguments exactly once, so they</span>
  <span class="c1">// can have side effects.</span>

  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">Increment</span><span class="p">());</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">Increment</span><span class="p">());</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">Increment</span><span class="p">());</span>

  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">Decrement</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Oczywiście jest ich znacznie więcej.</p>

<p>Są dwa powody dlaczego warto najpierw podawać wartość oczekiwaną, a potem wynikową.</p>

<ol>
  <li>Czytelność - przeglądając test, czytamy linijkę od lewej do prawej. Gdy wartością oczekiwaną jest po prostu stałą liczbową lub tekstową, szybciej dowiemy się co jest oczekiwane względem testowanej metody.</li>
  <li>Spójność z warunkami w kodzie - znasz ten ból, gdy w <strong>if</strong> zamiast użyć operatora porównania <strong>==</strong>, użyłeś operator przypisania <strong>=</strong>? Ja tak, dlatego warto najpierw wartość oczekiwaną podawać jako pierwszą. Jeśli jest to stała, kompilator szybko poinformuje nas o pomyłce.</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// Kompilator nie zgłosi błędu</span>

<span class="k">if</span><span class="p">(</span><span class="mi">5</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span> <span class="c1">// a tutaj już tak</span>

</code></pre></div></div>

<p>Logika jest zachowana ale zwiększa się odporność na błędy.</p>

<p>To która wersja będzie poprawna?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">resultValue</span><span class="p">,</span> <span class="n">expectedValue</span><span class="p">);</span> <span class="c1">// Ta?</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedValue</span><span class="p">,</span> <span class="n">resultValue</span><span class="p">);</span> <span class="c1">// czy ta?</span>
</code></pre></div></div>

<p>Tak naprawdę - to zależy. Choć sama kolejność jest sugerowana przykładami, nie jest ona napisana wprost. Którą więc wybrać? Jeśli wchodzisz do projektu, gdzie pierwsza wartość to ta wynikowa. Dostosuj się do konwencji już panującej w projekcie. Jeśli to nowy projekt, lub brak jest spójnej konwencji, wybierz wersję, gdzie wartość oczekiwana podawana jest jako pierwsza.</p>

<h3 id="używanie-expect-zamiast-assert">Używanie EXPECT zamiast ASSERT</h3>

<p>Ten błąd może kosztować życie (naszego wątku uruchamiającego testy). Dlaczego? Najpierw omówmy różnicę w zachowaniu <strong>EXPECT_EQ</strong> i <strong>ASSERT_EQ</strong> (lub dowolnej innej pary tych typów asercji). Obie asercje mają za zadanie sprawdzać czy dana wartość zgadza się z oczekiwaną. Różnica polega na tym co wydarzy się w przypadku niepowodzenia asercji. <strong>EXPECT</strong> spowoduje, że test nie zostanie zaliczony, wypisze komunikat i przejdzie do następnej linii testu.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">WidgetFactoryTests</span><span class="p">,</span> <span class="n">create_ButtonWidgetType_ReturnButtonWidget</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Rect</span> <span class="n">expectedRect</span> <span class="p">{</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">30</span> <span class="p">};</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expectedText</span> <span class="p">{</span> <span class="s">"Test Button"</span> <span class="p">};</span>
    <span class="n">WidgetFactory</span> <span class="n">factory</span> <span class="p">{};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">resultWidget</span> <span class="p">{</span> <span class="n">factory</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">WidgetType</span><span class="o">::</span><span class="n">BUTTON</span><span class="p">,</span> <span class="n">expectedRect</span><span class="p">,</span> <span class="n">expectedText</span><span class="p">)};</span>

    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">WidgetType</span><span class="o">::</span><span class="n">LABEL</span><span class="p">,</span> <span class="n">resultWidget</span><span class="p">.</span><span class="n">getType</span><span class="p">());</span> <span class="c1">// Ta asercja się nie powiedzie</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedRect</span><span class="p">,</span> <span class="n">resultWidget</span><span class="p">.</span><span class="n">getRect</span><span class="p">());</span> <span class="c1">// Ta i następna zostaną wywołane</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedText</span><span class="p">,</span> <span class="n">resultWidget</span><span class="p">.</span><span class="n">getText</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>ASSERT</strong> również spowoduje fail testu, wypisze komunikat, ale już nie przejdzie dalej do kolejnej części testu. Test zostaje przerwany w tym miejscu i dalej nie będzie kontynuowany.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">WidgetsFactorySfmlTests</span><span class="p">,</span> <span class="n">create_LabelType_CreateLabelWidget</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">sfmlWindow</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">MockSfmlWindow</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">sfmlWindow</span><span class="p">,</span> <span class="n">getRenderTarget</span><span class="p">()).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnRef</span><span class="p">(</span><span class="n">getWindow</span><span class="p">()));</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">sfmlWindow</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">_</span><span class="p">));</span>
    <span class="n">WidgetsFactorySfml</span> <span class="n">factory</span> <span class="p">{</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">sfmlWindow</span><span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">resultWidget</span> <span class="p">{</span>
        <span class="n">factory</span><span class="p">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">WidgetType</span><span class="o">::</span><span class="n">LABEL</span><span class="p">,</span>
            <span class="n">WidgetGeometry</span> <span class="p">{},</span>
            <span class="n">WidgetText</span> <span class="p">{},</span>
            <span class="n">WidgetStyle</span> <span class="p">{}</span>
        <span class="p">)</span>
    <span class="p">};</span> <span class="c1">// Jeśli ta metoda zwróci nullptr</span>

    <span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">resultWidget</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span> <span class="c1">// to ta asercja się nie powiedzie i test przerywa wykonywanie.</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">WidgetType</span><span class="o">::</span><span class="n">LABEL</span><span class="p">,</span> <span class="n">resultWidget</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span> <span class="c1">// Ta i następna asercja nie zostaną wywołane</span>
    <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">LabelWidget</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">resultWidget</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Co nam to daje? Bardzo wiele, zwłaszcza gdy kolejne asercje opierają się na naszym <strong>ASSERT</strong>. Jeśli zastosujemy zwykły <strong>EXPECT</strong> to test zakończy swoje działanie poprzez brutalne przerwanie w stylu segfaulta.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">WidgetsFactorySfmlTests</span><span class="p">,</span> <span class="n">create_LabelType_CreateLabelWidget</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">sfmlWindow</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">MockSfmlWindow</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">sfmlWindow</span><span class="p">,</span> <span class="n">getRenderTarget</span><span class="p">()).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnRef</span><span class="p">(</span><span class="n">getWindow</span><span class="p">()));</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">sfmlWindow</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">_</span><span class="p">));</span>
    <span class="n">WidgetsFactorySfml</span> <span class="n">factory</span> <span class="p">{</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">sfmlWindow</span><span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">resultWidget</span> <span class="p">{</span>
        <span class="n">factory</span><span class="p">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">WidgetType</span><span class="o">::</span><span class="n">LABEL</span><span class="p">,</span>
            <span class="n">WidgetGeometry</span> <span class="p">{},</span>
            <span class="n">WidgetText</span> <span class="p">{},</span>
            <span class="n">WidgetStyle</span> <span class="p">{}</span>
        <span class="p">)</span>
    <span class="p">};</span> 

    <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">resultWidget</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span> <span class="c1">// zamiast ASSERT jest EXPECT</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">WidgetType</span><span class="o">::</span><span class="n">LABEL</span><span class="p">,</span> <span class="n">resultWidget</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span>
    <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">LabelWidget</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">resultWidget</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Test nie przejdzie, na dodatek, jeśli w naszej suicie będzie więcej testów i miały być one uruchomione po tym, to do tego nie dojdzie. Cały wątek z naszą suitą zostanie przerwany. Czyli inne testy nawet się nie wykonają.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span> RUN      <span class="o">]</span> WidgetsFactorySfmlTests.create_LabelType_CreateLabelWidget
Setting vertical <span class="nb">sync </span>not supported
/usr/src/heisttown/src/Sfml/SfmlWidgets/Tests/WidgetsFactorySfmlTests.cpp:42: Failure
Value of: resultWidget <span class="o">!=</span> nullptr
  Actual: <span class="nb">false
</span>Expected: <span class="nb">true</span>
</code></pre></div></div>

<p>W tym przypadku mamy chociaż informacje co poszło nie tak. Jeśli nie dodalibyśmy, w ogóle asercji na sprawdzanie czy <strong>resultWidget</strong> nie jest <strong>nullptr</strong>, nie wiedzielibyśmy nic. Dlatego ważne jest, aby stosować <strong>ASSERT</strong> czy <strong>EXPECT</strong> zgodnie z ich przeznaczeniem.</p>

<p>Dlaczego więc nie stosować <strong>ASSERT</strong> zawsze? Jak już pisałem, <strong>ASSERT</strong> zatrzymuje test, dalsza jego część nie jest weryfikowana. Jeśli następne asercje nie są zależne od poprzednich to, w takim przypadku zostaną pominięte i nie będziemy wiedzieli, czy tylko ta jedna asercja nie została spełniona, czy cały ich szereg. Obraz sytuacji będzie niekompletny.</p>

<p>Jeśli oczekiwanym wynikiem może być kontener to sprawdź jego rozmiar <strong>ASSERT</strong>em zanim zaczniesz weryfikować jego konkretne elementy. Albo, gdy wynikiem będzie wskaźnik, sprawdź czy nie jest on <strong>nullptr</strong> zanim zaczniesz odwoływać się do obiektu pod nim. To tylko najczęściej powtarzające się sytuacje, gdzie należy stosować <strong>ASSERT</strong>. Z pewnością jest ich więcej.</p>

<h3 id="porównywanie-floatów-bez-precyzji">Porównywanie float’ów bez precyzji</h3>

<p>Reprezentacja liczb zmiennoprzecinkowych przez komputer nie jest doskonała i wie to każdy doświadczony programista. Porównywanie wartości typu <strong>float</strong> czy <strong>double</strong> ze sobą nie jest takie proste jak liczb całkowitych. Weryfikacja testu odbywa się właśnie przez porównanie, a wyniki zapisane w liczbach zmiennoprzecinkowych mogą się nieznacznie różnić od tych oczekiwanych.</p>

<p>Dlaczego tak się dzieje?</p>

<p>Spora część liczb zmiennoprzecinkowych nie ma idealnej reprezentacji w systemie binarnym. Dlatego komputer musi zaokrąglać wyliczoną wartość do najbliższej zero-jedynkowej wartości. Jest nawet na to określony standard <a href="https://pl.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">“IEEE 754”</a>. Właśnie ze względu na te zaokrąglenia, porównywanie wartości zmiennoprzecinkowych, może dać fałszywe wyniki. Dlatego stosuje się porównywanie z tolerancją, tak zwany <strong>epsilon</strong>.</p>

<p>To mi przypomina moje początki nauki pisania unit testów i pracy z Google Test. Tak, mniej więcej, wyglądał jeden z moich pierwszych unit testów w zakresie weryfikacji wyniku zapisanego właśnie w <strong>double</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST</span><span class="p">(</span><span class="n">DemodulationTests</span><span class="p">,</span> <span class="n">llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">sample</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">};</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">noise</span> <span class="p">{</span> <span class="mf">0.394</span> <span class="p">};</span>
  
    <span class="k">const</span> <span class="k">auto</span> <span class="n">resultLlr</span> <span class="p">{</span> <span class="n">llr16QamIMsb</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">noise</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mf">5.0761421319796952</span><span class="p">,</span> <span class="n">resultLlr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Teraz, gdy o tym myślę, chce mi się śmiać, ale kto nie popełnia błędów? Ten kto nic nie robi ;) Dziś sobie z przed lat powiedziałbym co trzeba zrobić w takim przypadku, poprawilibyśmy ten test i wyglądałby następująco.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST</span><span class="p">(</span><span class="n">DemodulationTests</span><span class="p">,</span> <span class="n">llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">sample</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">};</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">noise</span> <span class="p">{</span> <span class="mf">0.394</span> <span class="p">};</span>
  
    <span class="k">const</span> <span class="k">auto</span> <span class="n">resultLlr</span> <span class="p">{</span> <span class="n">llr16QamIMsb</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">noise</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">EXPECT_NEAR</span><span class="p">(</span><span class="mf">5.07614</span><span class="p">,</span> <span class="n">resultLlr</span><span class="p">,</span> <span class="mf">0.00001</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Zmieniła się tylko sama asercja i z pewnością test stał się niewrażliwy na zmianę platformy, która ma inną precyzję operacji na liczbach zmiennoprzecinkowych. Dodatkowo dzięki właśnie <strong>EXPECT_NEAR</strong> możemy jasno określić tolerancję, czyli już wcześniej wspomniany <strong>epsilon</strong>.</p>

<h3 id="logika-wmocku">Logika w Mocku</h3>

<p>Wraz z Google Test dostajemy również Google Mock, jest on dodawany jako osobny nagłówek <strong>gmock.h</strong>. Mock to w tłumaczeniu na polski - makieta. Czyli, w kontekście programowania obiektowego, coś co tylko udaje implementację klasy. Nieraz jednak widziałem, mocki, które przysłaniały tylko część metod, pozostawiając lub nadpisując implementację klasy, z której dziedziczyły.</p>

<p>Możemy podejść do mockowania na przynajmniej dwa sposoby. Pierowysz to bazowanie na interfejsie. Wprowadzamy klasę czysto abstrakcyjną, do której nasza testowana klasa się odwołuje, nie znając prawdziwej wersji implementacji.</p>

<p>Poniżej przykład interfejsu <strong>RenderSceneBuilder</strong>. Klasa ta ma za zadanie budowanie sceny gry złożonej z obiektów klasy <strong>RenderItem</strong> (również interfejs) w oparciu o strukturę <strong>SceneUdate</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">RenderSceneBuilder</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">RenderSceneBuilder</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">build</span><span class="p">(</span><span class="k">const</span> <span class="n">SceneUpdate</span><span class="o">&amp;</span> <span class="n">sceneUpdate</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">popRenderItems</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">RenderItems</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>A tutaj przykład jego wykorzystania (uproszczony by nie zaciemniać obrazu).</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SfmlWindow</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">SfmlWindow</span><span class="p">(</span>
        <span class="c1">//...</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RenderSceneBuilder</span><span class="o">&gt;</span> <span class="n">inputSceneBuilder</span> <span class="o">=</span> <span class="nb">nullptr</span>
        <span class="c1">//...</span>
    <span class="p">);</span>

    <span class="c1">//...</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">update</span><span class="p">(</span><span class="k">const</span> <span class="n">SceneUpdate</span><span class="o">&amp;</span> <span class="n">sceneUpdate</span><span class="p">)</span> <span class="k">override</span> <span class="o">-&gt;</span> <span class="kt">void</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="c1">//...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RenderSceneBuilder</span><span class="o">&gt;</span> <span class="n">sceneBuilder</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Teraz utworzymy mocka z interfejsu, <strong>MockRenderSceneBuilder</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MockRenderSceneBuilder</span> <span class="o">:</span> <span class="k">public</span> <span class="n">RenderSceneBuilder</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">build</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">SceneUpdate</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">RenderItems</span><span class="p">,</span> <span class="n">popRenderItems</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</code></pre></div></div>

<p>W tym przypadku klasa mocka przysłania tylko interfejs i wszystko mamy czyste. Wstrzykujemy mocka do naszej testowanej klasy poprzez konstruktor i voilà!</p>

<p>Drugi sposób - do destruktora oraz wszystkich publicznych metod klasy, którą chcemy zamockować dodajemy <strong>virtual</strong>. Dla przykładu mamy klasę <strong>GameSession</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GameSession</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">GameSession</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SceneItemFactory</span><span class="o">&gt;</span> <span class="n">inputFactory</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">GameSession</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">addPlayer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">PlayerID</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">removePlayer</span><span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span> <span class="n">playerId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">queuePlayerStatus</span><span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span> <span class="n">playerId</span><span class="p">,</span> <span class="k">const</span> <span class="n">PlayerStatus</span><span class="o">&amp;</span> <span class="n">playerStatus</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">updateGameWorld</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">getUpdateForPlayer</span><span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span> <span class="n">playerId</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">GameplayUpdate</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>I mockujemy.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MockGameSession</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameSession</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MockGameSession</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">PlayerID</span><span class="p">,</span> <span class="n">addPlayer</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">removePlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">queuePlayerStatus</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">PlayerStatus</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">updateGameWorld</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">GameplayUpdate</span><span class="p">,</span> <span class="n">getUpdateForPlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span><span class="p">,</span> <span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

</code></pre></div></div>

<p>Jeśli pozostawimy część publicznych metod jako niewirtualne i nie przysłonimy ich w mocku to nie odcinamy w pełni zależności między naszą testowaną klasą, a klasą zmockowaną. Taki test de facto nie jest już unit testem lecz czymś w rodzaju karykatury module testu. Poniżej przykład</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MockGameSession</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameSession</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MockGameSession</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">PlayerID</span><span class="p">,</span> <span class="n">addPlayer</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">removePlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">queuePlayerStatus</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">PlayerStatus</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">updateGameWorld</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">GameplayUpdate</span> <span class="n">getUpdateForPlayer</span><span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="c1">// Generuje losowe wartości i wypełnia nimi GameplayUpdate</span>
    <span class="p">}</span> 
<span class="p">};</span>
</code></pre></div></div>

<p>W przypadku, gdy dopisujemy jakąś część logiki w kodzie mocka ograniczamy widoczność tych operacji w naszych testach. Mock sam z siebie nie powinien nic robić. Służy on do weryfikacji zachowania naszej testowanej klasy, tj. jego interakcji z mockowaną klasą. Jeśli potrzebujemy, by nasz mock reagował na te interakcje Google Mock udostępnia szereg narzędzi jak <strong>ON_CALL</strong> i <strong>EXPECT_CALL</strong> z odpowiednią kombinacją na przykład <strong>WillOnce</strong> i <strong>Invoke</strong> (są też inne metody na sterowanie zachowaniem mocka). Wtedy wszystko jest zapisane w naszym unit teście, w bloku <a href="https://cpptested.com/unit%20testing/AAA-golden-standard/" target="_blank" rel="noopener">“Arrange”</a>.</p>

<h3 id="testowanie-mocka">Testowanie Mocka</h3>

<p>Jak już wspomniałem mocki służą do weryfikacji interakcji z naszą testowaną klasą. Spotkałem się jednak z innym sposobem wykorzystywania mocków w unit testach. Kiedy nie znamy dobrych podstaw pisania unit testów (o których jeszcze napiszę ;) ), mogą powstać naprawdę dziwne rzeczy.</p>

<p>W unit testach widziałem wiele nietypowych konstrukcji, i w rzeczy samej testowanie mocka jest jedną z nich. Chcąc odciąć jakąś zależność możemy zastosować mocka, aby przysłonić część implementacji lub wręcz zastąpić ją inną. Co de facto mija się z celem testowania.</p>

<p>Dla przykładu, mamy mocka klasy <strong>MockGameSession</strong> z poprzedniego punktu. Tym razem jak najbardziej poprawnego.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MockGameSession</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameSession</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MockGameSession</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">PlayerID</span><span class="p">,</span> <span class="n">addPlayer</span><span class="p">,</span> <span class="p">());</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">removePlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">queuePlayerStatus</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">PlayerStatus</span><span class="o">&amp;</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">updateGameWorld</span><span class="p">,</span> <span class="p">());</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">GameplayUpdate</span><span class="p">,</span> <span class="n">getUpdateForPlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">Texture</span><span class="p">,</span> <span class="n">getTexture</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span><span class="p">));</span> <span class="c1">// metoda protected w GameSession</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Natomiast w unit testach chcemy przetestować metodę <strong>addPlayer</strong> klasy <strong>GameSession</strong>, jednak korzysta ona z metody <strong>getTexture</strong> odczytującej teksturę gracza z pliku. W takim przypadku moglibyśmy zastosować <a href="https://cpptested.com/unit%20testing/handling-globals/" target="_blank" rel="noopener">“Wrapper”</a> lub wprowadzić osobny obiekt klasy <strong>Factory</strong> i zacmokocwać ją stosująć Dependency Injection. Jednak nie znając jeszcze tych technik możemy pokusić się o użycie mocka w taki sposób, by podczas testowania metody <strong>addPlayer</strong> przysłonić tylko metodę <strong>getTexture</strong>, która to odpowiedzialna jest za odczyt pliku.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">GameSessionTests</span><span class="p">,</span> <span class="n">addPlayer_OneNewPlayer_ReturnNewPlayerId</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">factory</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockSceneItemFactory</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">factory</span><span class="p">,</span> <span class="n">create</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">));</span>
    <span class="n">MockGameSession</span> <span class="n">gameSession</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">factory</span><span class="p">)</span> <span class="p">};</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">gameSession</span><span class="p">,</span> <span class="n">getTexture</span><span class="p">(</span><span class="n">_</span><span class="p">)).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="n">Texture</span><span class="p">()));</span> <span class="c1">// Mockowanie zależności odczytu z pliku</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">gameSession</span><span class="p">,</span> <span class="n">addPlayer</span><span class="p">()).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span> <span class="c1">// Mockowana metoda wykonuje tą prawdziwą</span>
        <span class="k">return</span> <span class="n">gameSession</span><span class="p">.</span><span class="n">GameSession</span><span class="o">::</span><span class="n">addPlayer</span><span class="p">();</span>
    <span class="p">}));</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">resultPlayerId</span> <span class="p">{</span> <span class="n">gameSession</span><span class="p">.</span><span class="n">addPlayer</span><span class="p">()</span> <span class="p">};</span> <span class="c1">// Wywołanie mockowanej metody</span>

    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">resultPlayerId</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dlaczego uważam to za fatalny pomysł? W końcu działa…</p>

<p>No cóż to tak jakby używać spawarki do wbijania gwoździ, no niby da się tylko po co? Mocki zostały wymyślone po to by odcinać zależności między klasami, a nie do grzebania w implementacji naszej testowanej klasy. Gdy widzę test, w którym nie ma normalnej klasy, tylko same mocki to coś tu jest nie tak.</p>

<p>Taki test jest bardzo nieczytelny. Gdy dodamy do tego enigmatyczną nazwę to praktycznie na pierwszy czy nawet drugi rzut oka, nie jesteśmy w stanie stwierdzić, która klasa jest testowana. W GoogleTest są oczywiście nazwa test suity, która może w tym przypadku podpowiedzieć to i owo, niemniej, czytelność i tak spada diametralnie.</p>

<p>Używajmy narzędzi zgodnie z ich pierwotnym przeznaczeniem, zwłaszcza podczas testowania. Dbamy tym samym o wysoką czytelność i przejrzystość w naszych unit testach.</p>

<h3 id="brak-override-w-mockach">Brak override w mockach</h3>

<p>Słowo kluczowe (a dokładnie specyfikator) <strong>override</strong> możemy stosować również w mockowanych metodach i działa ono dokładnie tak samo jak w zwykłych klasach. W <strong>MOCK_METHOD</strong> na końcu, w sekcji gdzie dodajemy kwalifikatory i specyfikatory. Dla przykładu, wróćmy do <strong>MockGameSession</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MockGameSession</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameSession</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MockGameSession</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">PlayerID</span><span class="p">,</span> <span class="n">addPlayer</span><span class="p">,</span> <span class="p">());</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">removePlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">queuePlayerStatus</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">PlayerStatus</span><span class="o">&amp;</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">updateGameWorld</span><span class="p">,</span> <span class="p">());</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">GameplayUpdate</span><span class="p">,</span> <span class="n">getUpdateForPlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span><span class="p">));</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Jeśli w takim przypadku metoda <strong>removePlayer</strong> w klasie <strong>GameSession</strong> nie będzie wirtualna, kompilator i tak nie zwróci błędu. Kod skompiluje się, a my będziemy zachodzić w głowę czemu nasz mock nie jest wywoływany.</p>

<p>Użycie <strong>override</strong> eliminuje problem. W przypadku, gdy dodamy ten specyfikator, a metoda w klasie bazowej nie będzie wirtualna, kompilator zwróci błąd. Tak jak na poniższym przykładzie.</p>

<p>Tutaj już poprawiony mock.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MockGameSession</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameSession</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MockGameSession</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">PlayerID</span><span class="p">,</span> <span class="n">addPlayer</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">removePlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">queuePlayerStatus</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">PlayerStatus</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">updateGameWorld</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">GameplayUpdate</span><span class="p">,</span> <span class="n">getUpdateForPlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span><span class="p">,</span> <span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Oraz błąd zwracany przez kompilator.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/.../MockGameSession.hpp:16:23: error: <span class="s1">'testing::internal::Function&lt;void(const int&amp;)&gt;::Result MockGameSession::removePlayer(testing::internal::ElemFromList&lt;0, const int&amp;&gt;::type)'</span> marked <span class="s1">'override'</span>, but does not override
   16 |     MOCK_METHOD<span class="o">(</span>void, removePlayer, <span class="o">(</span>const PlayerID&amp;<span class="o">)</span>, <span class="o">(</span>override<span class="o">))</span><span class="p">;</span>
      | 
</code></pre></div></div>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>To już wszystko w tym wpisie. Mam nadzieję, że będzie dla Ciebie choć trochę pomocny w zmaganiach z Google Test’em. Czy któryś z wymienionych w tym wpisie błędów Cię zaskoczył? Może inny jest dość znajomy? Daj znać w komentarzu! Popełnianie błędów jest czymś normalnym. Ważne by się rozwijać i uczyć od siebie nawzajem. Jeśli znasz inne przypadki, chętnie się z nimi zapoznam. Możesz również napisać do mnie email lub wysłać wiadomość na LinkedIn. Będzie mi bardzo miło :)</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="clean code" /><category term="clean code" /><category term="code quality" /><category term="developer practices" /><category term="software" /><summary type="html"><![CDATA[Google Test to chyba najbardziej znany i używany framework testowy w projektach C++. Zawiera w sobie masę przydatnych narzędzi do tworzenia różnych rodzajów testów. Ja osobiście stosuję go w swoich projektach pisząc unit testy, ale nic nie stoi na przeszkodzie by tworzyć testy modułowe czy komponentowe (typu black box). Ceniony za swą uniwersalność oraz rozbudowany system asercji jest narzędziem bardzo potężnym. Mimo to nie jest również bez wad. Im bardziej złożone jest narzędzie tym trudniej się go nauczyć i korzystać z niego poprawnie. Popełniamy błędy. To normalne, ważne jest co z tym zrobimy. Warto wyciągnąć z nich lekcje na przyszłość. Poniższa lista to nic innego jak moje własne obserwacje, jak programiści C++(w tym ja) wykorzystują GTest i gdzie najczęściej popełniają błędy. Kolejność parametrów asercji Czy kolejność w asercji typu EXPECT_EQ jest ważna? Owszem! Choć nie wynika ona z samej definicji makra w nagłówku gtest.h. Wspomniana definicja wygląda następująco. #define EXPECT_EQ(val1, val2) \ EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2) Sam Google Test nie informuje gdzie ma być umieszczona wartość oczekiwania, a gdzie wynikowa. Skąd więc założenie, że wartość expected powinna być pierwsza? Głównie z przykładów z repozytorium Google Test. Przykład z folderu samples repozytorium Google Test, a dokładnie ten “sample4_unittest”. TEST(Counter, Increment) { Counter c; // Test that counter 0 returns 0 EXPECT_EQ(0, c.Decrement()); // EXPECT_EQ() evaluates its arguments exactly once, so they // can have side effects. EXPECT_EQ(0, c.Increment()); EXPECT_EQ(1, c.Increment()); EXPECT_EQ(2, c.Increment()); EXPECT_EQ(3, c.Decrement()); } Oczywiście jest ich znacznie więcej. Są dwa powody dlaczego warto najpierw podawać wartość oczekiwaną, a potem wynikową. Czytelność - przeglądając test, czytamy linijkę od lewej do prawej. Gdy wartością oczekiwaną jest po prostu stałą liczbową lub tekstową, szybciej dowiemy się co jest oczekiwane względem testowanej metody. Spójność z warunkami w kodzie - znasz ten ból, gdy w if zamiast użyć operatora porównania ==, użyłeś operator przypisania =? Ja tak, dlatego warto najpierw wartość oczekiwaną podawać jako pierwszą. Jeśli jest to stała, kompilator szybko poinformuje nas o pomyłce. if(i = 5) // Kompilator nie zgłosi błędu if(5 = i) // a tutaj już tak Logika jest zachowana ale zwiększa się odporność na błędy. To która wersja będzie poprawna? EXPECT_EQ(resultValue, expectedValue); // Ta? EXPECT_EQ(expectedValue, resultValue); // czy ta? Tak naprawdę - to zależy. Choć sama kolejność jest sugerowana przykładami, nie jest ona napisana wprost. Którą więc wybrać? Jeśli wchodzisz do projektu, gdzie pierwsza wartość to ta wynikowa. Dostosuj się do konwencji już panującej w projekcie. Jeśli to nowy projekt, lub brak jest spójnej konwencji, wybierz wersję, gdzie wartość oczekiwana podawana jest jako pierwsza. Używanie EXPECT zamiast ASSERT Ten błąd może kosztować życie (naszego wątku uruchamiającego testy). Dlaczego? Najpierw omówmy różnicę w zachowaniu EXPECT_EQ i ASSERT_EQ (lub dowolnej innej pary tych typów asercji). Obie asercje mają za zadanie sprawdzać czy dana wartość zgadza się z oczekiwaną. Różnica polega na tym co wydarzy się w przypadku niepowodzenia asercji. EXPECT spowoduje, że test nie zostanie zaliczony, wypisze komunikat i przejdzie do następnej linii testu. TEST_F(WidgetFactoryTests, create_ButtonWidgetType_ReturnButtonWidget) { const Rect expectedRect { 300, 400, 120, 30 }; const std::string expectedText { "Test Button" }; WidgetFactory factory {}; const auto resultWidget { factory.create(WidgetType::BUTTON, expectedRect, expectedText)}; EXPECT_EQ(WidgetType::LABEL, resultWidget.getType()); // Ta asercja się nie powiedzie EXPECT_EQ(expectedRect, resultWidget.getRect()); // Ta i następna zostaną wywołane EXPECT_EQ(expectedText, resultWidget.getText()); } ASSERT również spowoduje fail testu, wypisze komunikat, ale już nie przejdzie dalej do kolejnej części testu. Test zostaje przerwany w tym miejscu i dalej nie będzie kontynuowany. TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget) { const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() }; EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow())); EXPECT_CALL(*sfmlWindow, add(_)); WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr }; const auto resultWidget { factory.create( WidgetType::LABEL, WidgetGeometry {}, WidgetText {}, WidgetStyle {} ) }; // Jeśli ta metoda zwróci nullptr ASSERT_TRUE(resultWidget != nullptr); // to ta asercja się nie powiedzie i test przerywa wykonywanie. EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType()); // Ta i następna asercja nie zostaną wywołane EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr); } Co nam to daje? Bardzo wiele, zwłaszcza gdy kolejne asercje opierają się na naszym ASSERT. Jeśli zastosujemy zwykły EXPECT to test zakończy swoje działanie poprzez brutalne przerwanie w stylu segfaulta. TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget) { const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() }; EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow())); EXPECT_CALL(*sfmlWindow, add(_)); WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr }; const auto resultWidget { factory.create( WidgetType::LABEL, WidgetGeometry {}, WidgetText {}, WidgetStyle {} ) }; EXPECT_TRUE(resultWidget != nullptr); // zamiast ASSERT jest EXPECT EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType()); EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr); } Test nie przejdzie, na dodatek, jeśli w naszej suicie będzie więcej testów i miały być one uruchomione po tym, to do tego nie dojdzie. Cały wątek z naszą suitą zostanie przerwany. Czyli inne testy nawet się nie wykonają. [ RUN ] WidgetsFactorySfmlTests.create_LabelType_CreateLabelWidget Setting vertical sync not supported /usr/src/heisttown/src/Sfml/SfmlWidgets/Tests/WidgetsFactorySfmlTests.cpp:42: Failure Value of: resultWidget != nullptr Actual: false Expected: true W tym przypadku mamy chociaż informacje co poszło nie tak. Jeśli nie dodalibyśmy, w ogóle asercji na sprawdzanie czy resultWidget nie jest nullptr, nie wiedzielibyśmy nic. Dlatego ważne jest, aby stosować ASSERT czy EXPECT zgodnie z ich przeznaczeniem. Dlaczego więc nie stosować ASSERT zawsze? Jak już pisałem, ASSERT zatrzymuje test, dalsza jego część nie jest weryfikowana. Jeśli następne asercje nie są zależne od poprzednich to, w takim przypadku zostaną pominięte i nie będziemy wiedzieli, czy tylko ta jedna asercja nie została spełniona, czy cały ich szereg. Obraz sytuacji będzie niekompletny. Jeśli oczekiwanym wynikiem może być kontener to sprawdź jego rozmiar ASSERTem zanim zaczniesz weryfikować jego konkretne elementy. Albo, gdy wynikiem będzie wskaźnik, sprawdź czy nie jest on nullptr zanim zaczniesz odwoływać się do obiektu pod nim. To tylko najczęściej powtarzające się sytuacje, gdzie należy stosować ASSERT. Z pewnością jest ich więcej. Porównywanie float’ów bez precyzji Reprezentacja liczb zmiennoprzecinkowych przez komputer nie jest doskonała i wie to każdy doświadczony programista. Porównywanie wartości typu float czy double ze sobą nie jest takie proste jak liczb całkowitych. Weryfikacja testu odbywa się właśnie przez porównanie, a wyniki zapisane w liczbach zmiennoprzecinkowych mogą się nieznacznie różnić od tych oczekiwanych. Dlaczego tak się dzieje? Spora część liczb zmiennoprzecinkowych nie ma idealnej reprezentacji w systemie binarnym. Dlatego komputer musi zaokrąglać wyliczoną wartość do najbliższej zero-jedynkowej wartości. Jest nawet na to określony standard “IEEE 754”. Właśnie ze względu na te zaokrąglenia, porównywanie wartości zmiennoprzecinkowych, może dać fałszywe wyniki. Dlatego stosuje się porównywanie z tolerancją, tak zwany epsilon. To mi przypomina moje początki nauki pisania unit testów i pracy z Google Test. Tak, mniej więcej, wyglądał jeden z moich pierwszych unit testów w zakresie weryfikacji wyniku zapisanego właśnie w double. TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr) { const std::complex&lt;double&gt; sample { 1.0, 0.0 }; const double noise { 0.394 }; const auto resultLlr { llr16QamIMsb(sample, noise) }; EXPECT_EQ(5.0761421319796952, resultLlr); } Teraz, gdy o tym myślę, chce mi się śmiać, ale kto nie popełnia błędów? Ten kto nic nie robi ;) Dziś sobie z przed lat powiedziałbym co trzeba zrobić w takim przypadku, poprawilibyśmy ten test i wyglądałby następująco. TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr) { const std::complex&lt;double&gt; sample { 1.0, 0.0 }; const double noise { 0.394 }; const auto resultLlr { llr16QamIMsb(sample, noise) }; EXPECT_NEAR(5.07614, resultLlr, 0.00001); } Zmieniła się tylko sama asercja i z pewnością test stał się niewrażliwy na zmianę platformy, która ma inną precyzję operacji na liczbach zmiennoprzecinkowych. Dodatkowo dzięki właśnie EXPECT_NEAR możemy jasno określić tolerancję, czyli już wcześniej wspomniany epsilon. Logika w Mocku Wraz z Google Test dostajemy również Google Mock, jest on dodawany jako osobny nagłówek gmock.h. Mock to w tłumaczeniu na polski - makieta. Czyli, w kontekście programowania obiektowego, coś co tylko udaje implementację klasy. Nieraz jednak widziałem, mocki, które przysłaniały tylko część metod, pozostawiając lub nadpisując implementację klasy, z której dziedziczyły. Możemy podejść do mockowania na przynajmniej dwa sposoby. Pierowysz to bazowanie na interfejsie. Wprowadzamy klasę czysto abstrakcyjną, do której nasza testowana klasa się odwołuje, nie znając prawdziwej wersji implementacji. Poniżej przykład interfejsu RenderSceneBuilder. Klasa ta ma za zadanie budowanie sceny gry złożonej z obiektów klasy RenderItem (również interfejs) w oparciu o strukturę SceneUdate. class RenderSceneBuilder { public: virtual ~RenderSceneBuilder() = default; virtual auto build(const SceneUpdate&amp; sceneUpdate) -&gt; void = 0; virtual auto popRenderItems() -&gt; RenderItems = 0; }; A tutaj przykład jego wykorzystania (uproszczony by nie zaciemniać obrazu). class SfmlWindow { public: SfmlWindow( //... std::unique_ptr&lt;RenderSceneBuilder&gt; inputSceneBuilder = nullptr //... ); //... virtual auto update(const SceneUpdate&amp; sceneUpdate) override -&gt; void; private: //... std::unique_ptr&lt;RenderSceneBuilder&gt; sceneBuilder; //... }; Teraz utworzymy mocka z interfejsu, MockRenderSceneBuilder. class MockRenderSceneBuilder : public RenderSceneBuilder { public: MOCK_METHOD(void, build, (const SceneUpdate&amp;), (override)); MOCK_METHOD(RenderItems, popRenderItems, (), (override)); }; W tym przypadku klasa mocka przysłania tylko interfejs i wszystko mamy czyste. Wstrzykujemy mocka do naszej testowanej klasy poprzez konstruktor i voilà! Drugi sposób - do destruktora oraz wszystkich publicznych metod klasy, którą chcemy zamockować dodajemy virtual. Dla przykładu mamy klasę GameSession. class GameSession { public: explicit GameSession(std::unique_ptr&lt;SceneItemFactory&gt; inputFactory = nullptr); virtual ~GameSession() = default; virtual auto addPlayer() -&gt; PlayerID; virtual auto removePlayer(const PlayerID&amp; playerId) -&gt; void; virtual auto queuePlayerStatus(const PlayerID&amp; playerId, const PlayerStatus&amp; playerStatus) -&gt; void; virtual auto updateGameWorld() -&gt; void; virtual auto getUpdateForPlayer(const PlayerID&amp; playerId) const -&gt; GameplayUpdate; private: //... }; I mockujemy. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, (), (override)); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override)); MOCK_METHOD(void, updateGameWorld, (), (override)); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override)); }; Jeśli pozostawimy część publicznych metod jako niewirtualne i nie przysłonimy ich w mocku to nie odcinamy w pełni zależności między naszą testowaną klasą, a klasą zmockowaną. Taki test de facto nie jest już unit testem lecz czymś w rodzaju karykatury module testu. Poniżej przykład class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, (), (override)); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override)); MOCK_METHOD(void, updateGameWorld, (), (override)); GameplayUpdate getUpdateForPlayer(const PlayerID&amp;) const override { // Generuje losowe wartości i wypełnia nimi GameplayUpdate } }; W przypadku, gdy dopisujemy jakąś część logiki w kodzie mocka ograniczamy widoczność tych operacji w naszych testach. Mock sam z siebie nie powinien nic robić. Służy on do weryfikacji zachowania naszej testowanej klasy, tj. jego interakcji z mockowaną klasą. Jeśli potrzebujemy, by nasz mock reagował na te interakcje Google Mock udostępnia szereg narzędzi jak ON_CALL i EXPECT_CALL z odpowiednią kombinacją na przykład WillOnce i Invoke (są też inne metody na sterowanie zachowaniem mocka). Wtedy wszystko jest zapisane w naszym unit teście, w bloku “Arrange”. Testowanie Mocka Jak już wspomniałem mocki służą do weryfikacji interakcji z naszą testowaną klasą. Spotkałem się jednak z innym sposobem wykorzystywania mocków w unit testach. Kiedy nie znamy dobrych podstaw pisania unit testów (o których jeszcze napiszę ;) ), mogą powstać naprawdę dziwne rzeczy. W unit testach widziałem wiele nietypowych konstrukcji, i w rzeczy samej testowanie mocka jest jedną z nich. Chcąc odciąć jakąś zależność możemy zastosować mocka, aby przysłonić część implementacji lub wręcz zastąpić ją inną. Co de facto mija się z celem testowania. Dla przykładu, mamy mocka klasy MockGameSession z poprzedniego punktu. Tym razem jak najbardziej poprawnego. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, ()); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;)); MOCK_METHOD(void, updateGameWorld, ()); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const)); MOCK_METHOD(Texture, getTexture, (const std::string), (const)); // metoda protected w GameSession }; Natomiast w unit testach chcemy przetestować metodę addPlayer klasy GameSession, jednak korzysta ona z metody getTexture odczytującej teksturę gracza z pliku. W takim przypadku moglibyśmy zastosować “Wrapper” lub wprowadzić osobny obiekt klasy Factory i zacmokocwać ją stosująć Dependency Injection. Jednak nie znając jeszcze tych technik możemy pokusić się o użycie mocka w taki sposób, by podczas testowania metody addPlayer przysłonić tylko metodę getTexture, która to odpowiedzialna jest za odczyt pliku. TEST_F(GameSessionTests, addPlayer_OneNewPlayer_ReturnNewPlayerId) { auto factory { std::make_unique&lt;MockSceneItemFactory&gt;() }; EXPECT_CALL(*factory, create(_, _, _)); MockGameSession gameSession { std::move(factory) }; EXPECT_CALL(gameSession, getTexture(_)).WillOnce(Return(Texture())); // Mockowanie zależności odczytu z pliku EXPECT_CALL(gameSession, addPlayer()).WillOnce(Invoke([&amp;](){ // Mockowana metoda wykonuje tą prawdziwą return gameSession.GameSession::addPlayer(); })); const auto resultPlayerId { gameSession.addPlayer() }; // Wywołanie mockowanej metody EXPECT_EQ(0, resultPlayerId); } Dlaczego uważam to za fatalny pomysł? W końcu działa… No cóż to tak jakby używać spawarki do wbijania gwoździ, no niby da się tylko po co? Mocki zostały wymyślone po to by odcinać zależności między klasami, a nie do grzebania w implementacji naszej testowanej klasy. Gdy widzę test, w którym nie ma normalnej klasy, tylko same mocki to coś tu jest nie tak. Taki test jest bardzo nieczytelny. Gdy dodamy do tego enigmatyczną nazwę to praktycznie na pierwszy czy nawet drugi rzut oka, nie jesteśmy w stanie stwierdzić, która klasa jest testowana. W GoogleTest są oczywiście nazwa test suity, która może w tym przypadku podpowiedzieć to i owo, niemniej, czytelność i tak spada diametralnie. Używajmy narzędzi zgodnie z ich pierwotnym przeznaczeniem, zwłaszcza podczas testowania. Dbamy tym samym o wysoką czytelność i przejrzystość w naszych unit testach. Brak override w mockach Słowo kluczowe (a dokładnie specyfikator) override możemy stosować również w mockowanych metodach i działa ono dokładnie tak samo jak w zwykłych klasach. W MOCK_METHOD na końcu, w sekcji gdzie dodajemy kwalifikatory i specyfikatory. Dla przykładu, wróćmy do MockGameSession. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, ()); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;)); MOCK_METHOD(void, updateGameWorld, ()); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const)); }; Jeśli w takim przypadku metoda removePlayer w klasie GameSession nie będzie wirtualna, kompilator i tak nie zwróci błędu. Kod skompiluje się, a my będziemy zachodzić w głowę czemu nasz mock nie jest wywoływany. Użycie override eliminuje problem. W przypadku, gdy dodamy ten specyfikator, a metoda w klasie bazowej nie będzie wirtualna, kompilator zwróci błąd. Tak jak na poniższym przykładzie. Tutaj już poprawiony mock. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, (), (override)); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override)); MOCK_METHOD(void, updateGameWorld, (), (override)); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override)); }; Oraz błąd zwracany przez kompilator. /.../MockGameSession.hpp:16:23: error: 'testing::internal::Function&lt;void(const int&amp;)&gt;::Result MockGameSession::removePlayer(testing::internal::ElemFromList&lt;0, const int&amp;&gt;::type)' marked 'override', but does not override 16 | MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); | Podsumowanie To już wszystko w tym wpisie. Mam nadzieję, że będzie dla Ciebie choć trochę pomocny w zmaganiach z Google Test’em. Czy któryś z wymienionych w tym wpisie błędów Cię zaskoczył? Może inny jest dość znajomy? Daj znać w komentarzu! Popełnianie błędów jest czymś normalnym. Ważne by się rozwijać i uczyć od siebie nawzajem. Jeśli znasz inne przypadki, chętnie się z nimi zapoznam. Możesz również napisać do mnie email lub wysłać wiadomość na LinkedIn. Będzie mi bardzo miło :) Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn]]></summary></entry><entry><title type="html">Zależności globalne - jak poradzić sobie z nimi w unit testach</title><link href="https://cpptested.com/unit-testing/handling-globals/" rel="alternate" type="text/html" title="Zależności globalne - jak poradzić sobie z nimi w unit testach" /><published>2025-12-16T00:00:00+01:00</published><updated>2025-12-16T00:00:00+01:00</updated><id>https://cpptested.com/unit-testing/handling-globals</id><content type="html" xml:base="https://cpptested.com/unit-testing/handling-globals/"><![CDATA[<p>Każdy dobry unit test powinien nie tylko weryfikować nasz kod ale również odcinać zewnętrzne zależności, tak, aby przeprowadzenie testu odbywało się w izolacji. Typów zależności jest kilka, jednak najbardziej problematycznym są te globalne. Zaszyte w naszym kodzie potrafią skutecznie uniemożliwić nam odizolowanie naszej testowanej jednostki. Czy można coś z tym zrobić? Oczywiście! Jest na to kilka naprawdę dobrych technik. A więc zacznijmy od podstaw.</p>

<h3 id="czym-są-zależności-globalne">Czym są zależności globalne</h3>

<p>Celowo nie użyłem słowa “zmienne” bo to nie jedyny problem. Możemy natrafić na stałe lub makra, które są zależne od platformy, na której nasz kod jest uruchamiany. Innym rodzajem zależności globalnej będzie <a href="https://pl.wikipedia.org/wiki/Singleton_(wzorzec_projektowy)" target="_blank" rel="noopener">Singleton</a>, z którego nasza testowana klasa korzysta. Kolejnym rodzajem zależności globalnej mogą być zmienne statyczne.</p>

<p>Ostatnią kategorią zależności globalnej jest wolna funkcja! Pewnie pomyślisz coś w stylu: “Ale jak to? To coś złego? Po prostu przetestuję logikę mojej klasy wraz z logiką funkcji!” Oczywiście, jak najbardziej możesz to zrobić i nawet nie będzie to takie złe. Tylko wolna funkcja powinna mieć swój zestaw testów. Po co więc powielać je jako część naszych nowych unit testów? Dobrze by było zasymulować co wolna funkcja ma zwrócić, tak, aby uzyskać pożądany przepływ sterowania w naszym kodzie, bez “wstrzeliwania się” w jej logikę.
Do wolnych funkcji zaliczamy również funkcje i obiekty z biblioteki standardowej lub frameworków oraz statyczne metody klas.</p>

<p>Jak widzisz zależności globalne mają różne formy. W świetnej książce <a href="https://lubimyczytac.pl/ksiazka/238260/praca-z-zastanym-kodem-najlepsze-techniki" target="_blank" rel="noopener">Praca z zastanym kodem. Najlepsze techniki</a> autora Michael’a Feathers’a, polskie tłumaczenie wykonane przez Ireneusza Jakóbika, określa tego rodzaju rozwiązania jako <strong>“spoiny”</strong>. Jak dla mnie bardzo trafne i ciekawe tłumaczenie, które również w moim wpisie się pojawi. Przejdźmy zatem do metod radzenia sobie z nimi.</p>

<h3 id="linkowanie">Linkowanie</h3>

<p>Jednym z rozwiązań, którym możemy się posłużyć, by odciąć zależności globalne jest proces linkowania. Jeżeli implementacja wolnej funkcji czy Singleton’u jest w pliku <strong>.cpp</strong>. Możemy stworzyć ich odpowiedniki tylko dla testów, które będą zwracać cały czas te same wartości lub mieć implementację z możliwością sterowania co i jak ma być zwracane w testach, tak aby każdy test był niezależny.</p>

<p>Mamy klasę <strong>TemperatureSensor</strong>, która do komunikacji z czujnikiem temperatury wykorzystuje protokół <a href="https://pl.wikipedia.org/wiki/I%C2%B2C" target="_blank" rel="noopener">I²C</a>, który jest zaimplementowany jako wolne funkcje w pliku <strong>I2cBus.hpp</strong> i <strong>I2cBus.cpp</strong>.</p>

<p>Tutaj fragment z implementacji klasy <strong>TemperatureSensor</strong> z użyciem zależności globalnej.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">TemperatureSensor</span><span class="o">::</span><span class="n">getAvgTemperature</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">sensorDrivers</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
      <span class="k">return</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">tempSum</span> <span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span> <span class="p">};</span>
    <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">sensorDriver</span> <span class="o">:</span> <span class="n">sensorDrivers</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tempSum</span> <span class="o">+=</span> <span class="n">i2c</span><span class="o">::</span><span class="n">getSensorTemp</span><span class="p">(</span><span class="n">sensorDriver</span><span class="p">.</span><span class="n">address</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tempSum</span> <span class="o">/</span> <span class="n">sensorDrivers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Spoinę linkowania możemy zastosować, gdy w pliku nagłówkowym mamy tylko deklarację.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">i2c</span>
<span class="p">{</span>

<span class="kt">float</span> <span class="n">getSensorTemp</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">sensorAddress</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Natomiast definicja znajduje się w pliku źródłowym (.cpp).</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">i2c</span>
<span class="p">{</span>

<span class="kt">float</span> <span class="n">getSensorTemp</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">sensorAddress</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//Tutaj produkcyjna implementacja</span>
<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>W takiej sytuacji możemy stworzyć osobną definicję dla testów w pliku <strong>I2cBusStub.cpp</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">i2c</span>
<span class="p">{</span>

<span class="kt">float</span> <span class="n">getSensorTemp</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">sensorAddress</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">32.1</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Struktura projektu mogłaby wyglądać tak:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-project</span> <span class="se">\</span>
  - src<span class="se">\</span>
    - temperatureSensor <span class="se">\</span>
      - I2cBus.hpp
      - I2cBus.cpp
      - TemperatureSensor.hpp
      - TemperatureSensor.cpp
    - tests <span class="se">\</span>
      - stubs
        - I2cBusStub.cpp
      - ut
        - TemperatureSensorTests.cpp
</code></pre></div></div>

<p>W systemie budowany dla testów jako plik źródłowy do nagłówka <strong>I2cBus.hpp</strong> podajemy implementację z folderu <strong>stubs</strong> i spoina gotowa.</p>

<p>W ten sposób w naszych unit testach, nie będziemy korzystać z produkcyjnej implementacji tylko z stubowej/mockowej wersji. O różnicach między stubem, a mockiem pewnie jeszcze napiszę ;).</p>

<p>Podsumowując zastosowanie spoiny linkowania odbywa się tak:</p>
<ol>
  <li>Jeśli trzeba przenosisz implementację zależności globalnej do pliku źródłowego.</li>
  <li>Tworzysz stuba lub mocka zależności globalnej i dostosowujesz system budowania.</li>
</ol>

<p>Spoina linkowania jest w mojej ocenie jednak rozwiązaniem ostatecznym. Rozwiązuje wprawdzie problem zależności globalnych lecz ma spore wady. Po pierwsze wymaga dużo czasu. Nie tylko musimy zaimplementować stuba/mocka, ale dodatkowo zmienić także pliki budowania. Drugą wadą jest bardzo słaba czytelność. Nawet dobrze skonfigurowane IDE nieraz ma problem, by otworzyć odpowiedni plik źródłowy zależności globalnej i pracując przy testach otwiera produkcyjną implementację, co może być bardzo mylące, zwłaszcza dla mniej doświadczonych programistów. Po trzecie, nie jest rozwiązaniem dla wszystkich typów zależności globalnych. Spoiną linkowania nie odetniemy zależności do zmiennych statycznych, funkcji <strong>inline</strong> i innych zależności definiowanych w nagłówkach, których z jakiś powodów nie możemy przenieść do plików źródłowych.</p>

<p>Przejdźmy zatem do spoin obiektowych.</p>

<h3 id="dependency-injection">Dependency Injection</h3>

<p>Wstrzykiwanie zależności to ogólnie dobra metoda separowania zależnych od siebie klas. W przypadku globalnych zależności ta technika również może pomóc. Możemy ją wykorzystać, gdy nasz kod zależny jest od zmiennych globalnych, Singleton’u, a nawet wolnych funkcji.</p>

<p>Technika ta polega na zmianie bezpośredniego wywołania zależności globalnej, w pole klasy i inicjalizowanie go poprzez dodanie parametru konstruktora. Weźmy na warsztat zmienną globalną.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">g_gameObjectsCounter</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

</code></pre></div></div>

<p>Tutaj przykład jej użycia</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Weapon</span><span class="o">::</span><span class="n">fire</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">position</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rotation</span><span class="o">&amp;</span> <span class="n">position</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">bullet</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">g_gameObjectsCounter</span><span class="o">++</span><span class="p">,</span> <span class="n">bulletTexture</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">display</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bullet</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>W takiej wersji zmienna globalna będzie trzymała stan między testami co prowadzi do zależności i złamania zasady <strong>I</strong> z <a href="https://cpptested.com/unit%20testing/first-reguly-ut/" target="_blank" rel="noopener">F.I.R.S.T.</a>.</p>

<p>Teraz spróbujmy przekazywać wartość zmiennej globalnej jako parametr konstruktora testowanej klasy. Plik nagłówkowy będzie wyglądał następująco.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Weapon</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Weapon</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">inputBulletId</span> <span class="o">=</span> <span class="n">g_gameObjectsCounter</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="nl">private:</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">bulletId</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Jak widać, możemy nadać bardziej konkretną nazwę, przekazanej zmiennej globalnej, co poprawia czytelność dodając więcej kontekstu do miejsca jej użycia.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Weapon</span><span class="o">::</span><span class="n">Weapon</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">inputBulletId</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">bulletId</span><span class="p">(</span><span class="n">inputBulletId</span><span class="p">)</span>
<span class="p">{}</span>

<span class="kt">void</span> <span class="n">Weapon</span><span class="o">::</span><span class="n">fire</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">position</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rotation</span><span class="o">&amp;</span> <span class="n">position</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">bullet</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bulletId</span><span class="o">++</span><span class="p">,</span> <span class="n">bulletTexture</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">display</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bullet</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>W każdym teście możemy przekazywać dowolną zmienną, a testy stają się niezależne. W kodzie produkcyjnym niewiele się zmieni. Dodatkowo możemy zdefiniować domyślną wartość nowego parametru i ustawić ją właśnie na zmienną globalną. Zaletą takiego podejścia jest wyrzucenie użycia zmiennej globalnej poza implementację klasy. Możemy też nadać jej lepszą nazwę, bardziej związaną z kontekstem samej klasy. Zmienne globalne zazwyczaj mają bardziej ogólne nazwy. Możemy nawet dojść do miejsca, w którym ta zmienna globalna stanie się tak naprawdę lokalną zmienną tworzoną na stosie funkcji <strong>main</strong>.</p>

<p>Spróbujmy teraz nieco trudniejszy przypadek - Singleton. Wystarczy nam jego plik nagłówkowy. Sama implementacja do zastosowania <strong>Dependency Injection</strong> nie jest nam potrzebna.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TextureStorage</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TextureStorage</span><span class="p">(</span><span class="k">const</span> <span class="n">TextureStorage</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">TextureStorage</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TextureStorage</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">TextureStorage</span><span class="p">(</span><span class="n">TextureStorage</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">TextureStorage</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TextureStorage</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">const</span> <span class="n">TextureStorage</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Texture</span><span class="o">&amp;</span> <span class="n">getTexture</span><span class="p">(</span><span class="k">const</span> <span class="n">TextureId</span> <span class="n">id</span><span class="p">);</span>

<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">TextureId</span><span class="p">,</span> <span class="n">Texture</span><span class="o">&gt;</span> <span class="n">textures</span><span class="p">;</span>

    <span class="n">TextureStorage</span><span class="p">();</span>
    <span class="o">~</span><span class="n">TextureStorage</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<p>A tutaj jego użycie w naszej testowanej klasie <strong>Player</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Player</span><span class="o">::</span><span class="n">Player</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">inputPosition</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rotation</span><span class="o">&amp;</span> <span class="n">inputRotation</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">position</span><span class="p">(</span><span class="n">inputPosition</span><span class="p">)</span>
  <span class="p">,</span> <span class="n">rotation</span><span class="p">(</span><span class="n">inputRotation</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">graphicsStorage</span> <span class="p">{</span> <span class="n">TextureStorage</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">texture</span> <span class="o">=</span> <span class="n">getTexture</span><span class="p">(</span><span class="n">TextureId</span><span class="o">::</span><span class="n">PLAYER</span><span class="p">);</span>

    <span class="c1">//Reszta implementacji konstruktora...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Player</span><span class="o">::</span><span class="n">changeLook</span><span class="p">(</span><span class="k">const</span> <span class="n">TextureId</span><span class="o">&amp;</span> <span class="n">newTexture</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">graphicsStorage</span> <span class="p">{</span> <span class="n">TextureStorage</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">texture</span> <span class="o">=</span> <span class="n">getTexture</span><span class="p">(</span><span class="n">newTexture</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Najpierw będziemy potrzebowali wydzielić potrzebny interfejs dla Singleton’u.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ITextureStorage</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Texture</span><span class="o">&amp;</span> <span class="n">getTexture</span><span class="p">(</span><span class="k">const</span> <span class="n">TextureId</span> <span class="n">id</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">TextureStorage</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Czasem spotykam się z opinią, że dodawanie litery <strong>I</strong> do nazwy interfejsu to zły pomysł. Jak dla mnie uwidacznia on zastosowanie interfejsu co jest zaletą.</p>

<p>Teraz sam Singleton będzie dziedziczył po nowym interfejsie.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TextureStorage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ITextureStorage</span>
<span class="p">{</span>
<span class="nl">public:</span>
<span class="c1">//...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>W naszej klasie <strong>Player</strong> należy dodać referencję do <strong>ITextureStorage</strong> i przekazać ją w konstruktorze.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Player</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Player</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">inputPosition</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rotation</span><span class="o">&amp;</span> <span class="n">rotation</span> <span class="n">inputRotation</span><span class="p">,</span> <span class="k">const</span> <span class="n">ITextureStorage</span><span class="o">&amp;</span> <span class="n">inputTextureStorage</span><span class="p">);</span>

    <span class="c1">//...</span>
<span class="nl">private:</span>
    <span class="k">const</span> <span class="n">ITextureStorage</span><span class="o">&amp;</span> <span class="n">textureStorage</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Dzięki takiemu zabiegowi, będziemy mogli w testach przekazać mocka, który również dziedziczy po tym samym interfejsie co Singleton. Umożliwi nam to pełne i dowolne sterowanie jego zachowaniem w naszej testowanej klasie. W podobny sposób możemy poradzić sobie ze statycznymi obiektami.</p>

<p>Ogólna zasada jest taka:</p>
<ol>
  <li>Dodajesz parametr do konstruktora</li>
  <li>Tworzysz pole i przekazujesz zależność globalną poprzez konstruktor.</li>
</ol>

<p>Jedyną wadę jaką mogę tutaj dostrzec jest czasochłonność takiego rozwiązania. Trzeba dodać nieraz sporo kodu, aby móc skorzystać w pełni z tej techniki. Choć i tak wydaje mi się, że nakładu pracy jest mniej niż w spoinie linkowania.</p>

<h3 id="wrapper">Wrapper</h3>

<p>Ostatnim i w mojej ocenie najlepszym rozwiązaniem do szybkiego, poprawnego i efektywnego odcięcia zależności globalnej jest <strong>wrapper</strong>. To nic innego jak opakowanie użycia globala w metodę. Metodę tą definiujemy jako <strong>virtual</strong> w sekcji <strong>protected</strong>. Tylko co nam to daje? Chyba najłatwiej będzie to zrozumieć na przykładzie.</p>

<p>Mamy klasę <strong>LoanScheduleGenerator</strong>, która wykorzystuje zmienną globalną <strong>g_interestRate</strong> w metodzie <strong>generate</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">g_interestRate</span> <span class="o">=</span> <span class="mf">0.035</span><span class="p">;</span>

<span class="n">PaymentSchedule</span> <span class="n">LoanScheduleGenerator</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="k">const</span> <span class="n">Loan</span><span class="o">&amp;</span> <span class="n">loan</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">numOfMonths</span> <span class="p">{</span> <span class="mi">12</span> <span class="p">};</span>
    <span class="kt">double</span> <span class="n">monthlyRate</span> <span class="o">=</span> <span class="n">g_interestRate</span> <span class="o">/</span> <span class="n">numOfMonths</span><span class="p">;</span>
    <span class="c1">// dalsza część implementacji generowania harmonogramu spłaty kredytu</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dodajemy wirtualną metodę <strong>getInterestRate</strong> w sekcji <strong>protected</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LoanScheduleGenerator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">//...</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">double</span> <span class="n">getInterestRate</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Następnie umieszczamy w niej globalną zależność. I zastępujemy bezpośrednie użycie globala <strong>wrapperem</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">LoanScheduleGenerator</span><span class="o">::</span><span class="n">getInterestRate</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">g_interestRate</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">PaymentSchedule</span> <span class="n">LoanScheduleGenerator</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="k">const</span> <span class="n">Loan</span><span class="o">&amp;</span> <span class="n">loan</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">numOfMonths</span> <span class="p">{</span> <span class="mi">12</span> <span class="p">};</span>
    <span class="kt">double</span> <span class="n">monthlyRate</span> <span class="o">=</span> <span class="n">getInterestRate</span><span class="p">()</span> <span class="o">/</span> <span class="n">numOfMonths</span><span class="p">;</span>
    <span class="c1">// dalsza część implementacji generowania harmonogramu spłaty kredytu</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Przejdźmy do testów. Dzięki <strong>wrapperowi</strong> możemy stworzyć klasę <strong>Testable</strong>, dziedziczącą po klasie <strong>LoanScheduleGenerator</strong>, którą chcemy przetestować i właśnie w niej przysłaniamy <strong>wrappera</strong> nadając mu potrzebne zachowanie.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LoanScheduleGeneratorTestable</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LoanScheduleGenerator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">//...</span>

<span class="nl">private:</span>
    <span class="kt">double</span> <span class="n">getInterestRate</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>W ten sposób odcinamy zależność, minimalizując przy tym ingerencję w kod produkcyjny. Zastosowanie <strong>wrappera</strong> sprowadza się do kilku kroków:</p>
<ol>
  <li>Tworzysz wirtualną metodę w sekcji <strong>protected</strong> testowanej klasy (<strong>wrapper</strong>).</li>
  <li>Przenosisz wywołanie zależności globalnej do tej metody.</li>
  <li>Zastępujesz użycie globala <strong>wrapperem</strong>.</li>
  <li>Tworzysz klasę pochodną od klasy testowanej z postfixem <strong>Testable</strong> i przysłaniasz w niej <strong>wrapper</strong>.</li>
</ol>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>I to już wszystko co chciałem przekazać Ci w temacie odcinania zależności globalnych w testach. Mam nadzieję, że dzięki tym technikom, dużo prościej będzie Ci pracować z Twoimi testami. Celowo nie wspomniałem o spoinach kompilacyjnych (z użyciem preprocesora), gdyż uważam je za bardzo mało intuicyjne i z powodzeniem można użyć spoin obiektowych. Niemniej dla ciekawych odsyłam do książki, o której wspomniałem na początku wpisu.</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="unit-testing" /><category term="unit testing" /><category term="code quality" /><category term="developer practices" /><category term="refactoring" /><category term="software testing" /><summary type="html"><![CDATA[Każdy dobry unit test powinien nie tylko weryfikować nasz kod ale również odcinać zewnętrzne zależności, tak, aby przeprowadzenie testu odbywało się w izolacji. Typów zależności jest kilka, jednak najbardziej problematycznym są te globalne. Zaszyte w naszym kodzie potrafią skutecznie uniemożliwić nam odizolowanie naszej testowanej jednostki. Czy można coś z tym zrobić? Oczywiście! Jest na to kilka naprawdę dobrych technik. A więc zacznijmy od podstaw. Czym są zależności globalne Celowo nie użyłem słowa “zmienne” bo to nie jedyny problem. Możemy natrafić na stałe lub makra, które są zależne od platformy, na której nasz kod jest uruchamiany. Innym rodzajem zależności globalnej będzie Singleton, z którego nasza testowana klasa korzysta. Kolejnym rodzajem zależności globalnej mogą być zmienne statyczne. Ostatnią kategorią zależności globalnej jest wolna funkcja! Pewnie pomyślisz coś w stylu: “Ale jak to? To coś złego? Po prostu przetestuję logikę mojej klasy wraz z logiką funkcji!” Oczywiście, jak najbardziej możesz to zrobić i nawet nie będzie to takie złe. Tylko wolna funkcja powinna mieć swój zestaw testów. Po co więc powielać je jako część naszych nowych unit testów? Dobrze by było zasymulować co wolna funkcja ma zwrócić, tak, aby uzyskać pożądany przepływ sterowania w naszym kodzie, bez “wstrzeliwania się” w jej logikę. Do wolnych funkcji zaliczamy również funkcje i obiekty z biblioteki standardowej lub frameworków oraz statyczne metody klas. Jak widzisz zależności globalne mają różne formy. W świetnej książce Praca z zastanym kodem. Najlepsze techniki autora Michael’a Feathers’a, polskie tłumaczenie wykonane przez Ireneusza Jakóbika, określa tego rodzaju rozwiązania jako “spoiny”. Jak dla mnie bardzo trafne i ciekawe tłumaczenie, które również w moim wpisie się pojawi. Przejdźmy zatem do metod radzenia sobie z nimi. Linkowanie Jednym z rozwiązań, którym możemy się posłużyć, by odciąć zależności globalne jest proces linkowania. Jeżeli implementacja wolnej funkcji czy Singleton’u jest w pliku .cpp. Możemy stworzyć ich odpowiedniki tylko dla testów, które będą zwracać cały czas te same wartości lub mieć implementację z możliwością sterowania co i jak ma być zwracane w testach, tak aby każdy test był niezależny. Mamy klasę TemperatureSensor, która do komunikacji z czujnikiem temperatury wykorzystuje protokół I²C, który jest zaimplementowany jako wolne funkcje w pliku I2cBus.hpp i I2cBus.cpp. Tutaj fragment z implementacji klasy TemperatureSensor z użyciem zależności globalnej. float TemperatureSensor::getAvgTemperature() { if(sensorDrivers.empty()) return 0.0f; float tempSum { 0.0f }; for(const auto&amp; sensorDriver : sensorDrivers) { tempSum += i2c::getSensorTemp(sensorDriver.address); } return tempSum / sensorDrivers.size(); } Spoinę linkowania możemy zastosować, gdy w pliku nagłówkowym mamy tylko deklarację. namespace i2c { float getSensorTemp(const int sensorAddress); } Natomiast definicja znajduje się w pliku źródłowym (.cpp). namespace i2c { float getSensorTemp(const int sensorAddress) { //Tutaj produkcyjna implementacja } } W takiej sytuacji możemy stworzyć osobną definicję dla testów w pliku I2cBusStub.cpp. namespace i2c { float getSensorTemp(const int sensorAddress) { return 32.1f; } } Struktura projektu mogłaby wyglądać tak: -project \ - src\ - temperatureSensor \ - I2cBus.hpp - I2cBus.cpp - TemperatureSensor.hpp - TemperatureSensor.cpp - tests \ - stubs - I2cBusStub.cpp - ut - TemperatureSensorTests.cpp W systemie budowany dla testów jako plik źródłowy do nagłówka I2cBus.hpp podajemy implementację z folderu stubs i spoina gotowa. W ten sposób w naszych unit testach, nie będziemy korzystać z produkcyjnej implementacji tylko z stubowej/mockowej wersji. O różnicach między stubem, a mockiem pewnie jeszcze napiszę ;). Podsumowując zastosowanie spoiny linkowania odbywa się tak: Jeśli trzeba przenosisz implementację zależności globalnej do pliku źródłowego. Tworzysz stuba lub mocka zależności globalnej i dostosowujesz system budowania. Spoina linkowania jest w mojej ocenie jednak rozwiązaniem ostatecznym. Rozwiązuje wprawdzie problem zależności globalnych lecz ma spore wady. Po pierwsze wymaga dużo czasu. Nie tylko musimy zaimplementować stuba/mocka, ale dodatkowo zmienić także pliki budowania. Drugą wadą jest bardzo słaba czytelność. Nawet dobrze skonfigurowane IDE nieraz ma problem, by otworzyć odpowiedni plik źródłowy zależności globalnej i pracując przy testach otwiera produkcyjną implementację, co może być bardzo mylące, zwłaszcza dla mniej doświadczonych programistów. Po trzecie, nie jest rozwiązaniem dla wszystkich typów zależności globalnych. Spoiną linkowania nie odetniemy zależności do zmiennych statycznych, funkcji inline i innych zależności definiowanych w nagłówkach, których z jakiś powodów nie możemy przenieść do plików źródłowych. Przejdźmy zatem do spoin obiektowych. Dependency Injection Wstrzykiwanie zależności to ogólnie dobra metoda separowania zależnych od siebie klas. W przypadku globalnych zależności ta technika również może pomóc. Możemy ją wykorzystać, gdy nasz kod zależny jest od zmiennych globalnych, Singleton’u, a nawet wolnych funkcji. Technika ta polega na zmianie bezpośredniego wywołania zależności globalnej, w pole klasy i inicjalizowanie go poprzez dodanie parametru konstruktora. Weźmy na warsztat zmienną globalną. int g_gameObjectsCounter { 0 }; Tutaj przykład jej użycia void Weapon::fire(const Position&amp; position, const Rotation&amp; position) { auto bullet { std::make_unique&lt;Bullet&gt;(g_gameObjectsCounter++, bulletTexture, position, position) }; display-&gt;add(std::move(bullet)); } W takiej wersji zmienna globalna będzie trzymała stan między testami co prowadzi do zależności i złamania zasady I z F.I.R.S.T.. Teraz spróbujmy przekazywać wartość zmiennej globalnej jako parametr konstruktora testowanej klasy. Plik nagłówkowy będzie wyglądał następująco. class Weapon { public: Weapon(int&amp; inputBulletId = g_gameObjectsCounter); //... private: int&amp; bulletId; //... }; Jak widać, możemy nadać bardziej konkretną nazwę, przekazanej zmiennej globalnej, co poprawia czytelność dodając więcej kontekstu do miejsca jej użycia. Weapon::Weapon(int&amp; inputBulletId) : bulletId(inputBulletId) {} void Weapon::fire(const Position&amp; position, const Rotation&amp; position) { auto bullet { std::make_unique&lt;Bullet&gt;(bulletId++, bulletTexture, position, position) }; display-&gt;add(std::move(bullet)); } W każdym teście możemy przekazywać dowolną zmienną, a testy stają się niezależne. W kodzie produkcyjnym niewiele się zmieni. Dodatkowo możemy zdefiniować domyślną wartość nowego parametru i ustawić ją właśnie na zmienną globalną. Zaletą takiego podejścia jest wyrzucenie użycia zmiennej globalnej poza implementację klasy. Możemy też nadać jej lepszą nazwę, bardziej związaną z kontekstem samej klasy. Zmienne globalne zazwyczaj mają bardziej ogólne nazwy. Możemy nawet dojść do miejsca, w którym ta zmienna globalna stanie się tak naprawdę lokalną zmienną tworzoną na stosie funkcji main. Spróbujmy teraz nieco trudniejszy przypadek - Singleton. Wystarczy nam jego plik nagłówkowy. Sama implementacja do zastosowania Dependency Injection nie jest nam potrzebna. class TextureStorage { public: TextureStorage(const TextureStorage&amp;) = delete; TextureStorage&amp; operator=(const TextureStorage&amp;) = delete; TextureStorage(TextureStorage&amp;&amp;) = delete; TextureStorage&amp; operator=(TextureStorage&amp;&amp;) = delete; static const TextureStorage&amp; instance(); const Texture&amp; getTexture(const TextureId id); private: std::map&lt;TextureId, Texture&gt; textures; TextureStorage(); ~TextureStorage(); }; A tutaj jego użycie w naszej testowanej klasie Player. Player::Player(const Position&amp; inputPosition, const Rotation&amp; inputRotation) : position(inputPosition) , rotation(inputRotation) { const auto&amp; graphicsStorage { TextureStorage::instance() }; texture = getTexture(TextureId::PLAYER); //Reszta implementacji konstruktora... } void Player::changeLook(const TextureId&amp; newTexture) { const auto&amp; graphicsStorage { TextureStorage::instance() }; texture = getTexture(newTexture); } Najpierw będziemy potrzebowali wydzielić potrzebny interfejs dla Singleton’u. class ITextureStorage { public: virtual const Texture&amp; getTexture(const TextureId id) = 0; virtual ~TextureStorage() = 0; }; Czasem spotykam się z opinią, że dodawanie litery I do nazwy interfejsu to zły pomysł. Jak dla mnie uwidacznia on zastosowanie interfejsu co jest zaletą. Teraz sam Singleton będzie dziedziczył po nowym interfejsie. class TextureStorage : public ITextureStorage { public: //... }; W naszej klasie Player należy dodać referencję do ITextureStorage i przekazać ją w konstruktorze. class Player { public: Player(const Position&amp; inputPosition, const Rotation&amp; rotation inputRotation, const ITextureStorage&amp; inputTextureStorage); //... private: const ITextureStorage&amp; textureStorage; //... }; Dzięki takiemu zabiegowi, będziemy mogli w testach przekazać mocka, który również dziedziczy po tym samym interfejsie co Singleton. Umożliwi nam to pełne i dowolne sterowanie jego zachowaniem w naszej testowanej klasie. W podobny sposób możemy poradzić sobie ze statycznymi obiektami. Ogólna zasada jest taka: Dodajesz parametr do konstruktora Tworzysz pole i przekazujesz zależność globalną poprzez konstruktor. Jedyną wadę jaką mogę tutaj dostrzec jest czasochłonność takiego rozwiązania. Trzeba dodać nieraz sporo kodu, aby móc skorzystać w pełni z tej techniki. Choć i tak wydaje mi się, że nakładu pracy jest mniej niż w spoinie linkowania. Wrapper Ostatnim i w mojej ocenie najlepszym rozwiązaniem do szybkiego, poprawnego i efektywnego odcięcia zależności globalnej jest wrapper. To nic innego jak opakowanie użycia globala w metodę. Metodę tą definiujemy jako virtual w sekcji protected. Tylko co nam to daje? Chyba najłatwiej będzie to zrozumieć na przykładzie. Mamy klasę LoanScheduleGenerator, która wykorzystuje zmienną globalną g_interestRate w metodzie generate. double g_interestRate = 0.035; PaymentSchedule LoanScheduleGenerator::generate(const Loan&amp; loan) { const unsigned numOfMonths { 12 }; double monthlyRate = g_interestRate / numOfMonths; // dalsza część implementacji generowania harmonogramu spłaty kredytu } Dodajemy wirtualną metodę getInterestRate w sekcji protected. class LoanScheduleGenerator { public: //... protected: virtual double getInterestRate() const; //... }; Następnie umieszczamy w niej globalną zależność. I zastępujemy bezpośrednie użycie globala wrapperem. double LoanScheduleGenerator::getInterestRate() const { return g_interestRate; } PaymentSchedule LoanScheduleGenerator::generate(const Loan&amp; loan) { const unsigned numOfMonths { 12 }; double monthlyRate = getInterestRate() / numOfMonths; // dalsza część implementacji generowania harmonogramu spłaty kredytu } Przejdźmy do testów. Dzięki wrapperowi możemy stworzyć klasę Testable, dziedziczącą po klasie LoanScheduleGenerator, którą chcemy przetestować i właśnie w niej przysłaniamy wrappera nadając mu potrzebne zachowanie. class LoanScheduleGeneratorTestable : public LoanScheduleGenerator { public: //... private: double getInterestRate() const { return 1.0; } }; W ten sposób odcinamy zależność, minimalizując przy tym ingerencję w kod produkcyjny. Zastosowanie wrappera sprowadza się do kilku kroków: Tworzysz wirtualną metodę w sekcji protected testowanej klasy (wrapper). Przenosisz wywołanie zależności globalnej do tej metody. Zastępujesz użycie globala wrapperem. Tworzysz klasę pochodną od klasy testowanej z postfixem Testable i przysłaniasz w niej wrapper. Podsumowanie I to już wszystko co chciałem przekazać Ci w temacie odcinania zależności globalnych w testach. Mam nadzieję, że dzięki tym technikom, dużo prościej będzie Ci pracować z Twoimi testami. Celowo nie wspomniałem o spoinach kompilacyjnych (z użyciem preprocesora), gdyż uważam je za bardzo mało intuicyjne i z powodzeniem można użyć spoin obiektowych. Niemniej dla ciekawych odsyłam do książki, o której wspomniałem na początku wpisu. Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn]]></summary></entry><entry><title type="html">DRY, YAGNI, KISS i inne. Uniwersalne zasady dla każdego programisty.</title><link href="https://cpptested.com/clean-code/dry-and-other-principles/" rel="alternate" type="text/html" title="DRY, YAGNI, KISS i inne. Uniwersalne zasady dla każdego programisty." /><published>2025-11-17T00:00:00+01:00</published><updated>2025-11-17T00:00:00+01:00</updated><id>https://cpptested.com/clean-code/dry-and-other-principles</id><content type="html" xml:base="https://cpptested.com/clean-code/dry-and-other-principles/"><![CDATA[<p>Te tajemnicze akronimy skrywają w sobie dekady doświadczeń naszych programistycznych poprzedników. Choć brzmi to nieco patetycznie, tak właśnie jest. Zasady, opisane w tym wpisie, to dziedzictwo wielu błędów, obserwacji i celnych spostrzeżeń, zbieranych latami przez bardzo doświadczonych ludzi dla ich następców. Te zasady działają jak sita. Przesiany przez nie kod staje się znacznie lepszy, bardziej czytelny, odporny na błędy i łatwiejszy w utrzymaniu.</p>

<h3 id="po-co-nam-zasady">Po co nam zasady?</h3>

<p>Zasady w programowaniu wytyczają nam szlak - kierunek, w jakim powinniśmy podążać, aby uzyskać kod wysokiej jakości. Każda z poniższych reguł, o których wspominam w tym wpisie, dotyka nieco innych aspektów wytwarzanego przez nas oprogramowania. Tworzą one niejako pewien standard. Można oczywiście pisać kod i bez nich, tylko po co? DRY i inne zasady to ogrom doświadczenia naszych poprzedników, z którego powinniśmy korzystać, ucząc się na ich błędach i kto wie, może formułować nowe? Czemu by nie!</p>

<p>Co daje nam trzymanie się dobrych zasad programowania?</p>
<ol>
  <li>Ułatwiają utrzymanie kodu.</li>
  <li>Zmniejszają ryzyko wystąpienia błędów.</li>
  <li>Umożliwiają dobrą współpracę między twórcami i odbiorcami kodu.</li>
  <li>Tworzą bardziej uporządkowany projekt.</li>
  <li>Pomagają podejmować odpowiedzialne decyzje.</li>
</ol>

<p>A teraz przejdźmy już do konkretów.</p>

<h3 id="dry---jedno-źródło-informacji">DRY - jedno źródło informacji</h3>

<p>DRY - Don’t Repeat Yourself - unikaj powielania wiedzy. Zasada ta jest prosta, jeśli widzisz w swoim kodzie ciągle powtarzające się linijki, to należy je odpowiednio nazwać i przenieść do funkcji lub metody, w zależności od kontekstu. Dzięki temu, gdy przyjdzie czas na zmianę (a z pewnością przyjdzie), będziemy musieli edytować tylko jedno miejsce, a nie wiele. Unikniemy sytuacji, gdy trzeba zmienić kod w kilku miejscach i o którymś zapomnimy. Daje nam to również możliwość zwiększenia czytelności naszego kodu. Nowa funkcja czy metoda musi mieć nazwę, warto, by była ona wyjaśniająca, tłumaczyła w krótki sposób, co robi wewnątrz.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Money</span> <span class="nf">calculateSalary</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="mi">18</span> <span class="o">&lt;=</span> <span class="n">employee</span><span class="p">.</span><span class="n">getAge</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">freeDays</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="mi">18</span> <span class="o">&lt;=</span> <span class="n">employee</span><span class="p">.</span><span class="n">getAge</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Widać tutaj powtórzenie, <strong>“18 &lt;= employee.getAge()”</strong>. Jest to pewien element wiedzy biznesowej. Jeśli pracownik jest niepełnoletni, to jego wynagrodzenie i liczba dni wolnych jest inna. Spróbujmy to lepiej wyrazić i zastosować DRY.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">isAdult</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">adultAge</span> <span class="p">{</span> <span class="mi">18</span> <span class="p">};</span>
    <span class="k">return</span> <span class="n">adultAge</span> <span class="o">&lt;=</span> <span class="n">employee</span><span class="p">.</span><span class="n">getAge</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Money</span> <span class="n">calculateSalary</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">isAdult</span><span class="p">(</span><span class="n">employee</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">freeDays</span><span class="p">(</span><span class="k">const</span> <span class="n">Employee</span><span class="o">&amp;</span> <span class="n">employee</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">isAdult</span><span class="p">(</span><span class="n">employee</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To tylko prosty przykład, jak możemy stosować DRY. Należy jednak pamiętać, że ta zasada, jak i wszystkie następne, mają nam pomagać tworzyć kod wysokiej jakości. Jak ze wszystkim, tak z DRY, też da się przesadzić. Zauważyłem, że często w unit testach DRY nie do końca się sprawdza.</p>

<p>Mamy klasę <strong>UserService</strong>, która odpowiada za logowanie (pomińmy na razie aspekty security ;) ).</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserService</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">login</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">username</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">password</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">username</span> <span class="o">==</span> <span class="s">"admin"</span> <span class="o">&amp;&amp;</span> <span class="n">password</span> <span class="o">==</span> <span class="s">"1234"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">checkLogin</span><span class="p">(</span><span class="n">UserService</span><span class="o">&amp;</span> <span class="n">service</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">user</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">pass</span><span class="p">,</span>
                <span class="kt">bool</span> <span class="n">expected</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">service</span><span class="p">.</span><span class="n">login</span><span class="p">(</span><span class="n">user</span><span class="p">,</span> <span class="n">pass</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">UserServiceTest</span><span class="p">,</span> <span class="n">AllLogins</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UserService</span> <span class="n">service</span><span class="p">;</span>
    <span class="n">checkLogin</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="s">"admin"</span><span class="p">,</span> <span class="s">"1234"</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="n">checkLogin</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="s">"admin"</span><span class="p">,</span> <span class="s">"wrong"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">checkLogin</span><span class="p">(</span><span class="n">service</span><span class="p">,</span> <span class="s">"user"</span><span class="p">,</span> <span class="s">"1234"</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>W tym przykładzie testujemy różne sposoby logowania. Wygląda prosto. Nie ma powtórzeń, ale jest tutaj jeden zasadniczy problem - czytelność, a raczej jej brak. Mamy tylko jeden test sprawdzający tę samą jednostkę, ale już w różnych scenariuszach. Nie spełnia on standardu <a href="https://cpptested.com/unit%20testing/AAA-golden-standard/" target="_blank" rel="noopener">AAA</a>. Gdy coś pójdzie nie tak, dużo trudniej będzie dowiedzieć się, który scenariusz nie działa poprawnie.</p>

<p>Teraz porównaj to z poniższymi testami.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST</span><span class="p">(</span><span class="n">UserServiceTest</span><span class="p">,</span> <span class="n">login_ValidCredentials_ReturnTrue</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UserService</span> <span class="n">service</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">service</span><span class="p">.</span><span class="n">login</span><span class="p">(</span><span class="s">"admin"</span><span class="p">,</span> <span class="s">"1234"</span><span class="p">);</span>

    <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">UserServiceTest</span><span class="p">,</span> <span class="n">login_WrongPassword_ReturnFalse</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UserService</span> <span class="n">service</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">service</span><span class="p">.</span><span class="n">login</span><span class="p">(</span><span class="s">"admin"</span><span class="p">,</span> <span class="s">"wrong"</span><span class="p">);</span>

    <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">UserServiceTest</span><span class="p">,</span> <span class="n">login_UnknownUser_ReturnFalse</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">UserService</span> <span class="n">service</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="n">service</span><span class="p">.</span><span class="n">login</span><span class="p">(</span><span class="s">"user"</span><span class="p">,</span> <span class="s">"1234"</span><span class="p">);</span>

    <span class="n">EXPECT_FALSE</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To klasyczny przykład, gdzie czytelność jest wyżej niż DRY. Don’t Repeat Yourself to świetna reguła. Pomaga uporządkować kod, ułatwia wprowadzanie zmian i zrozumienie logiki kodu. W testach również ma swoje zastosowanie, lecz nie powinna być regułą wiodącą w nich prym.</p>

<p>DRY to jednak coś znacznie więcej, niż tylko ograniczanie powielania kodu, jak dla mnie najlepiej opisuję tę zasadę Robert C. Martin w swojej bardzo znanej książce - <a href="https://lubimyczytac.pl/ksiazka/83492/czysty-kod-podrecznik-dobrego-programisty" target="_blank" rel="noopener">Czysty Kod. Podręcznik dobrego programisty</a>, którą z czystym sumieniem polecam ;)</p>

<h3 id="yagni---potrzebne-ponad-możliwe">YAGNI - potrzebne ponad możliwe</h3>

<p>YAGNI - You Aren’t Gonna Need It, ta zasada mówi o tym, że jeśli w danym momencie rozwoju oprogramowania nie potrzebujesz jakiejś funkcjonalności, to jej nie dodawaj. Czasem chcemy wychodzić naprzeciw oczekiwaniom użytkowników naszego kodu, lub staramy się przewidzieć, co jeszcze będzie potrzebne. Zapominamy jednak o czymś bardzo istotnym. Założenia się zmieniają. To, co wydawało nam się być potrzebne, choć nie planowane, po chwili może wylądować w gitowej historii.</p>

<p>W tej regule nie chodzi o to, by nie myśleć o przyszłości, o architekturze. Projekt jest ważny, umożliwia rozwój oprogramowania w jasno określonym kierunku i określony sposób. Bierze pod uwagę różne aspekty, takie jak elastyczność, łatwość utrzymania, koszty wytworzenia i wiele innych.</p>

<p>YAGNI nie mówi o tym, byś nie planował, nie przewidywał. Mówi o tym, byś nie implementował czegoś, co może okazać się niepotrzebne.</p>

<p>Wróćmy do <strong>UserService</strong>. Założenie jest proste, klasa odpowiada za logowanie. Można by przewidzieć, co będzie jeszcze potrzebne do logowania i nasza klasa rozrośnie się.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserService</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">login</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">username</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">password</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">username</span> <span class="o">==</span> <span class="s">"admin"</span> <span class="o">&amp;&amp;</span> <span class="n">password</span> <span class="o">==</span> <span class="s">"1234"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">logout</span><span class="p">()</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">resetPassword</span><span class="p">()</span> <span class="p">{}</span>
    <span class="kt">void</span> <span class="n">twoFactorAuth</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Tylko na tym etapie nie wiemy jeszcze, co tak naprawdę się przyda. Jak mamy zastosować TDD, gdy brak jest założeń? Co zrobić z kodem, którego nikt nie używa?</p>

<p>Nie traćmy czasu i zasobów na tworzenie kodu, którego nikt w danym momencie nie potrzebuje. Ogranicza to również koszty, które taki nadmiarowy kod generuje. Trzeba do niego napisać testy (choć w przykładzie dodaliśmy tylko puste metody, więc testów nie napiszemy), utrzymywać, aktualizować, gdy interfejs się zmienia. To są koszty, koszty, które ponosisz Ty, Twój zespół i Twoja firma. Ogranicz zakres zmian do minimum. YAGNI to istota minimalizmu w programistycznym świecie.</p>

<h3 id="kiss---prosto-ale-skutecznie">KISS - prosto ale skutecznie</h3>

<p>KISS - Keep It Simple, Stupid, dość wymowna nazwa. Kultura w branży IT wydaje mi się na całkiem wysokim poziomie, i nikt raczej nie wyzywa nikogo od idiotów :). Zasada ta mówi o tym, aby nie dodawać nadmiernej złożoności do naszego kodu. Kod prosty, to taki kod, który nie tylko łatwo napisać, ale przede wszystkim zrozumieć i zmienić, gdy będzie to potrzebne. Prosty kod też łatwiej się testuje.</p>

<p>Tutaj chcę zaznaczyć, że sama złożoność kodu nie jest zła, jeśli wynika ze złożoności problemu, który rozwiązuje. KISS trochę łączy się z YAGNI, bo możemy dodać więcej kodu, tworząc bardziej elastyczne rozwiązanie, potencjalnie łatwiejsze w rozszerzaniu. Może stosując jakiś wzorzec projektowy.</p>

<p>Tylko decyzja o użyciu wzorca powinna być podejmowana na poziomie architektury. Nie mówię tu o tym, żeby najpierw mieć cały projekt, a potem kod. W Agile tak się nie dzieje. Całe oprogramowanie tworzymy przyrostowo. Mówię o tym, by nie komplikować kodu bez potrzeby i bez planu.</p>

<p>Spójrz na poniższy przykład. Widać w nim pewien zamysł, może plany na przyszłość. Jednak kod jest zbyt zawiły w stosunku do tego, za co jest odpowiedzialny.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">IValidator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IValidator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">validate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">EmailValidator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IValidator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">validate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">'@'</span><span class="p">)</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">PasswordValidator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IValidator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">validate</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">8</span> <span class="o">&lt;=</span> <span class="n">value</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">UserService</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">UserService</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IValidator</span><span class="o">&gt;</span> <span class="n">inputEmailValidator</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IValidator</span><span class="o">&gt;</span> <span class="n">inputPasswordValidator</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">emailValidator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">inputEmailValidator</span><span class="p">)),</span>
          <span class="n">passwordValidator</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">inputPasswordValidator</span><span class="p">))</span>
    <span class="p">{}</span>

    <span class="kt">bool</span> <span class="n">registerUser</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">email</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">password</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">emailValidator</span><span class="o">-&gt;</span><span class="n">validate</span><span class="p">(</span><span class="n">email</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">passwordValidator</span><span class="o">-&gt;</span><span class="n">validate</span><span class="p">(</span><span class="n">password</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IValidator</span><span class="o">&gt;</span> <span class="n">emailValidator</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">IValidator</span><span class="o">&gt;</span> <span class="n">passwordValidator</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Widać tutaj zdecydowany overengineering. Tyle konstrukcji tylko po to, by sprawdzić dwa proste warunki. Z KISS kod wyglądałby mniej więcej tak.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">UserService</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">registerUser</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">email</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">password</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">email</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">'@'</span><span class="p">)</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">password</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Zdecydowanie, w takim przypadku prostota wygrywa. KISS pomaga nam trzymać w ryzach złożoność naszego kodu.</p>

<p>KISS to świetna zasada w połączeniu z TDD. Każda zmiana w kodzie ma sprawić by nowy test przeszedł, nic więcej. TDD zakłada właśnie to, żeby tworzyć kod, który tylko sprawi, że nasz nowy test przejdzie i nie wprowadzi regresji do poprzednich.</p>

<p>Zasada KISS łamana jest najczęściej w trzech przypadkach:</p>

<ol>
  <li>
    <p>Przedwczesna optymalizacja - stosujemy sztuczki w kodzie, które potencjalnie mogą zwiększyć wydajność kodu. Sprawić, że będzie on działał szybciej. Jednak praktycznie nigdy się tego nie mierzy, a sama optymalizacja jest tak naprawdę znikoma lub pozorna. Kompilator nieraz jest w stanie czysty kod lepiej sam zoptymalizować niż z naszymi “sprytnymi” sztuczkami.</p>
  </li>
  <li>
    <p>Nadużywanie wzorców projektowych - sam się na tym złapałem kilka lat temu, gdy poznałem wzorce. Chęć ich wykorzystania była tak duża, że przy jednym z zadań rekrutacyjnych od razu chciałem zastosować fabrykę, a wystarczyłby jeden prosty <strong>if</strong>.</p>
  </li>
  <li>
    <p>Magia w kodzie - metaprogramowanie, refleksje, wiele poziomów abstrakcji. Te wszystkie rzeczy mają swoje zastosowanie, ale są to narzędzia do konkretnych celów. Nie należy ich stosować wszędzie, gdzie popadnie, bo akurat nam pasuje.</p>
  </li>
</ol>

<p>Jak stosować KISS w codziennej pracy? Najpierw zrób tak, aby działało, potem uprość kod, a na samym końcu optymalizuj, jeśli jest to potrzebne.</p>

<h3 id="pola---to-oczywiste">POLA - to oczywiste!</h3>

<p>POLA - Principle Of Least Astonishment, to nic innego jak zasada najmniejszego zaskoczenia. Gdy widzimy nazwę funkcji lub metody klasy, która mówi <strong>A</strong>, to powinna robić <strong>A</strong>, a nie <strong>ABC</strong> plus jeszcze <strong>Z</strong>. Albo w ogóle nie robi <strong>A</strong>, tylko <strong>F</strong>. W tej zasadzie musimy pamiętać, że tworząc kod, należy dobrze opisywać, co on robi, poprzez nadawanie odpowiednich nazw zmiennym, stałym, metodom, funkcjom itp. Kluczem do zachowania POLA jest dobre nazewnictwo. Zwiększa ono czytelność i łatwość zrozumienia naszego kodu, a to bezpośrednio przekłada się na niższy koszt jego utrzymania. Pamiętajmy, że kod zazwyczaj piszemy raz, czytamy natomiast wielokrotnie.</p>

<p>POLA mówi o tym, by nasz kod, był intuicyjny i spójny w zachowaniu. Jeśli metody naszej klasy robią coś innego niż to, na co wskazuje ich nazwa, łatwo popełnić błąd, trudniej korzystać z takiej klasy, jest to bardziej czasochłonne, bo musimy zapoznać się z jej implementacją. Naruszenie tej zasady bywa nieraz bardzo subtelne, dlatego tym bardziej powinniśmy o niej pamiętać.</p>

<p>Mamy tutaj klasę <strong>FileWriter</strong> z jedną metodą <strong>write</strong>. Pozornie wszystko wygląda ok.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FileWriter</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">file</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directories</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="p">(</span><span class="n">path</span><span class="p">).</span><span class="n">parent_path</span><span class="p">());</span>
            <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">retry</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="n">retry</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Metoda <strong>write</strong> próbuje otworzyć podany w <strong>path</strong> plik. Jeśli się nie uda, utworzy go wraz z wszystkimi katalogami prowadzącymi do pliku. Tylko czy ta metoda powinna to robić? Co jeżeli, ktoś w <strong>path</strong> popełni tylko literówkę? Nazwa <strong>write</strong> nie mówi o tym, że metoda coś tworzy. Jak w takim razie powinna wyglądać?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">FileWriter</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">path</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">data</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">file</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"Cannot open file: "</span> <span class="o">+</span> <span class="n">path</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">file</span> <span class="o">&lt;&lt;</span> <span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Myślę, że rzucenie wyjątku jak najbardziej jest dobrym rozwiązaniem, jeżeli tylko nasz projekt zakłada ich użycie. Jeśli chcesz poznać więcej szczegółów dotyczących sytuacji wyjątkowych, to odsyłam do mojego wpisu o <a href="https://cpptested.com/multithreading/exception-in-thread/" target="_blank" rel="noopener">wyjątkach</a>.</p>

<p>W takiej formie, użytkownik klasy <strong>FileWriter</strong> nie powinien być zaskoczony wyrzuceniem wyjątku, gdy poda złą ścieżkę do pliku, zwłaszcza, iż metoda <strong>write</strong> nie jest oznaczona jako <strong>noexcept</strong>.</p>

<h3 id="lod---im-mniej-wiesz-tym-lepiej">LoD - im mniej wiesz, tym lepiej</h3>

<p>LoD - Law of Demeter, czyli inaczej Principle of Least Knowledge. Zasada najmniejszej wiedzy mówi o tym, by metoda wykorzystywała tylko to, co sama “wie”.</p>

<p>Metoda w klasie powinna komunikować się tylko z obiektami, które zna bezpośrednio. Sprowadza się to do używania tylko własnych pól klasy, przekazanych argumentów, stworzonych przez tę metodę obiektów i ewentualnie elementów globalnych (tak, tak, te ostatnie to zazwyczaj oznaka problemów projektowych, choć nie zawsze. Może napiszę osobny post, jak radzić sobie z globalami w testach).</p>

<p>Przyjrzyjmy się metodzie <strong>sendReport</strong> klasy <strong>ReportService</strong>. Metoda ta korzysta z wszystkich rodzajów dostępnej wiedzy, zachowując jednocześnie LoD.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Report</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">generate</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">"Daily report data"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">EmailClient</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">send</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">recipient</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">content</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Sending email to "</span> <span class="o">&lt;&lt;</span> <span class="n">recipient</span> <span class="o">&lt;&lt;</span> <span class="s">" with content:</span><span class="se">\n</span><span class="s">"</span>
                  <span class="o">&lt;&lt;</span> <span class="n">content</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Config</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">getDefaultRecipient</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="s">"admin@example.com"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ReportService</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">sendReport</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">customRecipient</span> <span class="o">=</span> <span class="s">""</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// użycie argumentu metody</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">recipient</span> <span class="o">=</span> <span class="n">customRecipient</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span>
            <span class="o">?</span> <span class="n">Config</span><span class="o">::</span><span class="n">getDefaultRecipient</span><span class="p">()</span>  <span class="c1">// globalne źródło wiedzy</span>
            <span class="o">:</span> <span class="n">customRecipient</span><span class="p">;</span>

        <span class="c1">// stworzenie i użycie obiektu lokalnego</span>
        <span class="n">Report</span> <span class="n">report</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">content</span> <span class="o">=</span> <span class="n">report</span><span class="p">.</span><span class="n">generate</span><span class="p">();</span>

        <span class="c1">// wysłanie raportu przez własne pole emailClient</span>
        <span class="n">emailClient</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">recipient</span><span class="p">,</span> <span class="n">reportTitle</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span> <span class="o">+</span> <span class="n">content</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">EmailClient</span> <span class="n">emailClient</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">reportTitle</span> <span class="p">{</span> <span class="s">"Daily Report"</span> <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p>W Law od Demeter chodzi o ograniczanie łańcuchów wywołań.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">order</span><span class="p">.</span><span class="n">getCustomer</span><span class="p">().</span><span class="n">getAddress</span><span class="p">().</span><span class="n">getCity</span><span class="p">().</span><span class="n">getName</span><span class="p">();</span>
</code></pre></div></div>

<p>Zamiast takiego łańcuszka powinniśmy dążyć do tego, aby klasa order udostępniła nazwę miasta klienta bezpośrednio.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">order</span><span class="p">.</span><span class="n">getCustomerCityName</span><span class="p">();</span>
</code></pre></div></div>

<p>Wewnątrz tej metody nie powinno być kolejnego, nieco krótszego łańcucha tylko coś w tym rodzaju.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Order</span><span class="o">::</span><span class="n">getCustomerCityName</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">customer</span><span class="p">.</span><span class="n">getCityName</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Zaletą stosowania LoD jest zmniejszenie sprzężenia między klasami. Poprawia się również czytelność kodu.</p>

<h3 id="coi---niczym-klocki-lego">COI - niczym klocki Lego</h3>

<p>COI - Composition Over Inheritance, dziedziczenie to potężny mechanizm niosący za sobą bardzo cenną mechanikę - polimorfizm. Jednak ma ono też drugie oblicze, łatwo można przesadzić. Hierarchia dziedziczenia powinna odzwierciedlać zależności typu “jest”, a nie “ma”. Jeśli klasa dziedziczy po innej tylko dlatego, że część jej funkcjonalności by się przydała, to należy dodać potrzebny obiekt jako nowe pole klasy zamiast po niej dziedziczyć.</p>

<p>Ta zasada nie mówi o tym, by z dziedziczenia nie korzystać, lecz o tym, by korzystać z niego mądrze. Kompozycja daje nam większą elastyczność kodu. Elementy, jako że są to pola klasy, można łatwo dodawać, usuwać czy wymieniać. Wewnętrzna implementacja klasy rodzica, może się zmienić i dużo łatwiej ta zmiana może negatywnie odbić się na naszej klasie, gdy po niej dziedziczy, niż gdy jest tylko polem.</p>

<p>Kompozycja ułatwia też testowanie naszej klasy. Tworząc testy, możemy łatwo zastąpić pola klasy mockami poprzez wstrzykiwanie zależności (Dependency Injection). W ten sposób będziemy mogli skupić się na przetestowaniu logiki tylko naszej klasy. W przypadku dziedziczenia, nie możemy już w tak łatwy sposób oddzielić logiki naszej klasy od logiki rodzica. Musimy nie jako przetestować całość, mimo iż klasa rodzica ma swoje testy.</p>

<p>Dziedziczenie dużo mocniej wiąże ze sobą klasy, co utrudnia ich ponowne użycie. Jeśli nie tworzą spójnej całości, może się okazać, że zamiast ponownie skorzystać z już napisanego kodu, musimy nie jako napisać go od nowa. Boleśnie się o tym przekonałem, gdy zacząłem pisanie swojej drugiej gry. W pierwszej, mocno korzystałem z dziedziczenia, co sprawiło, że nie mogłem w prosty sposób przenieść fragmentu kodu. Musiałbym przenieść kilka klas na raz. To doprowadziło do tego, że zamiast użyć kod ponownie, stał się on tylko przykładem, do którego zaglądam, implementując nową grę.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Shape</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Shape</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Rectangle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Drawing rectangle</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ColoredRectangle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Rectangle</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ColoredRectangle</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">inputColor</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">color</span><span class="p">(</span><span class="n">inputColor</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Drawing "</span> <span class="o">&lt;&lt;</span> <span class="n">color</span> <span class="o">&lt;&lt;</span> <span class="s">" rectangle</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">color</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Mamy tutaj interfejs <strong>Shape</strong>. Klasa <strong>Rectangle</strong> dziedziczy po interfejsie i to jest jak najbardziej ok. Problem zaczyna się w klasie <strong>ColoredRectangle</strong>, która dziedziczy po <strong>Rectangle</strong>. Co się stanie, jeżeli zaczniemy potrzebować klasy kwadratu z obramowaniem albo animacją? Idąc za dziedziczeniem, utworzymy <strong>BorderedRectangle</strong> i <strong>AnimatedRectangle</strong>. A jeśli będziemy potrzebować kolorowego kwadratu z obramowaniem? Kolejna klasa. A teraz dołóżmy trójkąt. Co wtedy? <strong>Triangle</strong>, <strong>ColoredTriangle</strong>, <strong>BorderedTriangle</strong>, <strong>AnimatedTriangle</strong>? Klasy mnożą się w zastraszającym tempie! Spróbujmy zastosować COI w tym przypadku.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ColoredShape</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ColoredShape</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;</span> <span class="n">inputShape</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">inputColor</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">shape</span><span class="p">(</span><span class="n">inputShape</span><span class="p">),</span> <span class="n">color</span><span class="p">(</span><span class="n">inputColor</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Drawing "</span> <span class="o">&lt;&lt;</span> <span class="n">color</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
        <span class="n">shape</span><span class="p">.</span><span class="n">draw</span><span class="p">();</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">Shape</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">color</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Teraz mamy ogólną klasę <strong>ColoredShape</strong>, niezwiązaną bezpośrednio z <strong>Rectangle</strong>. Obie klasy mogą być przetestowane osobno. Dodanie nowego kształtu sprowadza się do utworzenia tylko jednej klasy. Dodanie nowego atrybutu również. Oczywiście i z tym można by powalczyć, tworząc jeszcze bardziej uniwersalne rozwiązanie, ale to tylko przykład.</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>I to już wszystkie najważniejsze zasady programowania, które każdy programista powinien znać i stosować, aby jego kod był wysokiej jakości. Celowo nie poruszyłem tutaj zestawu zasad SOLID, gdyż one bardziej tyczą się projektowania. Przyjdzie i na to czas :). Tymczasem dziękuję Ci za dotrwanie do końca wpisu. Mam nadzieję, że przekazana tutaj wiedza pomoże Ci w codziennych bataliach z kodem. Jeśli masz pomysły na inne tematy, które mógłbym poruszyć na blogu - napisz w komentarzu.</p>

<p>Mój blog oparty jest na GitHub’ie, stąd trzeba się zalogować do niego, ale spokojnie, to jest odizolowany fragment strony, do którego nie mam bezpośredniego dostępu ;). Podobał Ci się ten wpis? Zapraszam do podzielenia się swoją opinią w komentarzu!</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="clean-code" /><category term="clean code" /><category term="code quality" /><category term="developer practices" /><category term="software" /><summary type="html"><![CDATA[Te tajemnicze akronimy skrywają w sobie dekady doświadczeń naszych programistycznych poprzedników. Choć brzmi to nieco patetycznie, tak właśnie jest. Zasady, opisane w tym wpisie, to dziedzictwo wielu błędów, obserwacji i celnych spostrzeżeń, zbieranych latami przez bardzo doświadczonych ludzi dla ich następców. Te zasady działają jak sita. Przesiany przez nie kod staje się znacznie lepszy, bardziej czytelny, odporny na błędy i łatwiejszy w utrzymaniu.]]></summary></entry><entry><title type="html">Wątki i wyjątki. Jak radzić sobie z nieoczekiwanymi zachowaniami w wielowątkowym kodzie.</title><link href="https://cpptested.com/multithreading/exception-in-thread/" rel="alternate" type="text/html" title="Wątki i wyjątki. Jak radzić sobie z nieoczekiwanymi zachowaniami w wielowątkowym kodzie." /><published>2025-10-13T00:00:00+02:00</published><updated>2025-10-13T00:00:00+02:00</updated><id>https://cpptested.com/multithreading/exception-in-thread</id><content type="html" xml:base="https://cpptested.com/multithreading/exception-in-thread/"><![CDATA[<p>Nieoczekiwane zachowanie czyli wyjątek to sytuacja, w której nasz kod zachował się w sposób, który normalnie nie występuje. Może być to wywołane problemami z zasobami jak brak pamięci podręcznej lub brak dostępu do pliku. Powodów może być wiele, najczęściej nie zależą od nas. Jednak możemy się na takie sytuacje przygotować i pomimo wystąpienia wyjątków, nasz program nie przerwie działania.</p>

<h3 id="rodzaje-wyjątków">Rodzaje wyjątków</h3>

<p>Rodzajów wyjątków w STL mamy całkiem sporo i są one pogrupowane w podklasy dziedziczące po <strong>std::exception</strong>. I tak mamy na przykład <strong>std::runtime_error</strong>, który sam w sobie nie jest zgłaszany, jest jednak klasą bazową dla innych, między innymi <strong>std::range_error</strong>, <strong>std::overflow_error</strong>, <strong>std::underflow_error</strong>. Część wyjątków dodana została w późniejszych wersjach C++.</p>

<p>Wyjątki dotyczą różnych problemów, na które nasz program może natrafić, brak elementu w kontenerze - <strong>std::out_of_range</strong>, rzutowanie referencji typów niepołączonych hierarchią - <strong>std::bad_cast</strong> (przy wskaźnikach dostaniemy <strong>nullptr</strong>, a wyjątek nie jest rzucany) czy problemy z alokowaniem pamięci - <strong>std::bad_alloc</strong>. To tylko kilka przykładów, po dokładne szczegóły odsyłam do dokumentacji: <a href="https://en.cppreference.com/w/cpp/error/exception.html" target="_blank" rel="noopener">std::exception</a>.</p>

<p>Prócz standardowych wyjątków, możemy również zdefiniować własne, po prostu dziedzicząc po <strong>std::exception</strong> lub jej klasie pochodnej.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ReadFileException</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span>
<span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">ReadFileException</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">inputFileName</span><span class="p">)</span>
	 <span class="o">:</span> <span class="n">fileName</span><span class="p">(</span><span class="n">inputFileName</span><span class="p">)</span>
	<span class="p">{}</span>

	<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">what</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="k">override</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">fileName</span><span class="p">.</span><span class="n">c_str</span><span class="p">();</span>
	<span class="p">}</span>

<span class="nl">private:</span>
	<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fileName</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="rzucanie-iłapanie-wyjątków">Rzucanie i łapanie wyjątków</h3>

<p>Rzucanie wyjątków w C++ jest banalnie proste, wystarczy użyć słowa kluczowego <strong>throw</strong> na obiekcie klasy wyjątka. Najczęściej będzie to obiekt tymczasowy. Jeszcze nie spotkałem się, z potrzebą składowania obiektów wyjątków, niemniej jest to jak najbardziej możliwe.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">throw</span> <span class="nf">ReadFileException</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">);</span>
</code></pre></div></div>

<p>Jak widać, rzucanie wyjątków jest proste, łatwe i czytelne. Inaczej jest z ich łapaniem. Obsługa wyjątków C++ jest już bardziej złożona. Do przechwytywania wyjątków służy blok <strong>try/catch</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fileHandler</span><span class="p">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">fileContent</span><span class="p">{</span> <span class="n">fileHandler</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">};</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadFileException</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cannot read file: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Block <strong>try</strong> jest prosty, to w nim umieszczamy kod, który może rzucić wyjątek. Block <strong>catch</strong> służy do przechwytywania wyjątków określonego typu oraz ich obsługi, na przykład zwolnienie zasobów takich jak pamięć czy mutex. Po opuszczeniu bloku <strong>catch</strong>, praca programu będzie kontynuowana. Bloków <strong>catch</strong> może być wiele, w zależności od tego jakie operacje muszą zostać wykonane w stosunku do typu rzuconego wyjątku.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fileHandler</span><span class="p">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">fileContent</span><span class="p">{</span> <span class="n">fileHandler</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">};</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadFileException</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cannot read file: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" with code: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dodatkowo wyjątki łapane są według hierarchii dziedziczenia, to znaczy, że jeśli nie zdefiniujemy w bloku <strong>catch</strong> określonego typu wyjątku, ale jego rodzica już tak, to ten wyjątek również zostanie obsłużony.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fileHandler</span><span class="p">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">fileContent</span><span class="p">{</span> <span class="n">fileHandler</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">};</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" with code: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="c1">// ReadFileException zostanie tutaj przechwycony</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cannot read file: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Należy zwrócić uwagę na hierarchię dziedziczenia, jeśli pierwszy blok <strong>catch</strong> będzie ustawiony na klasę bazową, a następny na klasę pochodną, to wyjątek nigdy nie zostanie złapany przez drugi blok <strong>catch</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fileHandler</span><span class="p">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">fileContent</span><span class="p">{</span> <span class="n">fileHandler</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">};</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="c1">// Wyjątek typu std::system_error dziedziczy po std::exception i&amp;nbsp;zostanie tutaj przechwycony</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cannot read file: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="c1">// Ten kod nigdy się nie wykona</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" with code: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Kompilator może nas poinformować ostrzeżeniem w stylu:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>main.cpp:71:1: warning: exception of <span class="nb">type</span> ‘std::system_error’ will be caught by earlier handler <span class="o">[</span><span class="nt">-Wexceptions</span><span class="o">]</span>
   71 | catch<span class="o">(</span>const std::system_error&amp; ex<span class="o">)</span>
      | ^~~~~
main.cpp:66:1: note: <span class="k">for </span><span class="nb">type</span> ‘std::exception’
   66 | catch<span class="o">(</span>const std::exception&amp; ex<span class="o">)</span>
      | ^~~~~
</code></pre></div></div>

<p>Bywają jednak takie sytuacje, gdy chcemy, by każdy wyjątek obsłużyć tak samo i nie ma dla nas znaczenia jaki to typ. Jest na to sposób. C++ nieczęsto stosuje składnię z użyciem wielokropka (<strong>…</strong>). To właśnie jeden z tych przypadków.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fileHandler</span><span class="p">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">fileContent</span><span class="p">{</span> <span class="n">fileHandler</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">};</span>
        <span class="c1">//...</span>
    <span class="p">}</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(...)</span> <span class="c1">// Łapiemy wszystkie wyjątki lecz kosztem braku informacji z&amp;nbsp;metody what()</span>
<span class="p">{</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wielokropek powinien być używany jako ostatni blok <strong>catch</strong>. Nie zalecałbym takiej obsługi wyjątków jako domyślny sposób. Niemniej, warto wiedzieć o jego istnieniu ;).</p>

<p>Wszystkie te sposoby obsługi wyjątków się łączą. Możemy dowolnie definiować liczbę i rodzaje bloków <strong>catch</strong> (zgodnie z hierarchią dziedziczenia). Możemy także zagnieżdżać całe bloki <strong>try/catch</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">try</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fileHandler</span><span class="p">.</span><span class="n">openFile</span><span class="p">(</span><span class="s">"file.txt"</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="k">auto</span> <span class="n">fileContent</span><span class="p">{</span> <span class="n">fileHandler</span><span class="p">.</span><span class="n">read</span><span class="p">()</span> <span class="p">};</span>
            <span class="c1">//...</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadFileException</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Cannot read file: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">fileHandler</span><span class="p">.</span><span class="n">closeFile</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" with code: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(...)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Something unexpected happened!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Trzeba jednak zachować umiar bo możemy skończyć z bardzo nieczytelnym kodem, w którym ciężko w szybki sposób zweryfikować, w który blok <strong>catch</strong> wyjątek zostanie złapany.</p>

<p>C++11 udostępnia nam też słowo kluczowe <strong>noexcept</strong>, którym możemy oznaczyć funkcje i metody nierzucające wyjątków. Czyli takie, które używają operacji bezpiecznych pod względem wyjątków i/lub same je obsługują. Słowo kluczowe <strong>noexcept</strong> możemy także zastosować do konstruktorów i destruktora klasy.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">&amp;</span><span class="n">nbsp</span><span class="p">;</span><span class="o">+</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">FileHandler</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">FileHandler</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
    <span class="o">~</span><span class="n">FileHandler</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">openFile</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">fileName</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">read</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">closeFile</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="n">File</span> <span class="n">file</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Żeby móc oznaczyć funkcję lub metodę jako <strong>noexcept</strong>. Wszystkie operacje i wywoływane funkcje/metody także powinny być oznaczone jako <strong>noexcept</strong>, by zachować bezpieczeństwo w kontekście wyjątków. Niestety kompilator nas nie poinformuje, jeżeli ten warunek nie jest spełniony. 
Co jeśli oznaczymy naszą funkcję/metodę jako <strong>noexcept</strong>, a z jakiegoś powodu jednak rzuci wyjątek? Specyfikacja podpowiada, że zostanie wywołana funkcja <strong>std::terminate()</strong>, która zakończy działanie naszego programu niezależnie od tego czy dany kod był w bloku <strong>try/catch</strong> czy nie.</p>

<p><strong>noexcept</strong> jest równoznaczne z <strong>noexcept(true)</strong>. Natomiast domyślnie wszystkie funkcje i metody oznaczone są jako <strong>noexcept(false)</strong>. Dlaczego dodano osobno <strong>noexcept</strong> oraz <strong>noexcept(true/false)</strong>? Głównie ze względu na szablony i metaprogramowanie, gdzie o tym czy funkcja lub metoda może lub nie może rzucać wyjątków kompilator dowiaduje się dopiero w trakcje kompilacji i konkretyzacji szablonów.</p>

<p><strong>noexcept</strong> jest traktowane jako część typu funkcji. To znaczy, że jeśli mamy wskaźniki na funkcje, które różnią się tylko <strong>noexcept</strong>, to będą one traktowane jako osobne typy. Tak samo jeżeli chodzi o parametry szablonu.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">funcPtr1</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">using</span> <span class="n">funcPtr2</span> <span class="o">=</span> <span class="kt">bool</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>noexcept</strong> nie można za to stosować do przeciążania funkcji, gdyż nie wchodzi w skład jej sygnatury.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// Błąd kompilacji, redefinicja funkcji "add"</span>
</code></pre></div></div>

<p>Zaletą <strong>noexcept</strong> jest przede wszystkim optymalizacja. Kompilator nie musi generować dodatkowego kodu do zwijania stosu po wystąpieniu wyjątku. Może także dobrać bardziej optymalne algorytmy STL. Łatwiej jest kompilatorowi inline’ować funkcję/metodę. Binarka wynikowa, również ma mniejszy rozmiar.</p>

<h3 id="przechwytywanie-wyjątku-wewnątrz-wątku">Przechwytywanie wyjątku wewnątrz wątku</h3>

<p>Przejdźmy teraz do wielowątkowego przechwytywania wyjątków. Nie jest to rzecz taka prosta. Spójrz na ten kod, czy jest on bezpieczny pod względem wyjątków?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">calucalteSumThread</span><span class="p">;</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">calucalteSumThread</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([]()</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"calculation error!"</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(...)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Something unexpected happened!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">calucalteSumThread</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">calucalteSumThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wydawać by się mogło, że tak. Przecież mamy blok <strong>catch</strong> zarówno na wyrzucany wyjątek <strong>std::runtime_error</strong> jak i <strong>…</strong>. Jednak tak nie jest. Po uruchomieniu tego kodu w prostej funkcji <strong>main</strong> zostanie wywołany <strong>std::terminate()</strong>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>terminate called after throwing an instance of <span class="s1">'std::runtime_error'</span>
  what<span class="o">()</span>:  calculation error!
</code></pre></div></div>

<p>Dzieje się tak dlatego, że wątek traktowany jest jako osobny proces pomimo, iż należy do głównego wątku naszej aplikacji. Jednym z rozwiązań tego problemu jest obsługa wyjątków wewnątrz wątku i nie wyrzucanie ich na zewnątrz, tworząc wątek bezpieczny względem wyjątków.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">calucalteSumThread</span><span class="p">;</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">calucalteSumThread</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">([]()</span>
    <span class="p">{</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"calculation error!"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(...)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Something unexpected happened!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="n">calucalteSumThread</span><span class="p">.</span><span class="n">joinable</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">calucalteSumThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wynikiem będzie tylko komunikat przechwyconego wyjątku, a nasz program będzie kontynuował pracę:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>calculation error!
</code></pre></div></div>

<h3 id="przekierowanie-wyjątku-do-wątku-głównego">Przekierowanie wyjątku do wątku głównego</h3>

<p>Tworzenie osobnego bloku <strong>try/catch</strong> w wątku i poza nim może doprowadzić do niepotrzebnej złożoności. Możemy też potrzebować obsłużyć wyjątek w głównym wątku naszej aplikacji, gdy wyjątek wystąpi wewnątrz wątku, aby poprawnie zareagować na taką sytuację. C++ od wersji 11 wraz z całą obsługą wyjątków daje nam kilka narzędzi, które rozwiązują ten problem: <strong>std::async</strong>, <strong>std::packaged_task</strong> i <strong>promise</strong>. Każde z nich umożliwia przekierowanie wyjątków z wątku pobocznego do wątku głównego.</p>

<p>Zacznijmy od <strong>std::async</strong>. To szablon funkcji o zmiennej liczbie parametrów umożliwiający uruchomienie przekazanej funkcji lub metody w osobnym wątku. Zwraca obiekt <strong>std::future</strong>, który po wywołaniu metody <strong>get()</strong> zwróci wynik lub wyjątek jeśli wystąpił.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">exceptionFutureObj</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]()</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"calculation error!"</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">exceptionFutureObj</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Widać tutaj prostotę tego rozwiązania. Wątek poboczny nie zawiera już bloku <strong>try/catch</strong>. Cała obsługa wyjątku dzieje się pod spodem <strong>std::async</strong>. Kod jest czysty i zrozumiały. By mieć pewność, że funkcja przekazana jako parametr uruchomi się w osobnym wątku, trzeba ustawić tryb uruchamiania na <strong>std::launch::async</strong>. W trybie <strong>std::launch::deffered</strong> funkcja zostanie uruchomiona w tym samym wątku dopiero w momencie wywołania metody <strong>get()</strong> lub <strong>wait()</strong> na zwróconym przez <strong>async</strong> obiekcie <strong>future</strong>. Domyślnie, to implementacja decyduje jaki tryb uruchamiania zostanie wykorzystany.</p>

<p>Drugim narzędziem, którym możemy przekazać wyjątki z wątku pobocznego do głównego jest <strong>std::packaged_task</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">packaged_task</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">task</span><span class="p">([]()</span>
<span class="p">{</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"calculation error!"</span><span class="p">);</span>
<span class="p">});</span>
<span class="k">auto</span> <span class="n">exceptionFutureObj</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>
<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">exceptionTaskThread</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">task</span><span class="p">));</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">exceptionFutureObj</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">exceptionTaskThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div>

<p>Pod względem przechwytywania wyjątków <strong>async</strong> i <strong>std::packaged_task</strong> działają tak samo. Oba zwracają obiekt typu <strong>future</strong> i w momencie pobierania wartości zwracanej (<strong>get()</strong>), wyjątek może zostać przechwycony. Zasadnicza różnica pomiędzy nimi jest moment, w którym wątek zostaje uruchomiony. Przy <strong>async</strong>  (z ustawionym <strong>std::launch::async</strong>), w momencie wywoływania. Przy <strong>std::packaged_task</strong>, dopiero, gdy task zostanie przekazany do nowego wątku.</p>

<p>Ostatni sposób na przekazanie wyjątków z wątku pobocznego do głównego, to <strong>std::promise</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">promise</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">exceptionPromise</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">exceptionFutureObj</span> <span class="o">=</span> <span class="n">exceptionPromise</span><span class="p">.</span><span class="n">get_future</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="nf">exceptionTaskThread</span><span class="p">([</span><span class="o">&amp;</span><span class="n">exceptionPromise</span><span class="p">]()</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"calculation error!"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(...)</span>
    <span class="p">{</span>
        <span class="n">exceptionPromise</span><span class="p">.</span><span class="n">set_exception</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">current_exception</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">});</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">exceptionFutureObj</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">exceptionTaskThread</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
</code></pre></div></div>

<p>Widać tutaj od razu, że blok <strong>try/catch</strong> powrócił do ciała naszego wątku pobocznego. Mimo to, jedynym dla nas potrzebnym blokiem <strong>catch</strong> jest ten z wielokropkiem, gdyż zależy nam na przekazywaniu wyjątków do wątku głównego. <strong>promise</strong> daje nam największą kontrolę nad tym, kiedy wątek zostanie uruchomiony, kiedy i jaki wyjątek zostanie przekazany wyżej. Możemy także przekazać jakąś wartość w <strong>std::promise</strong>, w polu <strong>value</strong>. Może w celu debuggowym albo jako wartość domyślną. Zależy od tego co będzie nam potrzebne.</p>

<h3 id="wielokrotne-przechwytywanie-wyjątków">Wielokrotne przechwytywanie wyjątków</h3>

<p>Na koniec jeszcze kwestia przechwytywania wyjątków z różnych wątków pobocznych w wątku głównym. Gdy przy użyciu <strong>std::async</strong>, uruchomimy dwa wątki i w obu zostaną wyrzucone wyjątki to musimy zadbać o to, by każdy został poprawnie obsłużony.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">exceptionFutureObj1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"First thread</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"calculation error!"</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">auto</span> <span class="n">exceptionFutureObj2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[]()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Second thread</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_error_code</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">errc</span><span class="p">(</span><span class="n">EDEADLK</span><span class="p">)),</span> <span class="s">"system error!"</span><span class="p">);</span>
<span class="p">});</span>

<span class="k">try</span>
<span class="p">{</span>
    <span class="n">exceptionFutureObj2</span><span class="p">.</span><span class="n">get</span><span class="p">();</span> <span class="c1">// Rzucenie wyjątku std::system_error, przejście do bloku catch</span>
    <span class="n">exceptionFutureObj1</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">system_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" with code: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">code</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A tutaj wynik działania powyższego fragmentu kodu:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>First thread
Second thread
system error!: Resource deadlock avoided with code: generic:35
</code></pre></div></div>

<p>W tym przypadku, pomimo, iż oba wątki zostały uruchomione, i oba z pewnością rzuciły wyjątki to tylko jeden zostanie przechwycony. Nie liczy się moment rzucenia wyjątku, a moment odebrania wyniku z obiektu <strong>future</strong>. Dopiero wtedy wyjątek rzucany jest w wątku głównym. Dlatego w powyższym przykładzie, wyjątek <strong>std::runtime_error</strong> nie został przechwycony. Drugi <strong>get()</strong> po prostu się nie wykonał.</p>

<p>Aby uniknąć takich sytuacji należy każdą próbę odebrania wyniku z <strong>future</strong> opakować blokiem <strong>try/catch</strong> osobno. Możemy do tego utworzyć szablonowy handler.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Future</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">exceptionHandler</span><span class="p">(</span><span class="n">Future</span><span class="o">&amp;</span> <span class="n">future</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="n">future</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">numOfThreads</span><span class="p">{</span> <span class="mi">5</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;&gt;</span> <span class="n">futures</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">numOfThreads</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">futures</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">async</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">launch</span><span class="o">::</span><span class="n">async</span><span class="p">,</span> <span class="p">[</span><span class="n">idx</span><span class="p">]()</span>
        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Thread nr: "</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"error from thread: "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">idx</span><span class="p">));</span>
        <span class="p">}));</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">future</span> <span class="o">:</span> <span class="n">futures</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">exceptionHandler</span><span class="p">(</span><span class="n">future</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A oto wynik:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Thread nr: 0Thread nr: 1
Thread nr: 2

Thread nr: 4
Thread nr: 3
error from thread: 0
error from thread: 1
error from thread: 2
error from thread: 3
error from thread: 4
</code></pre></div></div>

<p>Jak widać wszystkie wyjątki zostały przechwycone. Widać też asynchroniczność w logowaniu do <strong>std::cout</strong>. W takim przypadku lepiej użyć jakiegoś własnego loggera bezpiecznego dla wątków.</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>W tym wpisie, starałem się zebrać wszystkie najważniejsze informacje dotyczące wyjątków w C++. Od tego jakie wyjątki są dostępne w tym języku programowania, poprzez ich rzucanie i obsługę, kończąc na przekazywaniu ich pomiędzy wątkami. C++ wciąż się zmienia i ewoluuje. Może w przyszłości dojdą nowe mechanizmy związane z wyjątkami. Choć trzeba przyznać, że już teraz mamy spory wachlarz narzędzi do radzenia sobie z nimi :).</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="multithreading" /><category term="cpp" /><category term="exceptions" /><category term="multithreading" /><category term="software" /><summary type="html"><![CDATA[Nieoczekiwane zachowanie czyli wyjątek to sytuacja, w której nasz kod zachował się w sposób, który normalnie nie występuje. Może być to wywołane problemami z zasobami jak brak pamięci podręcznej lub brak dostępu do pliku. Powodów może być wiele, najczęściej nie zależą od nas. Jednak możemy się na takie sytuacje przygotować i pomimo wystąpienia wyjątków, nasz program nie przerwie działania.]]></summary></entry><entry><title type="html">AAA - złoty standard unit testów.</title><link href="https://cpptested.com/unit-testing/AAA-golden-standard/" rel="alternate" type="text/html" title="AAA - złoty standard unit testów." /><published>2025-09-15T00:00:00+02:00</published><updated>2025-09-15T00:00:00+02:00</updated><id>https://cpptested.com/unit-testing/AAA-golden-standard</id><content type="html" xml:base="https://cpptested.com/unit-testing/AAA-golden-standard/"><![CDATA[<p>Arrange Act Assert – to game changer dla jakości unit testów. Dzięki tym prostym zasadom testy stają się nie tylko bardziej czytelne, lecz mogą stanowić doskonałą dokumentację przypadków użycia naszego kodu. Dzielimy nazwę, jak i kod naszego unit testu, na trzy jasno określone bloki.</p>

<p>A czym jest to całe AAA? Zacznijmy od początku.</p>

<h3 id="aaa---złoty-standard">AAA - złoty standard</h3>

<p>O zasadzie AAA (triple A) piszę w swojej świetnej książce: <a href="https://lubimyczytac.pl/ksiazka/243300/testy-jednostkowe-swiat-niezawodnych-aplikacji" target="_blank" rel="noopener">Testy jednostkowe. Świat niezawodnych aplikacji</a> (The Art of Unit Testing) - Roy Osherove. Nie jest on wprawdzie jej bezpośrednim autorem, lecz wielkim fanem, zresztą nie tylko on ;). AAA wywodzi się ze środowiska .NET, niemniej, nie jest zależna od użytej technologii. Świetnie sprawdza się również w świecie C++.</p>

<p>No dobrze, ale czym ta zasada jest i o czym mówi?</p>

<p>AAA - mówi o tym, by podzielić test na trzy logiczne bloki: Arrange, Act i Assert.</p>

<h3 id="arrange">Arrange</h3>

<p>W pierwszym bloku kodu naszego testu przygotowujemy wszystko, co niezbędne, aby naszą testowaną metodę lub funkcję sprawdzić. Przygotowujemy dane wejściowe oraz oczekiwane dane wyjściowe. Tworzymy stuby i mocki oraz ustawiamy ich niezbędne zachowanie względem naszej testowanej jednostki. W tym bloku możemy także wywołać inne metody testowanej klasy, jeśli są nam potrzebne do uzyskania odpowiedniego stanu obiektu. Oczywiście te metody również powinny być zweryfikowane w osobnych testach.</p>

<h3 id="act">Act</h3>

<p>Drugim blokiem jest uruchomienie naszej testowanej metody/funkcji. Najczęściej będzie to pojedyncza linijka kodu, ale nie zawsze. Czasem bywa tak, że działanie naszej testowanej metody jest inne, gdy wywołamy ją kilkukrotnie. Jeśli to jest przedmiotem naszego unit testu, to wtedy jak najbardziej również umieszczamy wszystkie wywołania w bloku <strong>Act</strong>.</p>

<h3 id="assert">Assert</h3>

<p>Trzecim i ostatnim blokiem jest weryfikacja. Tutaj sprawdzamy, czy wartości zwracane przez naszą jednostkę są zgodne z oczekiwanymi. Również tutaj weryfikujemy stan obiektu, jeśli jest to oczekiwane zachowanie testowanej metody. Można spotkać się z zasadą “jedna asercja na test”. Jeśli potraktujemy ją dosłownie, to powielimy testy tylko po to, by zachować tę zasadę i wywoływać pojedynczy ASSERT w teście. Lecz nie o to w niej chodzi, tylko o spójny kontekst asercji. Samych wywołań może być więcej, jeśli tylko są one ściśle powiązane.</p>

<h3 id="przykład-użycia-triplea">Przykład użycia triple A</h3>

<p>Spójrz na poniższy przykład testu niekorzystającego z AAA, czy potrafisz odgadnąć co jest w zasadzie testowane?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">testCollectingTemperatures</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TemperatureSensorManager</span> <span class="n">manager</span><span class="p">;</span>

    <span class="n">TemperatureSensorFactoryStub</span> <span class="n">factory</span><span class="p">;</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">expectedSensorName1</span><span class="p">{</span> <span class="s">"temp_core_1"</span> <span class="p">};</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">addSensor</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">expectedSensorName1</span><span class="p">,</span> <span class="mf">47.3</span><span class="p">));</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">expectedSensorName2</span><span class="p">{</span> <span class="s">"temp_core_2"</span> <span class="p">};</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">addSensor</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">expectedSensorName2</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.0</span><span class="p">));</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">expectedSensorName3</span><span class="p">{</span> <span class="s">"temp_board_0"</span> <span class="p">};</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">addSensor</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">expectedSensorName3</span><span class="p">,</span> <span class="mf">65.1</span><span class="p">));</span>

    <span class="k">auto</span> <span class="n">temps</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">getTemps</span><span class="p">();</span>
    <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedSensorName1</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getName</span><span class="p">());</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedSensorName2</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">getName</span><span class="p">());</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedSensorName3</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">getName</span><span class="p">());</span>

    <span class="n">EXPECT_FLOAT_EQ</span><span class="p">(</span><span class="mf">34.13</span><span class="p">,</span> <span class="n">manager</span><span class="p">.</span><span class="n">getAvgTemp</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>A teraz ten sam test, tylko sformatowany zgodnie z triple A(na co dzień nie dodaję takich komentarzy ;) ):</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">testCollectingTemperatures</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//Arrange</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">expectedSensorName1</span><span class="p">{</span> <span class="s">"temp_core_1"</span> <span class="p">};</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">expectedSensorName2</span><span class="p">{</span> <span class="s">"temp_core_2"</span> <span class="p">};</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">expectedSensorName3</span><span class="p">{</span> <span class="s">"temp_board_0"</span> <span class="p">};</span>
    <span class="n">TemperatureSensorFactoryStub</span> <span class="n">factory</span><span class="p">;</span>
    <span class="n">TemperatureSensorManager</span> <span class="n">manager</span><span class="p">;</span>

    <span class="c1">//Act</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">addSensor</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">expectedSensorName1</span><span class="p">,</span> <span class="mf">47.3</span><span class="p">));</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">addSensor</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">expectedSensorName2</span><span class="p">,</span> <span class="o">-</span><span class="mf">10.0</span><span class="p">));</span>
    <span class="n">manager</span><span class="p">.</span><span class="n">addSensor</span><span class="p">(</span><span class="n">factory</span><span class="p">.</span><span class="n">createSensor</span><span class="p">(</span><span class="n">expectedSensorName3</span><span class="p">,</span> <span class="mf">65.1</span><span class="p">));</span>

    <span class="c1">//Assert</span>
    <span class="k">auto</span> <span class="n">temps</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">getTemps</span><span class="p">();</span>
    <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedSensorName1</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getName</span><span class="p">());</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedSensorName2</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">getName</span><span class="p">());</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedSensorName3</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="n">getName</span><span class="p">());</span>
    <span class="n">EXPECT_FLOAT_EQ</span><span class="p">(</span><span class="mf">34.13</span><span class="p">,</span> <span class="n">manager</span><span class="p">.</span><span class="n">getAvgTemp</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Od razu widać, co jest przedmiotem testu, co jest wymagane na początku oraz jaki wynik będzie oczekiwany. Mimo iż sama nazwa testu nie mówi nam wiele, szybkie spojrzenie na kod daje jednak jasny obraz tego, co unit test sprawdza. No właśnie, nazwa testu… czy można coś z tym zrobić?</p>

<h3 id="nazwa-testu">Nazwa testu</h3>

<p>Standard AAA możemy również wykorzystać przy nadawaniu nazw unit testów. Główną zaletą AAA jest poprawa czytelności testów. Dobra nazwa to nie taka prosta sprawa, jeśli nie zna się przydatnych wytycznych.
Dla przykładu zwykła lub “zła” nazwa testu:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorTests</span><span class="p">,</span> <span class="n">test_no_avg_temp</span><span class="p">)</span>
</code></pre></div></div>

<p>Czy domyślasz się, co jest testowane? W jakich warunkach? Co jest wynikiem testu?
Jeśli się domyślasz, ale tego nie wiesz, już po samej nazwie, to nie jest ona do końca trafiona, prawda?</p>

<p>Ok, spróbujmy teraz z taką nazwą:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorTests</span><span class="p">,</span> <span class="n">calculateAverageTemp_emptyTemperatureInput_ReturnZero</span><span class="p">)</span>
</code></pre></div></div>

<p>Lepiej? Nie wiem jak dla Ciebie, ale dla mnie, tak! Zdecydowanie widać co jest testowane, jak i co będzie wynikiem.
Tym właśnie jest AAA - trzy części nazwy unit testu, w skrócie, schemat budowy nazwy testów wygląda tak:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TestowanaKlasaTest</span><span class="p">,</span> <span class="n">nazwaTestowanejMetody_ScenariuszTestowyZawieraj</span><span class="err">ą</span><span class="n">cyDaneWej</span><span class="err">ś</span><span class="n">ciowe_WynikCzyliToCoMaSi</span><span class="err">ę</span><span class="n">Sta</span><span class="err">ć</span><span class="n">PoWykonaniuTestowanejMetody</span><span class="p">)</span>
</code></pre></div></div>

<p>Powróćmy do naszego przykładowego unit testu i zastosujmy AAA do jego nazwy. Znając wytyczne, zamiast takiej nazwy:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">testCollectingTemperatures</span><span class="p">)</span>
</code></pre></div></div>

<p>Powinniśmy otrzymać coś w tym rodzaju:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">addSensor_AddThreeValidSensors_StoreAllSensorsAndReturnCorrectAverageTemperature</span><span class="p">)</span>
</code></pre></div></div>

<p>Teraz, nie znając ciała testu, łatwo możemy określić co on robi. A dlaczego taki format, a nie inny? Dla przykładu zróbmy listę kilku takich nazw:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">addSensor_AddOneValidSensor_StoreSensorAndReturnAverageTemperatureSameAsSensorTemperature</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">addSensor_AddTwoSensorsOneValid_StoreOneSensorAndReturnAverageTemperatureSameAsSensorTemperature</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">addSensor_AddThreeSensorsAllNoValid_NotStoreAnySensorAndReturnZeroAsAverageTemperature</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">getTemps_NoAddedSensors_ReturnsEmptyContainer</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">getTemps_ThreeSensorsAdded_ReturnsThreeSensors</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">getAvgTemp_NoAddedSensors_ReturnsZero</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">getAvgTemp_AddedOneSensor_ReturnsSameTemperatureAsSensor</span><span class="p">)</span>
</code></pre></div></div>

<p>Przeglądając taki zestaw nazw, szybko zweryfikujemy, czy i jakie metody naszej klasy są przetestowane oraz w jakich warunkach. To miałem na myśli, pisząc o przypadkach użycia. Wystarczy nam lista nazw unit testów i mamy nie tylko zakres testowania, ale także funkcjonalne i zawsze aktualne sposoby użycia naszej klasy. Nawet osoba nietechniczna będzie w stanie ogarnąć, co jest testowane i w jakim zakresie. Nie musi analizować kodu testów.</p>

<h3 id="wyjątki-od-aaa">Wyjątki od AAA</h3>

<p>Od podziału na 3 bloki są pewne wyjątki. Możemy mieć sytuację, gdy chcemy, na przykład przetestować domyślne zachowanie konstruktora i w tym przypadku akurat nie mamy nic do zainicjalizowania. Wtedy po prostu bloku <strong>Arrange</strong> nie ma w teście i to jest ok.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">DoorsLockTests</span><span class="p">,</span> <span class="n">constructor_DefaultBehavior_ShouldReturnEmptyTemps</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TemperatureSensorManager</span> <span class="n">manager</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">temps</span> <span class="o">=</span> <span class="n">manager</span><span class="p">.</span><span class="n">getTemps</span><span class="p">();</span>
    <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">temps</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Inny przykład, gdy jedynym oczekiwanym wynikiem naszej testowanej metody jest wartość przez nią zwrócona. Wtedy <strong>Act</strong> i <strong>Assert</strong> występują razem.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">getAvgTemp_NoAddedSensors_ReturnsZero</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TemperatureSensorManager</span> <span class="n">manager</span><span class="p">;</span>

    <span class="n">EXPECT_FLOAT_EQ</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">manager</span><span class="p">.</span><span class="n">getAvgTemp</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Możemy również dodać zmienną wynikową, by zachować podział na 3 bloki. Takie rozwiązanie też jest dobre.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">getAvgTemp_NoAddedSensors_ReturnsZero</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">TemperatureSensorManager</span> <span class="n">manager</span><span class="p">;</span>

    <span class="k">auto</span> <span class="n">result</span><span class="p">{</span> <span class="n">manager</span><span class="p">.</span><span class="n">getAvgTemp</span><span class="p">()</span> <span class="p">};</span>

    <span class="n">EXPECT_FLOAT_EQ</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Ostatnim przykładem może być test zawierający tylko jedną linijkę kodu.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">TemperatureSensorManagerTest</span><span class="p">,</span> <span class="n">constructor_DefaultBehavior_ShouldNoThrowAnyException</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">EXPECT_NO_THROW</span><span class="p">(</span><span class="n">TemperatureSensorManager</span><span class="p">{});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Zauważ, że we wszystkich przykładach nazwa wciąż zawiera podział zgodny z AAA. Mimo, że samych bloków może brakować, to wciąż test jest czytelny i łatwy do zrozumienia.</p>

<h3 id="gwt">GWT</h3>

<p>W Internecie możesz spotkać się z nazwą GWT. To w zasadzie to samo.
GWT czyli Give(Arrnage) When(Act) Then(Assert). Ja osobiście wolę triple A ;)</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>I to już cały opis triple A. Mam nadzieję, że znajomość złotego standardu podniesie jakość także w Twoich testach. Jak dla mnie AAA naprawdę sporo wnosi i nie widzę żadnych przeciwwskazań do jego stosowania. Po prostu spróbuj!</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="unit-testing" /><category term="clean code" /><category term="code quality" /><category term="developer practices" /><category term="refactoring" /><category term="software testing" /><summary type="html"><![CDATA[Arrange Act Assert – to game changer dla jakości unit testów. Dzięki tym prostym zasadom testy stają się nie tylko bardziej czytelne, lecz mogą stanowić doskonałą dokumentację przypadków użycia naszego kodu. Dzielimy nazwę, jak i kod naszego unit testu, na trzy jasno określone bloki.]]></summary></entry><entry><title type="html">Czym jest TDD i czy warto je stosować?</title><link href="https://cpptested.com/tdd/about-tdd/" rel="alternate" type="text/html" title="Czym jest TDD i czy warto je stosować?" /><published>2025-08-26T00:00:00+02:00</published><updated>2025-08-26T00:00:00+02:00</updated><id>https://cpptested.com/tdd/about-tdd</id><content type="html" xml:base="https://cpptested.com/tdd/about-tdd/"><![CDATA[<p>Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem.</p>

<h3 id="czym-jest-tdd">Czym jest TDD.</h3>

<p>Dla niektórych TDD to zasada, najpierw test (<strong>test first</strong>), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi jednak przyjrzyjmy się jej bliżej.</p>

<p>Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada <strong>test first</strong> to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie.</p>

<p>Metodologia TDD jest jedną z technik programowania ekstremalnego (<a href="https://en.wikipedia.org/wiki/Extreme_programming" target="_blank" rel="noopener">XP</a> - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować.</p>

<h3 id="cykl-pracy-wtdd">Cykl pracy w TDD</h3>

<p>We wpisie o <a href="https://cpptested.com/unit%20testing/first-reguly-ut/" target="_blank" rel="noopener">F.I.R.S.T.</a> wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządzmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe.</p>

<p><strong>Red</strong> - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach.</p>

<p><strong>Green</strong> - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”.</p>

<p><strong>Refactor</strong> - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post).</p>

<p>Pracując w cyklach, częstu uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla progamistów - “pustego ekranu” :) ).</p>

<h3 id="zalety-tdd">Zalety TDD</h3>

<p>Podczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii.</p>

<p><strong>1)</strong> Praca w TDD prowadzi do generowania kodu łatwego w testowaniu.
W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować.</p>

<p><strong>2)</strong> Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone.
Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni.</p>

<p><strong>3)</strong> Zyskujemy zaufanie, że nasza implementacja działa.
Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”.</p>

<p><strong>4)</strong> Konkretyzujemy wymagania, zanim kod jest napisany.
W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać.</p>

<p><strong>5)</strong> Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy.
Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty.</p>

<p><strong>6)</strong> Poczucie ciągłego postępu - zwiększona satysfakcja.
Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza.</p>

<h3 id="wady-tdd">Wady TDD</h3>

<p>TDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować.</p>

<p><strong>1)</strong> W mojej ocenie TDD nie jest łatwe do nauki.
Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nieraz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą.</p>

<p><strong>2)</strong> Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste.
Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać.</p>

<p><strong>3)</strong> Dodatkowy narzut czasowy.
Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem.</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>Porównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę.</p>

<p>W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - <a href="https://lubimyczytac.pl/ksiazka/223586/tdd-sztuka-tworzenia-dobrego-kodu" target="_blank" rel="noopener">TDD. Sztuka tworzenia dobrego kodu</a></p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="tdd" /><category term="clean code" /><category term="code quality" /><category term="developer practices" /><category term="refactoring" /><category term="test driven development" /><summary type="html"><![CDATA[Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem. Czym jest TDD. Dla niektórych TDD to zasada, najpierw test (test first), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi jednak przyjrzyjmy się jej bliżej. Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada test first to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie. Metodologia TDD jest jedną z technik programowania ekstremalnego (XP - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować. Cykl pracy w TDD We wpisie o F.I.R.S.T. wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządzmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe. Red - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach. Green - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”. Refactor - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post). Pracując w cyklach, częstu uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla progamistów - “pustego ekranu” :) ). Zalety TDD Podczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii. 1) Praca w TDD prowadzi do generowania kodu łatwego w testowaniu. W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować. 2) Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone. Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni. 3) Zyskujemy zaufanie, że nasza implementacja działa. Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”. 4) Konkretyzujemy wymagania, zanim kod jest napisany. W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać. 5) Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy. Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty. 6) Poczucie ciągłego postępu - zwiększona satysfakcja. Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza. Wady TDD TDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować. 1) W mojej ocenie TDD nie jest łatwe do nauki. Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nieraz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą. 2) Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste. Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać. 3) Dodatkowy narzut czasowy. Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem. Podsumowanie Porównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę. W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - TDD. Sztuka tworzenia dobrego kodu Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn]]></summary></entry><entry><title type="html">F.I.R.S.T. - jak pisać unit testy lepiej.</title><link href="https://cpptested.com/unit-testing/first-reguly-ut/" rel="alternate" type="text/html" title="F.I.R.S.T. - jak pisać unit testy lepiej." /><published>2025-07-28T00:00:00+02:00</published><updated>2025-07-28T00:00:00+02:00</updated><id>https://cpptested.com/unit-testing/first-reguly-ut</id><content type="html" xml:base="https://cpptested.com/unit-testing/first-reguly-ut/"><![CDATA[<p>F.I.R.S.T. to pewien standard, jaki unit testy powinny spełniać. To zbiór założeń, które wyznaczają kierunek, jaki powinniśmy obierać, pisząc testy.</p>

<h3 id="f-jak-fast">F jak Fast</h3>

<p>Czas oczekiwania na wynik naszych unit testów powinien być jak najkrótszy.</p>

<p>Znani i cenieni specjaliści, jak Robert C. Martin czy Kent Beck, w swoich książkach przytaczają związek między czasem wykonywania testów, a ich regularnym uruchamianiem.
Jeśli testy “kręcą się” kilka lub kilkanaście minut, często zniechęca to programistów do regularnego ich uruchamiania. Dodatkowo,  gdy weźmiemy pod uwagę Test Driven Development, to praktycznie paraliżuje to rozwój kodu i rodzi sporo frustracji.</p>

<p>Kiedy testy “kręcą się” za długo? Tutaj sprawa już nie jest taka prosta. Czy 5 s jest OK? Myślę, że tak. 30 s – jeszcze akceptowalne. 1–2 min? Tutaj już może pojawić się myśl: “Czy zdążę zrobić sobie kawę/herbatę?”
Gdy zaczynamy myśleć o zrobieniu czegoś innego, oczekując na wyniki unit testów, to już jest znak, że trwa to za długo. Gdy pracujemy w TDD, to zmiany często są minimalne, trwające kilka sekund. Nie możemy pozwolić, by ich weryfikacja trwała kilkukrotnie dłużej, bo wybije nas to z rytmu.</p>

<p>Przyczyn długiego oczekiwania na zakończenie unit testów może być kilka:</p>

<p><strong>1)</strong> Sleepy w testach.
   Jeśli w naszych unit testach korzystamy z czasowych opóźnień, to często jest to związane z timerami użytymi w logice naszego kodu.</p>

<p><strong>2)</strong> Dostęp do plików.
   Pojedynczy przypadek raczej nie wpłynie znacząco na czas wykonywania unit testów. Gdy takich odczytów jest więcej, zaczynają one mieć znaczenie.</p>

<p><strong>3)</strong> Zewnętrzny framework do przesyłania message’y/eventów.
   Jeśli nasz kod produkcyjny korzysta z takich rozwiązań, może to w testach doprowadzić do opóźnień. Na przykład, gdy  message nie przyjdzie na czas z powodu obciążenia sprzętu, na którym uruchamiamy testy (współdzielony serwer).</p>

<p>Z pewnością każdy z Was może znaleźć też inne przyczyny opóźnień. Najczęstszym rozwiązaniem jest wprowadzenie warstwy pośredniej, rodzaj interfejsu, aby móc zastąpić implementację problematycznych zależności mockami.</p>

<p>Warto pamiętać i dążyć do tego, aby czas oczekiwania na wyniki unit testów był jak najkrótszy. Podnosi to nie tylko jakość kodu, ale też satysfakcję z samej pracy z nim.</p>

<h3 id="i-jak-independent">I jak Independent</h3>

<p>Unit testy powinny być niezależne od siebie nawzajem, tak aby można było uruchomić je w dowolnej kolejności.</p>

<p>Sytuacja, w której jeden test nie przechodzi tylko dlatego, że inny również nie przeszedł, nie należy do zbyt komfortowych. Tracimy wtedy wiarę w wiarygodność testów. Dodatkowo zmiana w jednym teście wymusza zmianę również w innym.
Framework testowy Google Test domyślnie uruchamia testy w sposób losowy, dzięki czemu złamanie tej reguły powinno wyjść bardzo szybko.</p>

<p>Częstym powodem zależności między testami są zmienne globalne. Istnieją techniki odcinania zależności od zmiennych globalnych czy wolnych funkcji (niezwiązanych z żadnym obiektem).
W mojej ocenie jedną z najlepszych jest opakowanie użycia zmiennej globalnej (czy też funkcji) w metodę klasy w sekcji protected. Tak, aby można było przysłonić jej zachowanie w testach, tworząc klasę Testable.</p>

<p>Technik radzenia sobie ze zmiennymi globalnymi jest więcej i można je znaleźć w tak świetnych książkach jak “Praca z zastanym kodem” czy “Refaktoryzacja. Ulepszanie struktury istniejącego kodu”.</p>

<h3 id="r-jak-repeatable">R jak Repeatable</h3>

<p>Testy powinny być powtarzalne, niezależnie od środowiska, w którym je uruchomimy. Czy to będzie mój laptop, czy serwer firmowy – wyniki testów powinny być takie same.
Esencją braku tej zasady jest znane przez chyba wszystkich programistów zdanie: “U mnie działa.”
Świetnie, ale testy powinny działać wszędzie tam, gdzie się je uruchomi, i zwracać to samo.
Gdy unit test zwraca jeden wynik w środowisku A, a inny wynik w środowisku B – to znak, że ma on jakąś zależność, która powinna zostać odcięta.</p>

<p>Tutaj znów przyczyną może być dostęp do systemu plików. Gdy w jednym środowisku pliki istnieją, a w innym nie – testy zachowują się inaczej.</p>

<p>Inną przyczyną może być korzystanie ze zmiennych środowiskowych.
Tak czy inaczej – takie praktyki przeczą idei unit testów, jaką jest izolacja: odcięcie zewnętrznych zależności i testowanie małego fragmentu w przygotowanym do tego środowisku i scenariuszu.</p>

<p>W mojej ocenie korzystanie z zewnętrznych zależności w testach to droga na skróty, która w dłuższej perspektywie rodzi więcej problemów, niż daje korzyści.</p>

<h3 id="s-jak-self-validating">S jak Self-Validating</h3>

<p>Unit test powinien zwracać jednoznaczny wynik – test się powiódł lub nie.
Testy jednostkowe to jedno z wielu zautomatyzowanych narzędzi wspierających naszą pracę z kodem i podnoszących jego jakość.</p>

<p>Gdy musimy ręcznie weryfikować wyniki testów, marnujemy sporo czasu lub co gorasze, możemy błędnie odczytać ich wynik – dostarczając wadliwy kod lub niepotrzebnie debuggując go, gdy jednak jest poprawny, szukając błędu, który nie istnieje.
Jeśli test wymaga ręcznego sprawdzenia logów, by potwierdzić, czy testowany kod działa, to znaczy, że coś jest nie tak.</p>

<p>Czy możemy wtedy mówić o zautomatyzowanym teście? Zdecydowanie nie.
Informacja zwrotna powinna być jasna – Twój kod działa/nie działa.
Myślę, że ten punkt jest jasny i bez niego nie możemy mówić o cyklu TDD: Red → Green → Refactor. Bez jasnego sygnału, jak zakończyły się testy, nie możemy płynnie pracować w tym rytmie.</p>

<h3 id="t-jak-timely">T jak Timely</h3>

<p>Unit testy powinny być uruchamiane w odpowiednim czasie. W tym punkcie nie mówię o czasie wykonywania, ale o momencie, w którym uruchamiamy testy.</p>

<p>W Test Driven Development (TDD) mamy cykl Red → Green → Refactor, o którym już wspomniałem. Każdy cykl rozpoczyna się od napisania testu i od razu próby jego uruchomienia. Najczęściej kończy się on błędem kompilacji, gdyż nowa metoda, którą chcemy przetestować, jeszcze nie powstała. To też jest wynik “Red”.</p>

<p>Testy uruchamiamy tak często, jak to możliwe, i wprowadzamy zmiany iteracyjnie, małymi krokami. Dzięki takim krótkim cyklom szybko możemy wykryć regresję, a zakres zmian jest minimalny i łatwo możemy dojść do tego, gdzie popełniliśmy błąd.
Timely nie odnosi się już do tego, jak pisać unit testy, tylko jak ich używać - często :)</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>W tym wpisie starałem się przybliżyć pięć cech dobrych unit testów. Są to drogowskazy pomagające nam nie tylko pisać testy lepiej, ale przede wszystkim pracować z nimi na co dzień.
Trzymając się tych reguł, z pewnością odczujemy różnicę w codziennej pracy – zyskując kontrolę nad zmianami, większe zaufanie do kodu i pewność, że nie wprowadzimy regresji.</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="unit-testing" /><category term="clean code" /><category term="software testing" /><category term="code quality" /><category term="refactoring" /><category term="developer practices" /><summary type="html"><![CDATA[F.I.R.S.T. to pewien standard, jaki unit testy powinny spełniać. To zbiór założeń, które wyznaczają kierunek, jaki powinniśmy obierać, pisząc testy.]]></summary></entry></feed>