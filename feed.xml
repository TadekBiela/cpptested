<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2025-08-26T00:31:24+02:00</updated><id>/feed.xml</id><title type="html">CppTested</title><subtitle>Blog o TDD, unit testach, nowoczesnym C++ i wielowątkowości. Jak pisać lepszy, bezpieczniejszy i bardziej przewidywalny kod.</subtitle><author><name>Tadeusz Biela</name></author><entry><title type="html">Czym jest TDD i czy warto je stosować?</title><link href="/tdd/about-tdd/" rel="alternate" type="text/html" title="Czym jest TDD i czy warto je stosować?" /><published>2025-08-26T00:00:00+02:00</published><updated>2025-08-26T00:00:00+02:00</updated><id>/tdd/about-tdd</id><content type="html" xml:base="/tdd/about-tdd/"><![CDATA[<p>Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem.</p>

<h3 id="czym-jest-tdd">Czym jest TDD.</h3>

<p>Dla niektórych TDD to zasada, najpierw test (<strong>test first</strong>), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi jednak przyjrzyjmy się jej bliżej.</p>

<p>Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada <strong>test first</strong> to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie.</p>

<p>Metodologia TDD jest jedną z technik programowania ekstremalnego (<a href="https://en.wikipedia.org/wiki/Extreme_programming" target="_blank" rel="noopener">XP</a> - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować.</p>

<h3 id="cykl-pracy-wtdd">Cykl pracy w TDD</h3>

<p>We wpisie o <a href="https://cpptested.com/unit%20testing/first-reguly-ut/" target="_blank" rel="noopener">F.I.R.S.T.</a> wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządzmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe.</p>

<p><strong>Red</strong> - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach.</p>

<p><strong>Green</strong> - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”.</p>

<p><strong>Refactor</strong> - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post).</p>

<p>Pracując w cyklach, częstu uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla progamistów - “pustego ekranu” :) ).</p>

<h3 id="zalety-tdd">Zalety TDD</h3>

<p>Podczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii.</p>

<p><strong>1)</strong> Praca w TDD prowadzi do generowania kodu łatwego w testowaniu.
W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować.</p>

<p><strong>2)</strong> Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone.
Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni.</p>

<p><strong>3)</strong> Zyskujemy zaufanie, że nasza implementacja działa.
Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”.</p>

<p><strong>4)</strong> Konkretyzujemy wymagania, zanim kod jest napisany.
W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać.</p>

<p><strong>5)</strong> Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy.
Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty.</p>

<p><strong>6)</strong> Poczucie ciągłego postępu - zwiększona satysfakcja.
Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza.</p>

<h3 id="wady-tdd">Wady TDD</h3>

<p>TDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować.</p>

<p><strong>1)</strong> W mojej ocenie TDD nie jest łatwe do nauki.
Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nie raz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą.</p>

<p><strong>2)</strong> Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste.
Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać.</p>

<p><strong>3)</strong> Dodatkowy narzut czasowy.
Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem.</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>Porównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę.</p>

<p>W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - <a href="https://lubimyczytac.pl/ksiazka/223586/tdd-sztuka-tworzenia-dobrego-kodu" target="_blank" rel="noopener">TDD. Sztuka tworzenia dobrego kodu</a></p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="tdd" /><category term="clean code" /><category term="code quality" /><category term="developer practices" /><category term="refactoring" /><category term="test driven development" /><summary type="html"><![CDATA[Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem. Czym jest TDD. Dla niektórych TDD to zasada, najpierw test (test first), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi jednak przyjrzyjmy się jej bliżej. Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada test first to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie. Metodologia TDD jest jedną z technik programowania ekstremalnego (XP - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować. Cykl pracy w TDD We wpisie o F.I.R.S.T. wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządzmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe. Red - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach. Green - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”. Refactor - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post). Pracując w cyklach, częstu uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla progamistów - “pustego ekranu” :) ). Zalety TDD Podczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii. 1) Praca w TDD prowadzi do generowania kodu łatwego w testowaniu. W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować. 2) Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone. Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni. 3) Zyskujemy zaufanie, że nasza implementacja działa. Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”. 4) Konkretyzujemy wymagania, zanim kod jest napisany. W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać. 5) Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy. Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty. 6) Poczucie ciągłego postępu - zwiększona satysfakcja. Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza. Wady TDD TDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować. 1) W mojej ocenie TDD nie jest łatwe do nauki. Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nie raz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą. 2) Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste. Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać. 3) Dodatkowy narzut czasowy. Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem. Podsumowanie Porównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę. W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - TDD. Sztuka tworzenia dobrego kodu Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn]]></summary></entry><entry><title type="html">F.I.R.S.T. - jak pisać unit testy lepiej.</title><link href="/unit%20testing/first-reguly-ut/" rel="alternate" type="text/html" title="F.I.R.S.T. - jak pisać unit testy lepiej." /><published>2025-07-28T00:00:00+02:00</published><updated>2025-07-28T00:00:00+02:00</updated><id>/unit%20testing/first-reguly-ut</id><content type="html" xml:base="/unit%20testing/first-reguly-ut/"><![CDATA[<p>F.I.R.S.T. to pewien standard, jaki unit testy powinny spełniać. To zbiór założeń, które wyznaczają kierunek, jaki powinniśmy obierać, pisząc testy.</p>

<h3 id="f-jak-fast">F jak Fast</h3>

<p>Czas oczekiwania na wynik naszych unit testów powinien być jak najkrótszy.</p>

<p>Znani i cenieni specjaliści, jak Robert C. Martin czy Kent Beck, w swoich książkach przytaczają związek między czasem wykonywania testów, a ich regularnym uruchamianiem.
Jeśli testy “kręcą się” kilka lub kilkanaście minut, często zniechęca to programistów do regularnego ich uruchamiania. Dodatkowo,  gdy weźmiemy pod uwagę Test Driven Development, to praktycznie paraliżuje to rozwój kodu i rodzi sporo frustracji.</p>

<p>Kiedy testy “kręcą się” za długo? Tutaj sprawa już nie jest taka prosta. Czy 5 s jest OK? Myślę, że tak. 30 s – jeszcze akceptowalne. 1–2 min? Tutaj już może pojawić się myśl: “Czy zdążę zrobić sobie kawę/herbatę?”
Gdy zaczynamy myśleć o zrobieniu czegoś innego, oczekując na wyniki unit testów, to już jest znak, że trwa to za długo. Gdy pracujemy w TDD, to zmiany często są minimalne, trwające kilka sekund. Nie możemy pozwolić, by ich weryfikacja trwała kilkukrotnie dłużej, bo wybije nas to z rytmu.</p>

<p>Przyczyn długiego oczekiwania na zakończenie unit testów może być kilka:</p>

<p><strong>1)</strong> Sleepy w testach.
   Jeśli w naszych unit testach korzystamy z czasowych opóźnień, to często jest to związane z timerami użytymi w logice naszego kodu.</p>

<p><strong>2)</strong> Dostęp do plików.
   Pojedynczy przypadek raczej nie wpłynie znacząco na czas wykonywania unit testów. Gdy takich odczytów jest więcej, zaczynają one mieć znaczenie.</p>

<p><strong>3)</strong> Zewnętrzny framework do przesyłania message’y/eventów.
   Jeśli nasz kod produkcyjny korzysta z takich rozwiązań, może to w testach doprowadzić do opóźnień. Na przykład, gdy  message nie przyjdzie na czas z powodu obciążenia sprzętu, na którym uruchamiamy testy (współdzielony serwer).</p>

<p>Z pewnością każdy z Was może znaleźć też inne przyczyny opóźnień. Najczęstszym rozwiązaniem jest wprowadzenie warstwy pośredniej, rodzaj interfejsu, aby móc zastąpić implementację problematycznych zależności mockami.</p>

<p>Warto pamiętać i dążyć do tego, aby czas oczekiwania na wyniki unit testów był jak najkrótszy. Podnosi to nie tylko jakość kodu, ale też satysfakcję z samej pracy z nim.</p>

<h3 id="i-jak-independent">I jak Independent</h3>

<p>Unit testy powinny być niezależne od siebie nawzajem, tak aby można było uruchomić je w dowolnej kolejności.</p>

<p>Sytuacja, w której jeden test nie przechodzi tylko dlatego, że inny również nie przeszedł, nie należy do zbyt komfortowych. Tracimy wtedy wiarę w wiarygodność testów. Dodatkowo zmiana w jednym teście wymusza zmianę również w innym.
Framework testowy Google Test domyślnie uruchamia testy w sposób losowy, dzięki czemu złamanie tej reguły powinno wyjść bardzo szybko.</p>

<p>Częstym powodem zależności między testami są zmienne globalne. Istnieją techniki odcinania zależności od zmiennych globalnych czy wolnych funkcji (niezwiązanych z żadnym obiektem).
W mojej ocenie jedną z najlepszych jest opakowanie użycia zmiennej globalnej (czy też funkcji) w metodę klasy w sekcji protected. Tak, aby można było przysłonić jej zachowanie w testach, tworząc klasę Testable.</p>

<p>Technik radzenia sobie ze zmiennymi globalnymi jest więcej i można je znaleźć w tak świetnych książkach jak “Praca z zastanym kodem” czy “Refaktoryzacja. Ulepszanie struktury istniejącego kodu”.</p>

<h3 id="r-jak-repeatable">R jak Repeatable</h3>

<p>Testy powinny być powtarzalne, niezależnie od środowiska, w którym je uruchomimy. Czy to będzie mój laptop, czy serwer firmowy – wyniki testów powinny być takie same.
Esencją braku tej zasady jest znane przez chyba wszystkich programistów zdanie: “U mnie działa.”
Świetnie, ale testy powinny działać wszędzie tam, gdzie się je uruchomi, i zwracać to samo.
Gdy unit test zwraca jeden wynik w środowisku A, a inny wynik w środowisku B – to znak, że ma on jakąś zależność, która powinna zostać odcięta.</p>

<p>Tutaj znów przyczyną może być dostęp do systemu plików. Gdy w jednym środowisku pliki istnieją, a w innym nie – testy zachowują się inaczej.</p>

<p>Inną przyczyną może być korzystanie ze zmiennych środowiskowych.
Tak czy inaczej – takie praktyki przeczą idei unit testów, jaką jest izolacja: odcięcie zewnętrznych zależności i testowanie małego fragmentu w przygotowanym do tego środowisku i scenariuszu.</p>

<p>W mojej ocenie korzystanie z zewnętrznych zależności w testach to droga na skróty, która w dłuższej perspektywie rodzi więcej problemów, niż daje korzyści.</p>

<h3 id="s-jak-self-validating">S jak Self-Validating</h3>

<p>Unit test powinien zwracać jednoznaczny wynik – test się powiódł lub nie.
Testy jednostkowe to jedno z wielu zautomatyzowanych narzędzi wspierających naszą pracę z kodem i podnoszących jego jakość.</p>

<p>Gdy musimy ręcznie weryfikować wyniki testów, marnujemy sporo czasu lub co gorasze, możemy błędnie odczytać ich wynik – dostarczając wadliwy kod lub niepotrzebnie debuggując go, gdy jednak jest poprawny, szukając błędu, który nie istnieje.
Jeśli test wymaga ręcznego sprawdzenia logów, by potwierdzić, czy testowany kod działa, to znaczy, że coś jest nie tak.</p>

<p>Czy możemy wtedy mówić o zautomatyzowanym teście? Zdecydowanie nie.
Informacja zwrotna powinna być jasna – Twój kod działa/nie działa.
Myślę, że ten punkt jest jasny i bez niego nie możemy mówić o cyklu TDD: Red → Green → Refactor. Bez jasnego sygnału, jak zakończyły się testy, nie możemy płynnie pracować w tym rytmie.</p>

<h3 id="t-jak-timely">T jak Timely</h3>

<p>Unit testy powinny być uruchamiane w odpowiednim czasie. W tym punkcie nie mówię o czasie wykonywania, ale o momencie, w którym uruchamiamy testy.</p>

<p>W Test Driven Development (TDD) mamy cykl Red → Green → Refactor, o którym już wspomniałem. Każdy cykl rozpoczyna się od napisania testu i od razu próby jego uruchomienia. Najczęściej kończy się on błędem kompilacji, gdyż nowa metoda, którą chcemy przetestować, jeszcze nie powstała. To też jest wynik “Red”.</p>

<p>Testy uruchamiamy tak często, jak to możliwe, i wprowadzamy zmiany iteracyjnie, małymi krokami. Dzięki takim krótkim cyklom szybko możemy wykryć regresję, a zakres zmian jest minimalny i łatwo możemy dojść do tego, gdzie popełniliśmy błąd.
Timely nie odnosi się już do tego, jak pisać unit testy, tylko jak ich używać - często :)</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>W tym wpisie starałem się przybliżyć pięć cech dobrych unit testów. Są to drogowskazy pomagające nam nie tylko pisać testy lepiej, ale przede wszystkim pracować z nimi na co dzień.
Trzymając się tych reguł, z pewnością odczujemy różnicę w codziennej pracy – zyskując kontrolę nad zmianami, większe zaufanie do kodu i pewność, że nie wprowadzimy regresji.</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>]]></content><author><name>Tadeusz Biela</name></author><category term="unit testing" /><category term="clean code" /><category term="software testing" /><category term="code quality" /><category term="refactoring" /><category term="developer practices" /><summary type="html"><![CDATA[F.I.R.S.T. to pewien standard, jaki unit testy powinny spełniać. To zbiór założeń, które wyznaczają kierunek, jaki powinniśmy obierać, pisząc testy.]]></summary></entry></feed>