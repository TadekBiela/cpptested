<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.0 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="pl" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>6 najczęstszych błędów z Google Test. - CppTested</title>
<meta name="description" content="Google Test to chyba najbardziej znany i używany framework testowy w projektach C++. Zawiera w sobie masę przydatnych narzędzi do tworzenia różnych rodzajów testów. Ja osobiście stosuję go w swoich projektach pisząc unit testy, ale nic nie stoi na przeszkodzie by tworzyć testy modułowe czy komponentowe (typu black box). Ceniony za swą uniwersalność oraz rozbudowany system asercji jest narzędziem bardzo potężnym. Mimo to nie jest również bez wad. Im bardziej złożone jest narzędzie tym trudniej się go nauczyć i korzystać z niego poprawnie.  Popełniamy błędy. To normalne, ważne jest co z tym zrobimy. Warto wyciągnąć z nich lekcje na przyszłość. Poniższa lista to nic innego jak moje własne obserwacje, jak programiści C++(w tym ja) wykorzystują GTest i gdzie najczęściej popełniają błędy.  Kolejność parametrów asercji  Czy kolejność w asercji typu EXPECT_EQ jest ważna? Owszem! Choć nie wynika ona z samej definicji makra w nagłówku gtest.h. Wspomniana definicja wygląda następująco.  #define EXPECT_EQ(val1, val2) \   EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)   Sam Google Test nie informuje gdzie ma być umieszczona wartość oczekiwania, a gdzie wynikowa. Skąd więc założenie, że wartość expected powinna być pierwsza? Głównie z przykładów z repozytorium Google Test.  Przykład z folderu samples repozytorium Google Test, a dokładnie ten “sample4_unittest”.  TEST(Counter, Increment) {   Counter c;    // Test that counter 0 returns 0   EXPECT_EQ(0, c.Decrement());    // EXPECT_EQ() evaluates its arguments exactly once, so they   // can have side effects.    EXPECT_EQ(0, c.Increment());   EXPECT_EQ(1, c.Increment());   EXPECT_EQ(2, c.Increment());    EXPECT_EQ(3, c.Decrement()); }   Oczywiście jest ich znacznie więcej.  Są dwa powody dlaczego warto najpierw podawać wartość oczekiwaną, a potem wynikową.     Czytelność - przeglądając test, czytamy linijkę od lewej do prawej. Gdy wartością oczekiwaną jest po prostu stałą liczbową lub tekstową, szybciej dowiemy się co jest oczekiwane względem testowanej metody.   Spójność z warunkami w kodzie - znasz ten ból, gdy w if zamiast użyć operatora porównania ==, użyłeś operator przypisania =? Ja tak, dlatego warto najpierw wartość oczekiwaną podawać jako pierwszą. Jeśli jest to stała, kompilator szybko poinformuje nas o pomyłce.    if(i = 5) // Kompilator nie zgłosi błędu  if(5 = i) // a tutaj już tak    Logika jest zachowana ale zwiększa się odporność na błędy.  To która wersja będzie poprawna?  EXPECT_EQ(resultValue, expectedValue); // Ta? EXPECT_EQ(expectedValue, resultValue); // czy ta?   Tak naprawdę - to zależy. Choć sama kolejność jest sugerowana przykładami, nie jest ona napisana wprost. Którą więc wybrać? Jeśli wchodzisz do projektu, gdzie pierwsza wartość to ta wynikowa. Dostosuj się do konwencji już panującej w projekcie. Jeśli to nowy projekt, lub brak jest spójnej konwencji, wybierz wersję, gdzie wartość oczekiwana podawana jest jako pierwsza.  Używanie EXPECT zamiast ASSERT  Ten błąd może kosztować życie (naszego wątku uruchamiającego testy). Dlaczego? Najpierw omówmy różnicę w zachowaniu EXPECT_EQ i ASSERT_EQ (lub dowolnej innej pary tych typów asercji). Obie asercje mają za zadanie sprawdzać czy dana wartość zgadza się z oczekiwaną. Różnica polega na tym co wydarzy się w przypadku niepowodzenia asercji. EXPECT spowoduje, że test nie zostanie zaliczony, wypisze komunikat i przejdzie do następnej linii testu.  TEST_F(WidgetFactoryTests, create_ButtonWidgetType_ReturnButtonWidget) {     const Rect expectedRect { 300, 400, 120, 30 };     const std::string expectedText { &quot;Test Button&quot; };     WidgetFactory factory {};      const auto resultWidget { factory.create(WidgetType::BUTTON, expectedRect, expectedText)};      EXPECT_EQ(WidgetType::LABEL, resultWidget.getType()); // Ta asercja się nie powiedzie     EXPECT_EQ(expectedRect, resultWidget.getRect()); // Ta i następna zostaną wywołane     EXPECT_EQ(expectedText, resultWidget.getText()); }   ASSERT również spowoduje fail testu, wypisze komunikat, ale już nie przejdzie dalej do kolejnej części testu. Test zostaje przerwany w tym miejscu i dalej nie będzie kontynuowany.  TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget) {     const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() };     EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow()));     EXPECT_CALL(*sfmlWindow, add(_));     WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr };      const auto resultWidget {         factory.create(             WidgetType::LABEL,             WidgetGeometry {},             WidgetText {},             WidgetStyle {}         )     }; // Jeśli ta metoda zwróci nullptr      ASSERT_TRUE(resultWidget != nullptr); // to ta asercja się nie powiedzie i test przerywa wykonywanie.     EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType()); // Ta i następna asercja nie zostaną wywołane     EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr); }   Co nam to daje? Bardzo wiele, zwłaszcza gdy kolejne asercje opierają się na naszym ASSERT. Jeśli zastosujemy zwykły EXPECT to test zakończy swoje działanie poprzez brutalne przerwanie w stylu segfaulta.  TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget) {     const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() };     EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow()));     EXPECT_CALL(*sfmlWindow, add(_));     WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr };      const auto resultWidget {         factory.create(             WidgetType::LABEL,             WidgetGeometry {},             WidgetText {},             WidgetStyle {}         )     };       EXPECT_TRUE(resultWidget != nullptr); // zamiast ASSERT jest EXPECT     EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType());     EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr); }   Test nie przejdzie, na dodatek, jeśli w naszej suicie będzie więcej testów i miały być one uruchomione po tym, to do tego nie dojdzie. Cały wątek z naszą suitą zostanie przerwany. Czyli inne testy nawet się nie wykonają.  [ RUN      ] WidgetsFactorySfmlTests.create_LabelType_CreateLabelWidget Setting vertical sync not supported /usr/src/heisttown/src/Sfml/SfmlWidgets/Tests/WidgetsFactorySfmlTests.cpp:42: Failure Value of: resultWidget != nullptr   Actual: false Expected: true   W tym przypadku mamy chociaż informacje co poszło nie tak. Jeśli nie dodalibyśmy, w ogóle asercji na sprawdzanie czy resultWidget nie jest nullptr, nie wiedzielibyśmy nic. Dlatego ważne jest, aby stosować ASSERT czy EXPECT zgodnie z ich przeznaczeniem.  Dlaczego więc nie stosować ASSERT zawsze? Jak już pisałem, ASSERT zatrzymuje test, dalsza jego część nie jest weryfikowana. Jeśli następne asercje nie są zależne od poprzednich to, w takim przypadku zostaną pominięte i nie będziemy wiedzieli, czy tylko ta jedna asercja nie została spełniona, czy cały ich szereg. Obraz sytuacji będzie niekompletny.  Jeśli oczekiwanym wynikiem może być kontener to sprawdź jego rozmiar ASSERTem zanim zaczniesz weryfikować jego konkretne elementy. Albo, gdy wynikiem będzie wskaźnik, sprawdź czy nie jest on nullptr zanim zaczniesz odwoływać się do obiektu pod nim. To tylko najczęściej powtarzające się sytuacje, gdzie należy stosować ASSERT. Z pewnością jest ich więcej.  Porównywanie float’ów bez precyzji  Reprezentacja liczb zmiennoprzecinkowych przez komputer nie jest doskonała i wie to każdy doświadczony programista. Porównywanie wartości typu float czy double ze sobą nie jest takie proste jak liczb całkowitych. Weryfikacja testu odbywa się właśnie przez porównanie, a wyniki zapisane w liczbach zmiennoprzecinkowych mogą się nieznacznie różnić od tych oczekiwanych.  Dlaczego tak się dzieje?  Spora część liczb zmiennoprzecinkowych nie ma idealnej reprezentacji w systemie binarnym. Dlatego komputer musi zaokrąglać wyliczoną wartość do najbliższej zero-jedynkowej wartości. Jest nawet na to określony standard “IEEE 754”. Właśnie ze względu na te zaokrąglenia, porównywanie wartości zmiennoprzecinkowych, może dać fałszywe wyniki. Dlatego stosuje się porównywanie z tolerancją, tak zwany epsilon.  To mi przypomina moje początki nauki pisania unit testów i pracy z Google Test. Tak, mniej więcej, wyglądał jeden z moich pierwszych unit testów w zakresie weryfikacji wyniku zapisanego właśnie w double.  TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr) {     const std::complex&lt;double&gt; sample { 1.0, 0.0 };     const double noise { 0.394 };        const auto resultLlr { llr16QamIMsb(sample, noise) };      EXPECT_EQ(5.0761421319796952, resultLlr); }   Teraz, gdy o tym myślę, chce mi się śmiać, ale kto nie popełnia błędów? Ten kto nic nie robi ;) Dziś sobie z przed lat powiedziałbym co trzeba zrobić w takim przypadku, poprawilibyśmy ten test i wyglądałby następująco.  TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr) {     const std::complex&lt;double&gt; sample { 1.0, 0.0 };     const double noise { 0.394 };        const auto resultLlr { llr16QamIMsb(sample, noise) };      EXPECT_NEAR(5.07614, resultLlr, 0.00001); }   Zmieniła się tylko sama asercja i z pewnością test stał się niewrażliwy na zmianę platformy, która ma inną precyzję operacji na liczbach zmiennoprzecinkowych. Dodatkowo dzięki właśnie EXPECT_NEAR możemy jasno określić tolerancję, czyli już wcześniej wspomniany epsilon.  Logika w Mocku  Wraz z Google Test dostajemy również Google Mock, jest on dodawany jako osobny nagłówek gmock.h. Mock to w tłumaczeniu na polski - makieta. Czyli, w kontekście programowania obiektowego, coś co tylko udaje implementację klasy. Nieraz jednak widziałem, mocki, które przysłaniały tylko część metod, pozostawiając lub nadpisując implementację klasy, z której dziedziczyły.  Możemy podejść do mockowania na przynajmniej dwa sposoby. Pierowysz to bazowanie na interfejsie. Wprowadzamy klasę czysto abstrakcyjną, do której nasza testowana klasa się odwołuje, nie znając prawdziwej wersji implementacji.  Poniżej przykład interfejsu RenderSceneBuilder. Klasa ta ma za zadanie budowanie sceny gry złożonej z obiektów klasy RenderItem (również interfejs) w oparciu o strukturę SceneUdate.  class RenderSceneBuilder { public:     virtual ~RenderSceneBuilder() = default;      virtual auto build(const SceneUpdate&amp; sceneUpdate) -&gt; void = 0;     virtual auto popRenderItems() -&gt; RenderItems = 0; };   A tutaj przykład jego wykorzystania (uproszczony by nie zaciemniać obrazu).  class SfmlWindow { public:     SfmlWindow(         //...         std::unique_ptr&lt;RenderSceneBuilder&gt; inputSceneBuilder = nullptr         //...     );      //...     virtual auto update(const SceneUpdate&amp; sceneUpdate) override -&gt; void;  private:     //...     std::unique_ptr&lt;RenderSceneBuilder&gt; sceneBuilder;     //... };   Teraz utworzymy mocka z interfejsu, MockRenderSceneBuilder.  class MockRenderSceneBuilder : public RenderSceneBuilder { public:     MOCK_METHOD(void, build, (const SceneUpdate&amp;), (override));     MOCK_METHOD(RenderItems, popRenderItems, (), (override)); };   W tym przypadku klasa mocka przysłania tylko interfejs i wszystko mamy czyste. Wstrzykujemy mocka do naszej testowanej klasy poprzez konstruktor i voilà!  Drugi sposób - do destruktora oraz wszystkich publicznych metod klasy, którą chcemy zamockować dodajemy virtual. Dla przykładu mamy klasę GameSession.  class GameSession { public:     explicit GameSession(std::unique_ptr&lt;SceneItemFactory&gt; inputFactory = nullptr);     virtual ~GameSession() = default;      virtual auto addPlayer() -&gt; PlayerID;     virtual auto removePlayer(const PlayerID&amp; playerId) -&gt; void;     virtual auto queuePlayerStatus(const PlayerID&amp; playerId, const PlayerStatus&amp; playerStatus) -&gt; void;     virtual auto updateGameWorld() -&gt; void;     virtual auto getUpdateForPlayer(const PlayerID&amp; playerId) const -&gt; GameplayUpdate;  private:     //... };   I mockujemy.  class MockGameSession : public GameSession { public:     MockGameSession() = default;      MOCK_METHOD(PlayerID, addPlayer, (), (override));     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override));     MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override));     MOCK_METHOD(void, updateGameWorld, (), (override));     MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override)); };    Jeśli pozostawimy część publicznych metod jako niewirtualne i nie przysłonimy ich w mocku to nie odcinamy w pełni zależności między naszą testowaną klasą, a klasą zmockowaną. Taki test de facto nie jest już unit testem lecz czymś w rodzaju karykatury module testu. Poniżej przykład  class MockGameSession : public GameSession { public:     MockGameSession() = default;      MOCK_METHOD(PlayerID, addPlayer, (), (override));     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override));     MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override));     MOCK_METHOD(void, updateGameWorld, (), (override));     GameplayUpdate getUpdateForPlayer(const PlayerID&amp;) const override     {         // Generuje losowe wartości i wypełnia nimi GameplayUpdate     }  };   W przypadku, gdy dopisujemy jakąś część logiki w kodzie mocka ograniczamy widoczność tych operacji w naszych testach. Mock sam z siebie nie powinien nic robić. Służy on do weryfikacji zachowania naszej testowanej klasy, tj. jego interakcji z mockowaną klasą. Jeśli potrzebujemy, by nasz mock reagował na te interakcje Google Mock udostępnia szereg narzędzi jak ON_CALL i EXPECT_CALL z odpowiednią kombinacją na przykład WillOnce i Invoke (są też inne metody na sterowanie zachowaniem mocka). Wtedy wszystko jest zapisane w naszym unit teście, w bloku “Arrange”.  Testowanie Mocka  Jak już wspomniałem mocki służą do weryfikacji interakcji z naszą testowaną klasą. Spotkałem się jednak z innym sposobem wykorzystywania mocków w unit testach. Kiedy nie znamy dobrych podstaw pisania unit testów (o których jeszcze napiszę ;) ), mogą powstać naprawdę dziwne rzeczy.  W unit testach widziałem wiele nietypowych konstrukcji, i w rzeczy samej testowanie mocka jest jedną z nich. Chcąc odciąć jakąś zależność możemy zastosować mocka, aby przysłonić część implementacji lub wręcz zastąpić ją inną. Co de facto mija się z celem testowania.  Dla przykładu, mamy mocka klasy MockGameSession z poprzedniego punktu. Tym razem jak najbardziej poprawnego.  class MockGameSession : public GameSession { public:     MockGameSession() = default;      MOCK_METHOD(PlayerID, addPlayer, ());     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;));     MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;));     MOCK_METHOD(void, updateGameWorld, ());     MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const));     MOCK_METHOD(Texture, getTexture, (const std::string), (const)); // metoda protected w GameSession };   Natomiast w unit testach chcemy przetestować metodę addPlayer klasy GameSession, jednak korzysta ona z metody getTexture odczytującej teksturę gracza z pliku. W takim przypadku moglibyśmy zastosować “Wrapper” lub wprowadzić osobny obiekt klasy Factory i zacmokocwać ją stosująć Dependency Injection. Jednak nie znając jeszcze tych technik możemy pokusić się o użycie mocka w taki sposób, by podczas testowania metody addPlayer przysłonić tylko metodę getTexture, która to odpowiedzialna jest za odczyt pliku.  TEST_F(GameSessionTests, addPlayer_OneNewPlayer_ReturnNewPlayerId) {     auto factory { std::make_unique&lt;MockSceneItemFactory&gt;() };     EXPECT_CALL(*factory, create(_, _, _));     MockGameSession gameSession { std::move(factory) };     EXPECT_CALL(gameSession, getTexture(_)).WillOnce(Return(Texture())); // Mockowanie zależności odczytu z pliku     EXPECT_CALL(gameSession, addPlayer()).WillOnce(Invoke([&amp;](){ // Mockowana metoda wykonuje tą prawdziwą         return gameSession.GameSession::addPlayer();     }));      const auto resultPlayerId { gameSession.addPlayer() }; // Wywołanie mockowanej metody      EXPECT_EQ(0, resultPlayerId); }   Dlaczego uważam to za fatalny pomysł? W końcu działa…  No cóż to tak jakby używać spawarki do wbijania gwoździ, no niby da się tylko po co? Mocki zostały wymyślone po to by odcinać zależności między klasami, a nie do grzebania w implementacji naszej testowanej klasy. Gdy widzę test, w którym nie ma normalnej klasy, tylko same mocki to coś tu jest nie tak.  Taki test jest bardzo nieczytelny. Gdy dodamy do tego enigmatyczną nazwę to praktycznie na pierwszy czy nawet drugi rzut oka, nie jesteśmy w stanie stwierdzić, która klasa jest testowana. W GoogleTest są oczywiście nazwa test suity, która może w tym przypadku podpowiedzieć to i owo, niemniej, czytelność i tak spada diametralnie.  Używajmy narzędzi zgodnie z ich pierwotnym przeznaczeniem, zwłaszcza podczas testowania. Dbamy tym samym o wysoką czytelność i przejrzystość w naszych unit testach.  Brak override w mockach  Słowo kluczowe (a dokładnie specyfikator) override możemy stosować również w mockowanych metodach i działa ono dokładnie tak samo jak w zwykłych klasach. W MOCK_METHOD na końcu, w sekcji gdzie dodajemy kwalifikatory i specyfikatory. Dla przykładu, wróćmy do MockGameSession.  class MockGameSession : public GameSession { public:     MockGameSession() = default;      MOCK_METHOD(PlayerID, addPlayer, ());     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;));     MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;));     MOCK_METHOD(void, updateGameWorld, ());     MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const)); };   Jeśli w takim przypadku metoda removePlayer w klasie GameSession nie będzie wirtualna, kompilator i tak nie zwróci błędu. Kod skompiluje się, a my będziemy zachodzić w głowę czemu nasz mock nie jest wywoływany.  Użycie override eliminuje problem. W przypadku, gdy dodamy ten specyfikator, a metoda w klasie bazowej nie będzie wirtualna, kompilator zwróci błąd. Tak jak na poniższym przykładzie.  Tutaj już poprawiony mock.  class MockGameSession : public GameSession { public:     MockGameSession() = default;      MOCK_METHOD(PlayerID, addPlayer, (), (override));     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override));     MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override));     MOCK_METHOD(void, updateGameWorld, (), (override));     MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override)); };   Oraz błąd zwracany przez kompilator.  /.../MockGameSession.hpp:16:23: error: &#39;testing::internal::Function&lt;void(const int&amp;)&gt;::Result MockGameSession::removePlayer(testing::internal::ElemFromList&lt;0, const int&amp;&gt;::type)&#39; marked &#39;override&#39;, but does not override    16 |     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override));       |    Podsumowanie  To już wszystko w tym wpisie. Mam nadzieję, że będzie dla Ciebie choć trochę pomocny w zmaganiach z Google Test’em. Czy któryś z wymienionych w tym wpisie błędów Cię zaskoczył? Może inny jest dość znajomy? Daj znać w komentarzu! Popełnianie błędów jest czymś normalnym. Ważne by się rozwijać i uczyć od siebie nawzajem. Jeśli znasz inne przypadki, chętnie się z nimi zapoznam. Możesz również napisać do mnie email lub wysłać wiadomość na LinkedIn. Będzie mi bardzo miło :)  Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów  LinkedIn">



<meta property="og:type" content="article">
<meta property="og:locale" content="pl">
<meta property="og:site_name" content="CppTested">
<meta property="og:title" content="6 najczęstszych błędów z Google Test.">
<meta property="og:url" content="https://cpptested.com/clean%20code/gtest-mistakes/">


  <meta property="og:description" content="Google Test to chyba najbardziej znany i używany framework testowy w projektach C++. Zawiera w sobie masę przydatnych narzędzi do tworzenia różnych rodzajów testów. Ja osobiście stosuję go w swoich projektach pisząc unit testy, ale nic nie stoi na przeszkodzie by tworzyć testy modułowe czy komponentowe (typu black box). Ceniony za swą uniwersalność oraz rozbudowany system asercji jest narzędziem bardzo potężnym. Mimo to nie jest również bez wad. Im bardziej złożone jest narzędzie tym trudniej się go nauczyć i korzystać z niego poprawnie.  Popełniamy błędy. To normalne, ważne jest co z tym zrobimy. Warto wyciągnąć z nich lekcje na przyszłość. Poniższa lista to nic innego jak moje własne obserwacje, jak programiści C++(w tym ja) wykorzystują GTest i gdzie najczęściej popełniają błędy.  Kolejność parametrów asercji  Czy kolejność w asercji typu EXPECT_EQ jest ważna? Owszem! Choć nie wynika ona z samej definicji makra w nagłówku gtest.h. Wspomniana definicja wygląda następująco.  #define EXPECT_EQ(val1, val2) \   EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)   Sam Google Test nie informuje gdzie ma być umieszczona wartość oczekiwania, a gdzie wynikowa. Skąd więc założenie, że wartość expected powinna być pierwsza? Głównie z przykładów z repozytorium Google Test.  Przykład z folderu samples repozytorium Google Test, a dokładnie ten “sample4_unittest”.  TEST(Counter, Increment) {   Counter c;    // Test that counter 0 returns 0   EXPECT_EQ(0, c.Decrement());    // EXPECT_EQ() evaluates its arguments exactly once, so they   // can have side effects.    EXPECT_EQ(0, c.Increment());   EXPECT_EQ(1, c.Increment());   EXPECT_EQ(2, c.Increment());    EXPECT_EQ(3, c.Decrement()); }   Oczywiście jest ich znacznie więcej.  Są dwa powody dlaczego warto najpierw podawać wartość oczekiwaną, a potem wynikową.     Czytelność - przeglądając test, czytamy linijkę od lewej do prawej. Gdy wartością oczekiwaną jest po prostu stałą liczbową lub tekstową, szybciej dowiemy się co jest oczekiwane względem testowanej metody.   Spójność z warunkami w kodzie - znasz ten ból, gdy w if zamiast użyć operatora porównania ==, użyłeś operator przypisania =? Ja tak, dlatego warto najpierw wartość oczekiwaną podawać jako pierwszą. Jeśli jest to stała, kompilator szybko poinformuje nas o pomyłce.    if(i = 5) // Kompilator nie zgłosi błędu  if(5 = i) // a tutaj już tak    Logika jest zachowana ale zwiększa się odporność na błędy.  To która wersja będzie poprawna?  EXPECT_EQ(resultValue, expectedValue); // Ta? EXPECT_EQ(expectedValue, resultValue); // czy ta?   Tak naprawdę - to zależy. Choć sama kolejność jest sugerowana przykładami, nie jest ona napisana wprost. Którą więc wybrać? Jeśli wchodzisz do projektu, gdzie pierwsza wartość to ta wynikowa. Dostosuj się do konwencji już panującej w projekcie. Jeśli to nowy projekt, lub brak jest spójnej konwencji, wybierz wersję, gdzie wartość oczekiwana podawana jest jako pierwsza.  Używanie EXPECT zamiast ASSERT  Ten błąd może kosztować życie (naszego wątku uruchamiającego testy). Dlaczego? Najpierw omówmy różnicę w zachowaniu EXPECT_EQ i ASSERT_EQ (lub dowolnej innej pary tych typów asercji). Obie asercje mają za zadanie sprawdzać czy dana wartość zgadza się z oczekiwaną. Różnica polega na tym co wydarzy się w przypadku niepowodzenia asercji. EXPECT spowoduje, że test nie zostanie zaliczony, wypisze komunikat i przejdzie do następnej linii testu.  TEST_F(WidgetFactoryTests, create_ButtonWidgetType_ReturnButtonWidget) {     const Rect expectedRect { 300, 400, 120, 30 };     const std::string expectedText { &quot;Test Button&quot; };     WidgetFactory factory {};      const auto resultWidget { factory.create(WidgetType::BUTTON, expectedRect, expectedText)};      EXPECT_EQ(WidgetType::LABEL, resultWidget.getType()); // Ta asercja się nie powiedzie     EXPECT_EQ(expectedRect, resultWidget.getRect()); // Ta i następna zostaną wywołane     EXPECT_EQ(expectedText, resultWidget.getText()); }   ASSERT również spowoduje fail testu, wypisze komunikat, ale już nie przejdzie dalej do kolejnej części testu. Test zostaje przerwany w tym miejscu i dalej nie będzie kontynuowany.  TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget) {     const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() };     EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow()));     EXPECT_CALL(*sfmlWindow, add(_));     WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr };      const auto resultWidget {         factory.create(             WidgetType::LABEL,             WidgetGeometry {},             WidgetText {},             WidgetStyle {}         )     }; // Jeśli ta metoda zwróci nullptr      ASSERT_TRUE(resultWidget != nullptr); // to ta asercja się nie powiedzie i test przerywa wykonywanie.     EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType()); // Ta i następna asercja nie zostaną wywołane     EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr); }   Co nam to daje? Bardzo wiele, zwłaszcza gdy kolejne asercje opierają się na naszym ASSERT. Jeśli zastosujemy zwykły EXPECT to test zakończy swoje działanie poprzez brutalne przerwanie w stylu segfaulta.  TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget) {     const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() };     EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow()));     EXPECT_CALL(*sfmlWindow, add(_));     WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr };      const auto resultWidget {         factory.create(             WidgetType::LABEL,             WidgetGeometry {},             WidgetText {},             WidgetStyle {}         )     };       EXPECT_TRUE(resultWidget != nullptr); // zamiast ASSERT jest EXPECT     EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType());     EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr); }   Test nie przejdzie, na dodatek, jeśli w naszej suicie będzie więcej testów i miały być one uruchomione po tym, to do tego nie dojdzie. Cały wątek z naszą suitą zostanie przerwany. Czyli inne testy nawet się nie wykonają.  [ RUN      ] WidgetsFactorySfmlTests.create_LabelType_CreateLabelWidget Setting vertical sync not supported /usr/src/heisttown/src/Sfml/SfmlWidgets/Tests/WidgetsFactorySfmlTests.cpp:42: Failure Value of: resultWidget != nullptr   Actual: false Expected: true   W tym przypadku mamy chociaż informacje co poszło nie tak. Jeśli nie dodalibyśmy, w ogóle asercji na sprawdzanie czy resultWidget nie jest nullptr, nie wiedzielibyśmy nic. Dlatego ważne jest, aby stosować ASSERT czy EXPECT zgodnie z ich przeznaczeniem.  Dlaczego więc nie stosować ASSERT zawsze? Jak już pisałem, ASSERT zatrzymuje test, dalsza jego część nie jest weryfikowana. Jeśli następne asercje nie są zależne od poprzednich to, w takim przypadku zostaną pominięte i nie będziemy wiedzieli, czy tylko ta jedna asercja nie została spełniona, czy cały ich szereg. Obraz sytuacji będzie niekompletny.  Jeśli oczekiwanym wynikiem może być kontener to sprawdź jego rozmiar ASSERTem zanim zaczniesz weryfikować jego konkretne elementy. Albo, gdy wynikiem będzie wskaźnik, sprawdź czy nie jest on nullptr zanim zaczniesz odwoływać się do obiektu pod nim. To tylko najczęściej powtarzające się sytuacje, gdzie należy stosować ASSERT. Z pewnością jest ich więcej.  Porównywanie float’ów bez precyzji  Reprezentacja liczb zmiennoprzecinkowych przez komputer nie jest doskonała i wie to każdy doświadczony programista. Porównywanie wartości typu float czy double ze sobą nie jest takie proste jak liczb całkowitych. Weryfikacja testu odbywa się właśnie przez porównanie, a wyniki zapisane w liczbach zmiennoprzecinkowych mogą się nieznacznie różnić od tych oczekiwanych.  Dlaczego tak się dzieje?  Spora część liczb zmiennoprzecinkowych nie ma idealnej reprezentacji w systemie binarnym. Dlatego komputer musi zaokrąglać wyliczoną wartość do najbliższej zero-jedynkowej wartości. Jest nawet na to określony standard “IEEE 754”. Właśnie ze względu na te zaokrąglenia, porównywanie wartości zmiennoprzecinkowych, może dać fałszywe wyniki. Dlatego stosuje się porównywanie z tolerancją, tak zwany epsilon.  To mi przypomina moje początki nauki pisania unit testów i pracy z Google Test. Tak, mniej więcej, wyglądał jeden z moich pierwszych unit testów w zakresie weryfikacji wyniku zapisanego właśnie w double.  TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr) {     const std::complex&lt;double&gt; sample { 1.0, 0.0 };     const double noise { 0.394 };        const auto resultLlr { llr16QamIMsb(sample, noise) };      EXPECT_EQ(5.0761421319796952, resultLlr); }   Teraz, gdy o tym myślę, chce mi się śmiać, ale kto nie popełnia błędów? Ten kto nic nie robi ;) Dziś sobie z przed lat powiedziałbym co trzeba zrobić w takim przypadku, poprawilibyśmy ten test i wyglądałby następująco.  TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr) {     const std::complex&lt;double&gt; sample { 1.0, 0.0 };     const double noise { 0.394 };        const auto resultLlr { llr16QamIMsb(sample, noise) };      EXPECT_NEAR(5.07614, resultLlr, 0.00001); }   Zmieniła się tylko sama asercja i z pewnością test stał się niewrażliwy na zmianę platformy, która ma inną precyzję operacji na liczbach zmiennoprzecinkowych. Dodatkowo dzięki właśnie EXPECT_NEAR możemy jasno określić tolerancję, czyli już wcześniej wspomniany epsilon.  Logika w Mocku  Wraz z Google Test dostajemy również Google Mock, jest on dodawany jako osobny nagłówek gmock.h. Mock to w tłumaczeniu na polski - makieta. Czyli, w kontekście programowania obiektowego, coś co tylko udaje implementację klasy. Nieraz jednak widziałem, mocki, które przysłaniały tylko część metod, pozostawiając lub nadpisując implementację klasy, z której dziedziczyły.  Możemy podejść do mockowania na przynajmniej dwa sposoby. Pierowysz to bazowanie na interfejsie. Wprowadzamy klasę czysto abstrakcyjną, do której nasza testowana klasa się odwołuje, nie znając prawdziwej wersji implementacji.  Poniżej przykład interfejsu RenderSceneBuilder. Klasa ta ma za zadanie budowanie sceny gry złożonej z obiektów klasy RenderItem (również interfejs) w oparciu o strukturę SceneUdate.  class RenderSceneBuilder { public:     virtual ~RenderSceneBuilder() = default;      virtual auto build(const SceneUpdate&amp; sceneUpdate) -&gt; void = 0;     virtual auto popRenderItems() -&gt; RenderItems = 0; };   A tutaj przykład jego wykorzystania (uproszczony by nie zaciemniać obrazu).  class SfmlWindow { public:     SfmlWindow(         //...         std::unique_ptr&lt;RenderSceneBuilder&gt; inputSceneBuilder = nullptr         //...     );      //...     virtual auto update(const SceneUpdate&amp; sceneUpdate) override -&gt; void;  private:     //...     std::unique_ptr&lt;RenderSceneBuilder&gt; sceneBuilder;     //... };   Teraz utworzymy mocka z interfejsu, MockRenderSceneBuilder.  class MockRenderSceneBuilder : public RenderSceneBuilder { public:     MOCK_METHOD(void, build, (const SceneUpdate&amp;), (override));     MOCK_METHOD(RenderItems, popRenderItems, (), (override)); };   W tym przypadku klasa mocka przysłania tylko interfejs i wszystko mamy czyste. Wstrzykujemy mocka do naszej testowanej klasy poprzez konstruktor i voilà!  Drugi sposób - do destruktora oraz wszystkich publicznych metod klasy, którą chcemy zamockować dodajemy virtual. Dla przykładu mamy klasę GameSession.  class GameSession { public:     explicit GameSession(std::unique_ptr&lt;SceneItemFactory&gt; inputFactory = nullptr);     virtual ~GameSession() = default;      virtual auto addPlayer() -&gt; PlayerID;     virtual auto removePlayer(const PlayerID&amp; playerId) -&gt; void;     virtual auto queuePlayerStatus(const PlayerID&amp; playerId, const PlayerStatus&amp; playerStatus) -&gt; void;     virtual auto updateGameWorld() -&gt; void;     virtual auto getUpdateForPlayer(const PlayerID&amp; playerId) const -&gt; GameplayUpdate;  private:     //... };   I mockujemy.  class MockGameSession : public GameSession { public:     MockGameSession() = default;      MOCK_METHOD(PlayerID, addPlayer, (), (override));     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override));     MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override));     MOCK_METHOD(void, updateGameWorld, (), (override));     MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override)); };    Jeśli pozostawimy część publicznych metod jako niewirtualne i nie przysłonimy ich w mocku to nie odcinamy w pełni zależności między naszą testowaną klasą, a klasą zmockowaną. Taki test de facto nie jest już unit testem lecz czymś w rodzaju karykatury module testu. Poniżej przykład  class MockGameSession : public GameSession { public:     MockGameSession() = default;      MOCK_METHOD(PlayerID, addPlayer, (), (override));     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override));     MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override));     MOCK_METHOD(void, updateGameWorld, (), (override));     GameplayUpdate getUpdateForPlayer(const PlayerID&amp;) const override     {         // Generuje losowe wartości i wypełnia nimi GameplayUpdate     }  };   W przypadku, gdy dopisujemy jakąś część logiki w kodzie mocka ograniczamy widoczność tych operacji w naszych testach. Mock sam z siebie nie powinien nic robić. Służy on do weryfikacji zachowania naszej testowanej klasy, tj. jego interakcji z mockowaną klasą. Jeśli potrzebujemy, by nasz mock reagował na te interakcje Google Mock udostępnia szereg narzędzi jak ON_CALL i EXPECT_CALL z odpowiednią kombinacją na przykład WillOnce i Invoke (są też inne metody na sterowanie zachowaniem mocka). Wtedy wszystko jest zapisane w naszym unit teście, w bloku “Arrange”.  Testowanie Mocka  Jak już wspomniałem mocki służą do weryfikacji interakcji z naszą testowaną klasą. Spotkałem się jednak z innym sposobem wykorzystywania mocków w unit testach. Kiedy nie znamy dobrych podstaw pisania unit testów (o których jeszcze napiszę ;) ), mogą powstać naprawdę dziwne rzeczy.  W unit testach widziałem wiele nietypowych konstrukcji, i w rzeczy samej testowanie mocka jest jedną z nich. Chcąc odciąć jakąś zależność możemy zastosować mocka, aby przysłonić część implementacji lub wręcz zastąpić ją inną. Co de facto mija się z celem testowania.  Dla przykładu, mamy mocka klasy MockGameSession z poprzedniego punktu. Tym razem jak najbardziej poprawnego.  class MockGameSession : public GameSession { public:     MockGameSession() = default;      MOCK_METHOD(PlayerID, addPlayer, ());     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;));     MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;));     MOCK_METHOD(void, updateGameWorld, ());     MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const));     MOCK_METHOD(Texture, getTexture, (const std::string), (const)); // metoda protected w GameSession };   Natomiast w unit testach chcemy przetestować metodę addPlayer klasy GameSession, jednak korzysta ona z metody getTexture odczytującej teksturę gracza z pliku. W takim przypadku moglibyśmy zastosować “Wrapper” lub wprowadzić osobny obiekt klasy Factory i zacmokocwać ją stosująć Dependency Injection. Jednak nie znając jeszcze tych technik możemy pokusić się o użycie mocka w taki sposób, by podczas testowania metody addPlayer przysłonić tylko metodę getTexture, która to odpowiedzialna jest za odczyt pliku.  TEST_F(GameSessionTests, addPlayer_OneNewPlayer_ReturnNewPlayerId) {     auto factory { std::make_unique&lt;MockSceneItemFactory&gt;() };     EXPECT_CALL(*factory, create(_, _, _));     MockGameSession gameSession { std::move(factory) };     EXPECT_CALL(gameSession, getTexture(_)).WillOnce(Return(Texture())); // Mockowanie zależności odczytu z pliku     EXPECT_CALL(gameSession, addPlayer()).WillOnce(Invoke([&amp;](){ // Mockowana metoda wykonuje tą prawdziwą         return gameSession.GameSession::addPlayer();     }));      const auto resultPlayerId { gameSession.addPlayer() }; // Wywołanie mockowanej metody      EXPECT_EQ(0, resultPlayerId); }   Dlaczego uważam to za fatalny pomysł? W końcu działa…  No cóż to tak jakby używać spawarki do wbijania gwoździ, no niby da się tylko po co? Mocki zostały wymyślone po to by odcinać zależności między klasami, a nie do grzebania w implementacji naszej testowanej klasy. Gdy widzę test, w którym nie ma normalnej klasy, tylko same mocki to coś tu jest nie tak.  Taki test jest bardzo nieczytelny. Gdy dodamy do tego enigmatyczną nazwę to praktycznie na pierwszy czy nawet drugi rzut oka, nie jesteśmy w stanie stwierdzić, która klasa jest testowana. W GoogleTest są oczywiście nazwa test suity, która może w tym przypadku podpowiedzieć to i owo, niemniej, czytelność i tak spada diametralnie.  Używajmy narzędzi zgodnie z ich pierwotnym przeznaczeniem, zwłaszcza podczas testowania. Dbamy tym samym o wysoką czytelność i przejrzystość w naszych unit testach.  Brak override w mockach  Słowo kluczowe (a dokładnie specyfikator) override możemy stosować również w mockowanych metodach i działa ono dokładnie tak samo jak w zwykłych klasach. W MOCK_METHOD na końcu, w sekcji gdzie dodajemy kwalifikatory i specyfikatory. Dla przykładu, wróćmy do MockGameSession.  class MockGameSession : public GameSession { public:     MockGameSession() = default;      MOCK_METHOD(PlayerID, addPlayer, ());     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;));     MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;));     MOCK_METHOD(void, updateGameWorld, ());     MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const)); };   Jeśli w takim przypadku metoda removePlayer w klasie GameSession nie będzie wirtualna, kompilator i tak nie zwróci błędu. Kod skompiluje się, a my będziemy zachodzić w głowę czemu nasz mock nie jest wywoływany.  Użycie override eliminuje problem. W przypadku, gdy dodamy ten specyfikator, a metoda w klasie bazowej nie będzie wirtualna, kompilator zwróci błąd. Tak jak na poniższym przykładzie.  Tutaj już poprawiony mock.  class MockGameSession : public GameSession { public:     MockGameSession() = default;      MOCK_METHOD(PlayerID, addPlayer, (), (override));     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override));     MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override));     MOCK_METHOD(void, updateGameWorld, (), (override));     MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override)); };   Oraz błąd zwracany przez kompilator.  /.../MockGameSession.hpp:16:23: error: &#39;testing::internal::Function&lt;void(const int&amp;)&gt;::Result MockGameSession::removePlayer(testing::internal::ElemFromList&lt;0, const int&amp;&gt;::type)&#39; marked &#39;override&#39;, but does not override    16 |     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override));       |    Podsumowanie  To już wszystko w tym wpisie. Mam nadzieję, że będzie dla Ciebie choć trochę pomocny w zmaganiach z Google Test’em. Czy któryś z wymienionych w tym wpisie błędów Cię zaskoczył? Może inny jest dość znajomy? Daj znać w komentarzu! Popełnianie błędów jest czymś normalnym. Ważne by się rozwijać i uczyć od siebie nawzajem. Jeśli znasz inne przypadki, chętnie się z nimi zapoznam. Możesz również napisać do mnie email lub wysłać wiadomość na LinkedIn. Będzie mi bardzo miło :)  Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów  LinkedIn">







  <meta property="article:published_time" content="2026-01-26T00:00:00+01:00">






<link rel="canonical" href="https://cpptested.com/clean%20code/gtest-mistakes/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="CppTested Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<script type="text/javascript" charset="UTF-8" src="//cdn.cookie-script.com/s/e646ffbf6c153feb4a722a4017c1873b.js"></script>

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>6 najczęstszych błędów z Google Test. | CppTested</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="6 najczęstszych błędów z Google Test." />
<meta name="author" content="Tadeusz Biela" />
<meta property="og:locale" content="pl" />
<meta name="description" content="Google Test to chyba najbardziej znany i używany framework testowy w projektach C++. Zawiera w sobie masę przydatnych narzędzi do tworzenia różnych rodzajów testów. Ja osobiście stosuję go w swoich projektach pisząc unit testy, ale nic nie stoi na przeszkodzie by tworzyć testy modułowe czy komponentowe (typu black box). Ceniony za swą uniwersalność oraz rozbudowany system asercji jest narzędziem bardzo potężnym. Mimo to nie jest również bez wad. Im bardziej złożone jest narzędzie tym trudniej się go nauczyć i korzystać z niego poprawnie. Popełniamy błędy. To normalne, ważne jest co z tym zrobimy. Warto wyciągnąć z nich lekcje na przyszłość. Poniższa lista to nic innego jak moje własne obserwacje, jak programiści C++(w tym ja) wykorzystują GTest i gdzie najczęściej popełniają błędy. Kolejność parametrów asercji Czy kolejność w asercji typu EXPECT_EQ jest ważna? Owszem! Choć nie wynika ona z samej definicji makra w nagłówku gtest.h. Wspomniana definicja wygląda następująco. #define EXPECT_EQ(val1, val2) \ EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2) Sam Google Test nie informuje gdzie ma być umieszczona wartość oczekiwania, a gdzie wynikowa. Skąd więc założenie, że wartość expected powinna być pierwsza? Głównie z przykładów z repozytorium Google Test. Przykład z folderu samples repozytorium Google Test, a dokładnie ten “sample4_unittest”. TEST(Counter, Increment) { Counter c; // Test that counter 0 returns 0 EXPECT_EQ(0, c.Decrement()); // EXPECT_EQ() evaluates its arguments exactly once, so they // can have side effects. EXPECT_EQ(0, c.Increment()); EXPECT_EQ(1, c.Increment()); EXPECT_EQ(2, c.Increment()); EXPECT_EQ(3, c.Decrement()); } Oczywiście jest ich znacznie więcej. Są dwa powody dlaczego warto najpierw podawać wartość oczekiwaną, a potem wynikową. Czytelność - przeglądając test, czytamy linijkę od lewej do prawej. Gdy wartością oczekiwaną jest po prostu stałą liczbową lub tekstową, szybciej dowiemy się co jest oczekiwane względem testowanej metody. Spójność z warunkami w kodzie - znasz ten ból, gdy w if zamiast użyć operatora porównania ==, użyłeś operator przypisania =? Ja tak, dlatego warto najpierw wartość oczekiwaną podawać jako pierwszą. Jeśli jest to stała, kompilator szybko poinformuje nas o pomyłce. if(i = 5) // Kompilator nie zgłosi błędu if(5 = i) // a tutaj już tak Logika jest zachowana ale zwiększa się odporność na błędy. To która wersja będzie poprawna? EXPECT_EQ(resultValue, expectedValue); // Ta? EXPECT_EQ(expectedValue, resultValue); // czy ta? Tak naprawdę - to zależy. Choć sama kolejność jest sugerowana przykładami, nie jest ona napisana wprost. Którą więc wybrać? Jeśli wchodzisz do projektu, gdzie pierwsza wartość to ta wynikowa. Dostosuj się do konwencji już panującej w projekcie. Jeśli to nowy projekt, lub brak jest spójnej konwencji, wybierz wersję, gdzie wartość oczekiwana podawana jest jako pierwsza. Używanie EXPECT zamiast ASSERT Ten błąd może kosztować życie (naszego wątku uruchamiającego testy). Dlaczego? Najpierw omówmy różnicę w zachowaniu EXPECT_EQ i ASSERT_EQ (lub dowolnej innej pary tych typów asercji). Obie asercje mają za zadanie sprawdzać czy dana wartość zgadza się z oczekiwaną. Różnica polega na tym co wydarzy się w przypadku niepowodzenia asercji. EXPECT spowoduje, że test nie zostanie zaliczony, wypisze komunikat i przejdzie do następnej linii testu. TEST_F(WidgetFactoryTests, create_ButtonWidgetType_ReturnButtonWidget) { const Rect expectedRect { 300, 400, 120, 30 }; const std::string expectedText { &quot;Test Button&quot; }; WidgetFactory factory {}; const auto resultWidget { factory.create(WidgetType::BUTTON, expectedRect, expectedText)}; EXPECT_EQ(WidgetType::LABEL, resultWidget.getType()); // Ta asercja się nie powiedzie EXPECT_EQ(expectedRect, resultWidget.getRect()); // Ta i następna zostaną wywołane EXPECT_EQ(expectedText, resultWidget.getText()); } ASSERT również spowoduje fail testu, wypisze komunikat, ale już nie przejdzie dalej do kolejnej części testu. Test zostaje przerwany w tym miejscu i dalej nie będzie kontynuowany. TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget) { const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() }; EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow())); EXPECT_CALL(*sfmlWindow, add(_)); WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr }; const auto resultWidget { factory.create( WidgetType::LABEL, WidgetGeometry {}, WidgetText {}, WidgetStyle {} ) }; // Jeśli ta metoda zwróci nullptr ASSERT_TRUE(resultWidget != nullptr); // to ta asercja się nie powiedzie i test przerywa wykonywanie. EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType()); // Ta i następna asercja nie zostaną wywołane EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr); } Co nam to daje? Bardzo wiele, zwłaszcza gdy kolejne asercje opierają się na naszym ASSERT. Jeśli zastosujemy zwykły EXPECT to test zakończy swoje działanie poprzez brutalne przerwanie w stylu segfaulta. TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget) { const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() }; EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow())); EXPECT_CALL(*sfmlWindow, add(_)); WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr }; const auto resultWidget { factory.create( WidgetType::LABEL, WidgetGeometry {}, WidgetText {}, WidgetStyle {} ) }; EXPECT_TRUE(resultWidget != nullptr); // zamiast ASSERT jest EXPECT EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType()); EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr); } Test nie przejdzie, na dodatek, jeśli w naszej suicie będzie więcej testów i miały być one uruchomione po tym, to do tego nie dojdzie. Cały wątek z naszą suitą zostanie przerwany. Czyli inne testy nawet się nie wykonają. [ RUN ] WidgetsFactorySfmlTests.create_LabelType_CreateLabelWidget Setting vertical sync not supported /usr/src/heisttown/src/Sfml/SfmlWidgets/Tests/WidgetsFactorySfmlTests.cpp:42: Failure Value of: resultWidget != nullptr Actual: false Expected: true W tym przypadku mamy chociaż informacje co poszło nie tak. Jeśli nie dodalibyśmy, w ogóle asercji na sprawdzanie czy resultWidget nie jest nullptr, nie wiedzielibyśmy nic. Dlatego ważne jest, aby stosować ASSERT czy EXPECT zgodnie z ich przeznaczeniem. Dlaczego więc nie stosować ASSERT zawsze? Jak już pisałem, ASSERT zatrzymuje test, dalsza jego część nie jest weryfikowana. Jeśli następne asercje nie są zależne od poprzednich to, w takim przypadku zostaną pominięte i nie będziemy wiedzieli, czy tylko ta jedna asercja nie została spełniona, czy cały ich szereg. Obraz sytuacji będzie niekompletny. Jeśli oczekiwanym wynikiem może być kontener to sprawdź jego rozmiar ASSERTem zanim zaczniesz weryfikować jego konkretne elementy. Albo, gdy wynikiem będzie wskaźnik, sprawdź czy nie jest on nullptr zanim zaczniesz odwoływać się do obiektu pod nim. To tylko najczęściej powtarzające się sytuacje, gdzie należy stosować ASSERT. Z pewnością jest ich więcej. Porównywanie float’ów bez precyzji Reprezentacja liczb zmiennoprzecinkowych przez komputer nie jest doskonała i wie to każdy doświadczony programista. Porównywanie wartości typu float czy double ze sobą nie jest takie proste jak liczb całkowitych. Weryfikacja testu odbywa się właśnie przez porównanie, a wyniki zapisane w liczbach zmiennoprzecinkowych mogą się nieznacznie różnić od tych oczekiwanych. Dlaczego tak się dzieje? Spora część liczb zmiennoprzecinkowych nie ma idealnej reprezentacji w systemie binarnym. Dlatego komputer musi zaokrąglać wyliczoną wartość do najbliższej zero-jedynkowej wartości. Jest nawet na to określony standard “IEEE 754”. Właśnie ze względu na te zaokrąglenia, porównywanie wartości zmiennoprzecinkowych, może dać fałszywe wyniki. Dlatego stosuje się porównywanie z tolerancją, tak zwany epsilon. To mi przypomina moje początki nauki pisania unit testów i pracy z Google Test. Tak, mniej więcej, wyglądał jeden z moich pierwszych unit testów w zakresie weryfikacji wyniku zapisanego właśnie w double. TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr) { const std::complex&lt;double&gt; sample { 1.0, 0.0 }; const double noise { 0.394 }; const auto resultLlr { llr16QamIMsb(sample, noise) }; EXPECT_EQ(5.0761421319796952, resultLlr); } Teraz, gdy o tym myślę, chce mi się śmiać, ale kto nie popełnia błędów? Ten kto nic nie robi ;) Dziś sobie z przed lat powiedziałbym co trzeba zrobić w takim przypadku, poprawilibyśmy ten test i wyglądałby następująco. TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr) { const std::complex&lt;double&gt; sample { 1.0, 0.0 }; const double noise { 0.394 }; const auto resultLlr { llr16QamIMsb(sample, noise) }; EXPECT_NEAR(5.07614, resultLlr, 0.00001); } Zmieniła się tylko sama asercja i z pewnością test stał się niewrażliwy na zmianę platformy, która ma inną precyzję operacji na liczbach zmiennoprzecinkowych. Dodatkowo dzięki właśnie EXPECT_NEAR możemy jasno określić tolerancję, czyli już wcześniej wspomniany epsilon. Logika w Mocku Wraz z Google Test dostajemy również Google Mock, jest on dodawany jako osobny nagłówek gmock.h. Mock to w tłumaczeniu na polski - makieta. Czyli, w kontekście programowania obiektowego, coś co tylko udaje implementację klasy. Nieraz jednak widziałem, mocki, które przysłaniały tylko część metod, pozostawiając lub nadpisując implementację klasy, z której dziedziczyły. Możemy podejść do mockowania na przynajmniej dwa sposoby. Pierowysz to bazowanie na interfejsie. Wprowadzamy klasę czysto abstrakcyjną, do której nasza testowana klasa się odwołuje, nie znając prawdziwej wersji implementacji. Poniżej przykład interfejsu RenderSceneBuilder. Klasa ta ma za zadanie budowanie sceny gry złożonej z obiektów klasy RenderItem (również interfejs) w oparciu o strukturę SceneUdate. class RenderSceneBuilder { public: virtual ~RenderSceneBuilder() = default; virtual auto build(const SceneUpdate&amp; sceneUpdate) -&gt; void = 0; virtual auto popRenderItems() -&gt; RenderItems = 0; }; A tutaj przykład jego wykorzystania (uproszczony by nie zaciemniać obrazu). class SfmlWindow { public: SfmlWindow( //... std::unique_ptr&lt;RenderSceneBuilder&gt; inputSceneBuilder = nullptr //... ); //... virtual auto update(const SceneUpdate&amp; sceneUpdate) override -&gt; void; private: //... std::unique_ptr&lt;RenderSceneBuilder&gt; sceneBuilder; //... }; Teraz utworzymy mocka z interfejsu, MockRenderSceneBuilder. class MockRenderSceneBuilder : public RenderSceneBuilder { public: MOCK_METHOD(void, build, (const SceneUpdate&amp;), (override)); MOCK_METHOD(RenderItems, popRenderItems, (), (override)); }; W tym przypadku klasa mocka przysłania tylko interfejs i wszystko mamy czyste. Wstrzykujemy mocka do naszej testowanej klasy poprzez konstruktor i voilà! Drugi sposób - do destruktora oraz wszystkich publicznych metod klasy, którą chcemy zamockować dodajemy virtual. Dla przykładu mamy klasę GameSession. class GameSession { public: explicit GameSession(std::unique_ptr&lt;SceneItemFactory&gt; inputFactory = nullptr); virtual ~GameSession() = default; virtual auto addPlayer() -&gt; PlayerID; virtual auto removePlayer(const PlayerID&amp; playerId) -&gt; void; virtual auto queuePlayerStatus(const PlayerID&amp; playerId, const PlayerStatus&amp; playerStatus) -&gt; void; virtual auto updateGameWorld() -&gt; void; virtual auto getUpdateForPlayer(const PlayerID&amp; playerId) const -&gt; GameplayUpdate; private: //... }; I mockujemy. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, (), (override)); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override)); MOCK_METHOD(void, updateGameWorld, (), (override)); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override)); }; Jeśli pozostawimy część publicznych metod jako niewirtualne i nie przysłonimy ich w mocku to nie odcinamy w pełni zależności między naszą testowaną klasą, a klasą zmockowaną. Taki test de facto nie jest już unit testem lecz czymś w rodzaju karykatury module testu. Poniżej przykład class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, (), (override)); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override)); MOCK_METHOD(void, updateGameWorld, (), (override)); GameplayUpdate getUpdateForPlayer(const PlayerID&amp;) const override { // Generuje losowe wartości i wypełnia nimi GameplayUpdate } }; W przypadku, gdy dopisujemy jakąś część logiki w kodzie mocka ograniczamy widoczność tych operacji w naszych testach. Mock sam z siebie nie powinien nic robić. Służy on do weryfikacji zachowania naszej testowanej klasy, tj. jego interakcji z mockowaną klasą. Jeśli potrzebujemy, by nasz mock reagował na te interakcje Google Mock udostępnia szereg narzędzi jak ON_CALL i EXPECT_CALL z odpowiednią kombinacją na przykład WillOnce i Invoke (są też inne metody na sterowanie zachowaniem mocka). Wtedy wszystko jest zapisane w naszym unit teście, w bloku “Arrange”. Testowanie Mocka Jak już wspomniałem mocki służą do weryfikacji interakcji z naszą testowaną klasą. Spotkałem się jednak z innym sposobem wykorzystywania mocków w unit testach. Kiedy nie znamy dobrych podstaw pisania unit testów (o których jeszcze napiszę ;) ), mogą powstać naprawdę dziwne rzeczy. W unit testach widziałem wiele nietypowych konstrukcji, i w rzeczy samej testowanie mocka jest jedną z nich. Chcąc odciąć jakąś zależność możemy zastosować mocka, aby przysłonić część implementacji lub wręcz zastąpić ją inną. Co de facto mija się z celem testowania. Dla przykładu, mamy mocka klasy MockGameSession z poprzedniego punktu. Tym razem jak najbardziej poprawnego. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, ()); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;)); MOCK_METHOD(void, updateGameWorld, ()); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const)); MOCK_METHOD(Texture, getTexture, (const std::string), (const)); // metoda protected w GameSession }; Natomiast w unit testach chcemy przetestować metodę addPlayer klasy GameSession, jednak korzysta ona z metody getTexture odczytującej teksturę gracza z pliku. W takim przypadku moglibyśmy zastosować “Wrapper” lub wprowadzić osobny obiekt klasy Factory i zacmokocwać ją stosująć Dependency Injection. Jednak nie znając jeszcze tych technik możemy pokusić się o użycie mocka w taki sposób, by podczas testowania metody addPlayer przysłonić tylko metodę getTexture, która to odpowiedzialna jest za odczyt pliku. TEST_F(GameSessionTests, addPlayer_OneNewPlayer_ReturnNewPlayerId) { auto factory { std::make_unique&lt;MockSceneItemFactory&gt;() }; EXPECT_CALL(*factory, create(_, _, _)); MockGameSession gameSession { std::move(factory) }; EXPECT_CALL(gameSession, getTexture(_)).WillOnce(Return(Texture())); // Mockowanie zależności odczytu z pliku EXPECT_CALL(gameSession, addPlayer()).WillOnce(Invoke([&amp;](){ // Mockowana metoda wykonuje tą prawdziwą return gameSession.GameSession::addPlayer(); })); const auto resultPlayerId { gameSession.addPlayer() }; // Wywołanie mockowanej metody EXPECT_EQ(0, resultPlayerId); } Dlaczego uważam to za fatalny pomysł? W końcu działa… No cóż to tak jakby używać spawarki do wbijania gwoździ, no niby da się tylko po co? Mocki zostały wymyślone po to by odcinać zależności między klasami, a nie do grzebania w implementacji naszej testowanej klasy. Gdy widzę test, w którym nie ma normalnej klasy, tylko same mocki to coś tu jest nie tak. Taki test jest bardzo nieczytelny. Gdy dodamy do tego enigmatyczną nazwę to praktycznie na pierwszy czy nawet drugi rzut oka, nie jesteśmy w stanie stwierdzić, która klasa jest testowana. W GoogleTest są oczywiście nazwa test suity, która może w tym przypadku podpowiedzieć to i owo, niemniej, czytelność i tak spada diametralnie. Używajmy narzędzi zgodnie z ich pierwotnym przeznaczeniem, zwłaszcza podczas testowania. Dbamy tym samym o wysoką czytelność i przejrzystość w naszych unit testach. Brak override w mockach Słowo kluczowe (a dokładnie specyfikator) override możemy stosować również w mockowanych metodach i działa ono dokładnie tak samo jak w zwykłych klasach. W MOCK_METHOD na końcu, w sekcji gdzie dodajemy kwalifikatory i specyfikatory. Dla przykładu, wróćmy do MockGameSession. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, ()); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;)); MOCK_METHOD(void, updateGameWorld, ()); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const)); }; Jeśli w takim przypadku metoda removePlayer w klasie GameSession nie będzie wirtualna, kompilator i tak nie zwróci błędu. Kod skompiluje się, a my będziemy zachodzić w głowę czemu nasz mock nie jest wywoływany. Użycie override eliminuje problem. W przypadku, gdy dodamy ten specyfikator, a metoda w klasie bazowej nie będzie wirtualna, kompilator zwróci błąd. Tak jak na poniższym przykładzie. Tutaj już poprawiony mock. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, (), (override)); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override)); MOCK_METHOD(void, updateGameWorld, (), (override)); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override)); }; Oraz błąd zwracany przez kompilator. /.../MockGameSession.hpp:16:23: error: &#39;testing::internal::Function&lt;void(const int&amp;)&gt;::Result MockGameSession::removePlayer(testing::internal::ElemFromList&lt;0, const int&amp;&gt;::type)&#39; marked &#39;override&#39;, but does not override 16 | MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); | Podsumowanie To już wszystko w tym wpisie. Mam nadzieję, że będzie dla Ciebie choć trochę pomocny w zmaganiach z Google Test’em. Czy któryś z wymienionych w tym wpisie błędów Cię zaskoczył? Może inny jest dość znajomy? Daj znać w komentarzu! Popełnianie błędów jest czymś normalnym. Ważne by się rozwijać i uczyć od siebie nawzajem. Jeśli znasz inne przypadki, chętnie się z nimi zapoznam. Możesz również napisać do mnie email lub wysłać wiadomość na LinkedIn. Będzie mi bardzo miło :) Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn" />
<meta property="og:description" content="Google Test to chyba najbardziej znany i używany framework testowy w projektach C++. Zawiera w sobie masę przydatnych narzędzi do tworzenia różnych rodzajów testów. Ja osobiście stosuję go w swoich projektach pisząc unit testy, ale nic nie stoi na przeszkodzie by tworzyć testy modułowe czy komponentowe (typu black box). Ceniony za swą uniwersalność oraz rozbudowany system asercji jest narzędziem bardzo potężnym. Mimo to nie jest również bez wad. Im bardziej złożone jest narzędzie tym trudniej się go nauczyć i korzystać z niego poprawnie. Popełniamy błędy. To normalne, ważne jest co z tym zrobimy. Warto wyciągnąć z nich lekcje na przyszłość. Poniższa lista to nic innego jak moje własne obserwacje, jak programiści C++(w tym ja) wykorzystują GTest i gdzie najczęściej popełniają błędy. Kolejność parametrów asercji Czy kolejność w asercji typu EXPECT_EQ jest ważna? Owszem! Choć nie wynika ona z samej definicji makra w nagłówku gtest.h. Wspomniana definicja wygląda następująco. #define EXPECT_EQ(val1, val2) \ EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2) Sam Google Test nie informuje gdzie ma być umieszczona wartość oczekiwania, a gdzie wynikowa. Skąd więc założenie, że wartość expected powinna być pierwsza? Głównie z przykładów z repozytorium Google Test. Przykład z folderu samples repozytorium Google Test, a dokładnie ten “sample4_unittest”. TEST(Counter, Increment) { Counter c; // Test that counter 0 returns 0 EXPECT_EQ(0, c.Decrement()); // EXPECT_EQ() evaluates its arguments exactly once, so they // can have side effects. EXPECT_EQ(0, c.Increment()); EXPECT_EQ(1, c.Increment()); EXPECT_EQ(2, c.Increment()); EXPECT_EQ(3, c.Decrement()); } Oczywiście jest ich znacznie więcej. Są dwa powody dlaczego warto najpierw podawać wartość oczekiwaną, a potem wynikową. Czytelność - przeglądając test, czytamy linijkę od lewej do prawej. Gdy wartością oczekiwaną jest po prostu stałą liczbową lub tekstową, szybciej dowiemy się co jest oczekiwane względem testowanej metody. Spójność z warunkami w kodzie - znasz ten ból, gdy w if zamiast użyć operatora porównania ==, użyłeś operator przypisania =? Ja tak, dlatego warto najpierw wartość oczekiwaną podawać jako pierwszą. Jeśli jest to stała, kompilator szybko poinformuje nas o pomyłce. if(i = 5) // Kompilator nie zgłosi błędu if(5 = i) // a tutaj już tak Logika jest zachowana ale zwiększa się odporność na błędy. To która wersja będzie poprawna? EXPECT_EQ(resultValue, expectedValue); // Ta? EXPECT_EQ(expectedValue, resultValue); // czy ta? Tak naprawdę - to zależy. Choć sama kolejność jest sugerowana przykładami, nie jest ona napisana wprost. Którą więc wybrać? Jeśli wchodzisz do projektu, gdzie pierwsza wartość to ta wynikowa. Dostosuj się do konwencji już panującej w projekcie. Jeśli to nowy projekt, lub brak jest spójnej konwencji, wybierz wersję, gdzie wartość oczekiwana podawana jest jako pierwsza. Używanie EXPECT zamiast ASSERT Ten błąd może kosztować życie (naszego wątku uruchamiającego testy). Dlaczego? Najpierw omówmy różnicę w zachowaniu EXPECT_EQ i ASSERT_EQ (lub dowolnej innej pary tych typów asercji). Obie asercje mają za zadanie sprawdzać czy dana wartość zgadza się z oczekiwaną. Różnica polega na tym co wydarzy się w przypadku niepowodzenia asercji. EXPECT spowoduje, że test nie zostanie zaliczony, wypisze komunikat i przejdzie do następnej linii testu. TEST_F(WidgetFactoryTests, create_ButtonWidgetType_ReturnButtonWidget) { const Rect expectedRect { 300, 400, 120, 30 }; const std::string expectedText { &quot;Test Button&quot; }; WidgetFactory factory {}; const auto resultWidget { factory.create(WidgetType::BUTTON, expectedRect, expectedText)}; EXPECT_EQ(WidgetType::LABEL, resultWidget.getType()); // Ta asercja się nie powiedzie EXPECT_EQ(expectedRect, resultWidget.getRect()); // Ta i następna zostaną wywołane EXPECT_EQ(expectedText, resultWidget.getText()); } ASSERT również spowoduje fail testu, wypisze komunikat, ale już nie przejdzie dalej do kolejnej części testu. Test zostaje przerwany w tym miejscu i dalej nie będzie kontynuowany. TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget) { const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() }; EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow())); EXPECT_CALL(*sfmlWindow, add(_)); WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr }; const auto resultWidget { factory.create( WidgetType::LABEL, WidgetGeometry {}, WidgetText {}, WidgetStyle {} ) }; // Jeśli ta metoda zwróci nullptr ASSERT_TRUE(resultWidget != nullptr); // to ta asercja się nie powiedzie i test przerywa wykonywanie. EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType()); // Ta i następna asercja nie zostaną wywołane EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr); } Co nam to daje? Bardzo wiele, zwłaszcza gdy kolejne asercje opierają się na naszym ASSERT. Jeśli zastosujemy zwykły EXPECT to test zakończy swoje działanie poprzez brutalne przerwanie w stylu segfaulta. TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget) { const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() }; EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow())); EXPECT_CALL(*sfmlWindow, add(_)); WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr }; const auto resultWidget { factory.create( WidgetType::LABEL, WidgetGeometry {}, WidgetText {}, WidgetStyle {} ) }; EXPECT_TRUE(resultWidget != nullptr); // zamiast ASSERT jest EXPECT EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType()); EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr); } Test nie przejdzie, na dodatek, jeśli w naszej suicie będzie więcej testów i miały być one uruchomione po tym, to do tego nie dojdzie. Cały wątek z naszą suitą zostanie przerwany. Czyli inne testy nawet się nie wykonają. [ RUN ] WidgetsFactorySfmlTests.create_LabelType_CreateLabelWidget Setting vertical sync not supported /usr/src/heisttown/src/Sfml/SfmlWidgets/Tests/WidgetsFactorySfmlTests.cpp:42: Failure Value of: resultWidget != nullptr Actual: false Expected: true W tym przypadku mamy chociaż informacje co poszło nie tak. Jeśli nie dodalibyśmy, w ogóle asercji na sprawdzanie czy resultWidget nie jest nullptr, nie wiedzielibyśmy nic. Dlatego ważne jest, aby stosować ASSERT czy EXPECT zgodnie z ich przeznaczeniem. Dlaczego więc nie stosować ASSERT zawsze? Jak już pisałem, ASSERT zatrzymuje test, dalsza jego część nie jest weryfikowana. Jeśli następne asercje nie są zależne od poprzednich to, w takim przypadku zostaną pominięte i nie będziemy wiedzieli, czy tylko ta jedna asercja nie została spełniona, czy cały ich szereg. Obraz sytuacji będzie niekompletny. Jeśli oczekiwanym wynikiem może być kontener to sprawdź jego rozmiar ASSERTem zanim zaczniesz weryfikować jego konkretne elementy. Albo, gdy wynikiem będzie wskaźnik, sprawdź czy nie jest on nullptr zanim zaczniesz odwoływać się do obiektu pod nim. To tylko najczęściej powtarzające się sytuacje, gdzie należy stosować ASSERT. Z pewnością jest ich więcej. Porównywanie float’ów bez precyzji Reprezentacja liczb zmiennoprzecinkowych przez komputer nie jest doskonała i wie to każdy doświadczony programista. Porównywanie wartości typu float czy double ze sobą nie jest takie proste jak liczb całkowitych. Weryfikacja testu odbywa się właśnie przez porównanie, a wyniki zapisane w liczbach zmiennoprzecinkowych mogą się nieznacznie różnić od tych oczekiwanych. Dlaczego tak się dzieje? Spora część liczb zmiennoprzecinkowych nie ma idealnej reprezentacji w systemie binarnym. Dlatego komputer musi zaokrąglać wyliczoną wartość do najbliższej zero-jedynkowej wartości. Jest nawet na to określony standard “IEEE 754”. Właśnie ze względu na te zaokrąglenia, porównywanie wartości zmiennoprzecinkowych, może dać fałszywe wyniki. Dlatego stosuje się porównywanie z tolerancją, tak zwany epsilon. To mi przypomina moje początki nauki pisania unit testów i pracy z Google Test. Tak, mniej więcej, wyglądał jeden z moich pierwszych unit testów w zakresie weryfikacji wyniku zapisanego właśnie w double. TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr) { const std::complex&lt;double&gt; sample { 1.0, 0.0 }; const double noise { 0.394 }; const auto resultLlr { llr16QamIMsb(sample, noise) }; EXPECT_EQ(5.0761421319796952, resultLlr); } Teraz, gdy o tym myślę, chce mi się śmiać, ale kto nie popełnia błędów? Ten kto nic nie robi ;) Dziś sobie z przed lat powiedziałbym co trzeba zrobić w takim przypadku, poprawilibyśmy ten test i wyglądałby następująco. TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr) { const std::complex&lt;double&gt; sample { 1.0, 0.0 }; const double noise { 0.394 }; const auto resultLlr { llr16QamIMsb(sample, noise) }; EXPECT_NEAR(5.07614, resultLlr, 0.00001); } Zmieniła się tylko sama asercja i z pewnością test stał się niewrażliwy na zmianę platformy, która ma inną precyzję operacji na liczbach zmiennoprzecinkowych. Dodatkowo dzięki właśnie EXPECT_NEAR możemy jasno określić tolerancję, czyli już wcześniej wspomniany epsilon. Logika w Mocku Wraz z Google Test dostajemy również Google Mock, jest on dodawany jako osobny nagłówek gmock.h. Mock to w tłumaczeniu na polski - makieta. Czyli, w kontekście programowania obiektowego, coś co tylko udaje implementację klasy. Nieraz jednak widziałem, mocki, które przysłaniały tylko część metod, pozostawiając lub nadpisując implementację klasy, z której dziedziczyły. Możemy podejść do mockowania na przynajmniej dwa sposoby. Pierowysz to bazowanie na interfejsie. Wprowadzamy klasę czysto abstrakcyjną, do której nasza testowana klasa się odwołuje, nie znając prawdziwej wersji implementacji. Poniżej przykład interfejsu RenderSceneBuilder. Klasa ta ma za zadanie budowanie sceny gry złożonej z obiektów klasy RenderItem (również interfejs) w oparciu o strukturę SceneUdate. class RenderSceneBuilder { public: virtual ~RenderSceneBuilder() = default; virtual auto build(const SceneUpdate&amp; sceneUpdate) -&gt; void = 0; virtual auto popRenderItems() -&gt; RenderItems = 0; }; A tutaj przykład jego wykorzystania (uproszczony by nie zaciemniać obrazu). class SfmlWindow { public: SfmlWindow( //... std::unique_ptr&lt;RenderSceneBuilder&gt; inputSceneBuilder = nullptr //... ); //... virtual auto update(const SceneUpdate&amp; sceneUpdate) override -&gt; void; private: //... std::unique_ptr&lt;RenderSceneBuilder&gt; sceneBuilder; //... }; Teraz utworzymy mocka z interfejsu, MockRenderSceneBuilder. class MockRenderSceneBuilder : public RenderSceneBuilder { public: MOCK_METHOD(void, build, (const SceneUpdate&amp;), (override)); MOCK_METHOD(RenderItems, popRenderItems, (), (override)); }; W tym przypadku klasa mocka przysłania tylko interfejs i wszystko mamy czyste. Wstrzykujemy mocka do naszej testowanej klasy poprzez konstruktor i voilà! Drugi sposób - do destruktora oraz wszystkich publicznych metod klasy, którą chcemy zamockować dodajemy virtual. Dla przykładu mamy klasę GameSession. class GameSession { public: explicit GameSession(std::unique_ptr&lt;SceneItemFactory&gt; inputFactory = nullptr); virtual ~GameSession() = default; virtual auto addPlayer() -&gt; PlayerID; virtual auto removePlayer(const PlayerID&amp; playerId) -&gt; void; virtual auto queuePlayerStatus(const PlayerID&amp; playerId, const PlayerStatus&amp; playerStatus) -&gt; void; virtual auto updateGameWorld() -&gt; void; virtual auto getUpdateForPlayer(const PlayerID&amp; playerId) const -&gt; GameplayUpdate; private: //... }; I mockujemy. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, (), (override)); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override)); MOCK_METHOD(void, updateGameWorld, (), (override)); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override)); }; Jeśli pozostawimy część publicznych metod jako niewirtualne i nie przysłonimy ich w mocku to nie odcinamy w pełni zależności między naszą testowaną klasą, a klasą zmockowaną. Taki test de facto nie jest już unit testem lecz czymś w rodzaju karykatury module testu. Poniżej przykład class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, (), (override)); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override)); MOCK_METHOD(void, updateGameWorld, (), (override)); GameplayUpdate getUpdateForPlayer(const PlayerID&amp;) const override { // Generuje losowe wartości i wypełnia nimi GameplayUpdate } }; W przypadku, gdy dopisujemy jakąś część logiki w kodzie mocka ograniczamy widoczność tych operacji w naszych testach. Mock sam z siebie nie powinien nic robić. Służy on do weryfikacji zachowania naszej testowanej klasy, tj. jego interakcji z mockowaną klasą. Jeśli potrzebujemy, by nasz mock reagował na te interakcje Google Mock udostępnia szereg narzędzi jak ON_CALL i EXPECT_CALL z odpowiednią kombinacją na przykład WillOnce i Invoke (są też inne metody na sterowanie zachowaniem mocka). Wtedy wszystko jest zapisane w naszym unit teście, w bloku “Arrange”. Testowanie Mocka Jak już wspomniałem mocki służą do weryfikacji interakcji z naszą testowaną klasą. Spotkałem się jednak z innym sposobem wykorzystywania mocków w unit testach. Kiedy nie znamy dobrych podstaw pisania unit testów (o których jeszcze napiszę ;) ), mogą powstać naprawdę dziwne rzeczy. W unit testach widziałem wiele nietypowych konstrukcji, i w rzeczy samej testowanie mocka jest jedną z nich. Chcąc odciąć jakąś zależność możemy zastosować mocka, aby przysłonić część implementacji lub wręcz zastąpić ją inną. Co de facto mija się z celem testowania. Dla przykładu, mamy mocka klasy MockGameSession z poprzedniego punktu. Tym razem jak najbardziej poprawnego. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, ()); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;)); MOCK_METHOD(void, updateGameWorld, ()); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const)); MOCK_METHOD(Texture, getTexture, (const std::string), (const)); // metoda protected w GameSession }; Natomiast w unit testach chcemy przetestować metodę addPlayer klasy GameSession, jednak korzysta ona z metody getTexture odczytującej teksturę gracza z pliku. W takim przypadku moglibyśmy zastosować “Wrapper” lub wprowadzić osobny obiekt klasy Factory i zacmokocwać ją stosująć Dependency Injection. Jednak nie znając jeszcze tych technik możemy pokusić się o użycie mocka w taki sposób, by podczas testowania metody addPlayer przysłonić tylko metodę getTexture, która to odpowiedzialna jest za odczyt pliku. TEST_F(GameSessionTests, addPlayer_OneNewPlayer_ReturnNewPlayerId) { auto factory { std::make_unique&lt;MockSceneItemFactory&gt;() }; EXPECT_CALL(*factory, create(_, _, _)); MockGameSession gameSession { std::move(factory) }; EXPECT_CALL(gameSession, getTexture(_)).WillOnce(Return(Texture())); // Mockowanie zależności odczytu z pliku EXPECT_CALL(gameSession, addPlayer()).WillOnce(Invoke([&amp;](){ // Mockowana metoda wykonuje tą prawdziwą return gameSession.GameSession::addPlayer(); })); const auto resultPlayerId { gameSession.addPlayer() }; // Wywołanie mockowanej metody EXPECT_EQ(0, resultPlayerId); } Dlaczego uważam to za fatalny pomysł? W końcu działa… No cóż to tak jakby używać spawarki do wbijania gwoździ, no niby da się tylko po co? Mocki zostały wymyślone po to by odcinać zależności między klasami, a nie do grzebania w implementacji naszej testowanej klasy. Gdy widzę test, w którym nie ma normalnej klasy, tylko same mocki to coś tu jest nie tak. Taki test jest bardzo nieczytelny. Gdy dodamy do tego enigmatyczną nazwę to praktycznie na pierwszy czy nawet drugi rzut oka, nie jesteśmy w stanie stwierdzić, która klasa jest testowana. W GoogleTest są oczywiście nazwa test suity, która może w tym przypadku podpowiedzieć to i owo, niemniej, czytelność i tak spada diametralnie. Używajmy narzędzi zgodnie z ich pierwotnym przeznaczeniem, zwłaszcza podczas testowania. Dbamy tym samym o wysoką czytelność i przejrzystość w naszych unit testach. Brak override w mockach Słowo kluczowe (a dokładnie specyfikator) override możemy stosować również w mockowanych metodach i działa ono dokładnie tak samo jak w zwykłych klasach. W MOCK_METHOD na końcu, w sekcji gdzie dodajemy kwalifikatory i specyfikatory. Dla przykładu, wróćmy do MockGameSession. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, ()); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;)); MOCK_METHOD(void, updateGameWorld, ()); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const)); }; Jeśli w takim przypadku metoda removePlayer w klasie GameSession nie będzie wirtualna, kompilator i tak nie zwróci błędu. Kod skompiluje się, a my będziemy zachodzić w głowę czemu nasz mock nie jest wywoływany. Użycie override eliminuje problem. W przypadku, gdy dodamy ten specyfikator, a metoda w klasie bazowej nie będzie wirtualna, kompilator zwróci błąd. Tak jak na poniższym przykładzie. Tutaj już poprawiony mock. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, (), (override)); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override)); MOCK_METHOD(void, updateGameWorld, (), (override)); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override)); }; Oraz błąd zwracany przez kompilator. /.../MockGameSession.hpp:16:23: error: &#39;testing::internal::Function&lt;void(const int&amp;)&gt;::Result MockGameSession::removePlayer(testing::internal::ElemFromList&lt;0, const int&amp;&gt;::type)&#39; marked &#39;override&#39;, but does not override 16 | MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); | Podsumowanie To już wszystko w tym wpisie. Mam nadzieję, że będzie dla Ciebie choć trochę pomocny w zmaganiach z Google Test’em. Czy któryś z wymienionych w tym wpisie błędów Cię zaskoczył? Może inny jest dość znajomy? Daj znać w komentarzu! Popełnianie błędów jest czymś normalnym. Ważne by się rozwijać i uczyć od siebie nawzajem. Jeśli znasz inne przypadki, chętnie się z nimi zapoznam. Możesz również napisać do mnie email lub wysłać wiadomość na LinkedIn. Będzie mi bardzo miło :) Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn" />
<link rel="canonical" href="https://cpptested.com/clean%20code/gtest-mistakes/" />
<meta property="og:url" content="https://cpptested.com/clean%20code/gtest-mistakes/" />
<meta property="og:site_name" content="CppTested" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2026-01-26T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="6 najczęstszych błędów z Google Test." />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Tadeusz Biela"},"dateModified":"2026-01-26T00:00:00+01:00","datePublished":"2026-01-26T00:00:00+01:00","description":"Google Test to chyba najbardziej znany i używany framework testowy w projektach C++. Zawiera w sobie masę przydatnych narzędzi do tworzenia różnych rodzajów testów. Ja osobiście stosuję go w swoich projektach pisząc unit testy, ale nic nie stoi na przeszkodzie by tworzyć testy modułowe czy komponentowe (typu black box). Ceniony za swą uniwersalność oraz rozbudowany system asercji jest narzędziem bardzo potężnym. Mimo to nie jest również bez wad. Im bardziej złożone jest narzędzie tym trudniej się go nauczyć i korzystać z niego poprawnie. Popełniamy błędy. To normalne, ważne jest co z tym zrobimy. Warto wyciągnąć z nich lekcje na przyszłość. Poniższa lista to nic innego jak moje własne obserwacje, jak programiści C++(w tym ja) wykorzystują GTest i gdzie najczęściej popełniają błędy. Kolejność parametrów asercji Czy kolejność w asercji typu EXPECT_EQ jest ważna? Owszem! Choć nie wynika ona z samej definicji makra w nagłówku gtest.h. Wspomniana definicja wygląda następująco. #define EXPECT_EQ(val1, val2) \\ EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2) Sam Google Test nie informuje gdzie ma być umieszczona wartość oczekiwania, a gdzie wynikowa. Skąd więc założenie, że wartość expected powinna być pierwsza? Głównie z przykładów z repozytorium Google Test. Przykład z folderu samples repozytorium Google Test, a dokładnie ten “sample4_unittest”. TEST(Counter, Increment) { Counter c; // Test that counter 0 returns 0 EXPECT_EQ(0, c.Decrement()); // EXPECT_EQ() evaluates its arguments exactly once, so they // can have side effects. EXPECT_EQ(0, c.Increment()); EXPECT_EQ(1, c.Increment()); EXPECT_EQ(2, c.Increment()); EXPECT_EQ(3, c.Decrement()); } Oczywiście jest ich znacznie więcej. Są dwa powody dlaczego warto najpierw podawać wartość oczekiwaną, a potem wynikową. Czytelność - przeglądając test, czytamy linijkę od lewej do prawej. Gdy wartością oczekiwaną jest po prostu stałą liczbową lub tekstową, szybciej dowiemy się co jest oczekiwane względem testowanej metody. Spójność z warunkami w kodzie - znasz ten ból, gdy w if zamiast użyć operatora porównania ==, użyłeś operator przypisania =? Ja tak, dlatego warto najpierw wartość oczekiwaną podawać jako pierwszą. Jeśli jest to stała, kompilator szybko poinformuje nas o pomyłce. if(i = 5) // Kompilator nie zgłosi błędu if(5 = i) // a tutaj już tak Logika jest zachowana ale zwiększa się odporność na błędy. To która wersja będzie poprawna? EXPECT_EQ(resultValue, expectedValue); // Ta? EXPECT_EQ(expectedValue, resultValue); // czy ta? Tak naprawdę - to zależy. Choć sama kolejność jest sugerowana przykładami, nie jest ona napisana wprost. Którą więc wybrać? Jeśli wchodzisz do projektu, gdzie pierwsza wartość to ta wynikowa. Dostosuj się do konwencji już panującej w projekcie. Jeśli to nowy projekt, lub brak jest spójnej konwencji, wybierz wersję, gdzie wartość oczekiwana podawana jest jako pierwsza. Używanie EXPECT zamiast ASSERT Ten błąd może kosztować życie (naszego wątku uruchamiającego testy). Dlaczego? Najpierw omówmy różnicę w zachowaniu EXPECT_EQ i ASSERT_EQ (lub dowolnej innej pary tych typów asercji). Obie asercje mają za zadanie sprawdzać czy dana wartość zgadza się z oczekiwaną. Różnica polega na tym co wydarzy się w przypadku niepowodzenia asercji. EXPECT spowoduje, że test nie zostanie zaliczony, wypisze komunikat i przejdzie do następnej linii testu. TEST_F(WidgetFactoryTests, create_ButtonWidgetType_ReturnButtonWidget) { const Rect expectedRect { 300, 400, 120, 30 }; const std::string expectedText { &quot;Test Button&quot; }; WidgetFactory factory {}; const auto resultWidget { factory.create(WidgetType::BUTTON, expectedRect, expectedText)}; EXPECT_EQ(WidgetType::LABEL, resultWidget.getType()); // Ta asercja się nie powiedzie EXPECT_EQ(expectedRect, resultWidget.getRect()); // Ta i następna zostaną wywołane EXPECT_EQ(expectedText, resultWidget.getText()); } ASSERT również spowoduje fail testu, wypisze komunikat, ale już nie przejdzie dalej do kolejnej części testu. Test zostaje przerwany w tym miejscu i dalej nie będzie kontynuowany. TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget) { const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() }; EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow())); EXPECT_CALL(*sfmlWindow, add(_)); WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr }; const auto resultWidget { factory.create( WidgetType::LABEL, WidgetGeometry {}, WidgetText {}, WidgetStyle {} ) }; // Jeśli ta metoda zwróci nullptr ASSERT_TRUE(resultWidget != nullptr); // to ta asercja się nie powiedzie i test przerywa wykonywanie. EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType()); // Ta i następna asercja nie zostaną wywołane EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr); } Co nam to daje? Bardzo wiele, zwłaszcza gdy kolejne asercje opierają się na naszym ASSERT. Jeśli zastosujemy zwykły EXPECT to test zakończy swoje działanie poprzez brutalne przerwanie w stylu segfaulta. TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget) { const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() }; EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow())); EXPECT_CALL(*sfmlWindow, add(_)); WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr }; const auto resultWidget { factory.create( WidgetType::LABEL, WidgetGeometry {}, WidgetText {}, WidgetStyle {} ) }; EXPECT_TRUE(resultWidget != nullptr); // zamiast ASSERT jest EXPECT EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType()); EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr); } Test nie przejdzie, na dodatek, jeśli w naszej suicie będzie więcej testów i miały być one uruchomione po tym, to do tego nie dojdzie. Cały wątek z naszą suitą zostanie przerwany. Czyli inne testy nawet się nie wykonają. [ RUN ] WidgetsFactorySfmlTests.create_LabelType_CreateLabelWidget Setting vertical sync not supported /usr/src/heisttown/src/Sfml/SfmlWidgets/Tests/WidgetsFactorySfmlTests.cpp:42: Failure Value of: resultWidget != nullptr Actual: false Expected: true W tym przypadku mamy chociaż informacje co poszło nie tak. Jeśli nie dodalibyśmy, w ogóle asercji na sprawdzanie czy resultWidget nie jest nullptr, nie wiedzielibyśmy nic. Dlatego ważne jest, aby stosować ASSERT czy EXPECT zgodnie z ich przeznaczeniem. Dlaczego więc nie stosować ASSERT zawsze? Jak już pisałem, ASSERT zatrzymuje test, dalsza jego część nie jest weryfikowana. Jeśli następne asercje nie są zależne od poprzednich to, w takim przypadku zostaną pominięte i nie będziemy wiedzieli, czy tylko ta jedna asercja nie została spełniona, czy cały ich szereg. Obraz sytuacji będzie niekompletny. Jeśli oczekiwanym wynikiem może być kontener to sprawdź jego rozmiar ASSERTem zanim zaczniesz weryfikować jego konkretne elementy. Albo, gdy wynikiem będzie wskaźnik, sprawdź czy nie jest on nullptr zanim zaczniesz odwoływać się do obiektu pod nim. To tylko najczęściej powtarzające się sytuacje, gdzie należy stosować ASSERT. Z pewnością jest ich więcej. Porównywanie float’ów bez precyzji Reprezentacja liczb zmiennoprzecinkowych przez komputer nie jest doskonała i wie to każdy doświadczony programista. Porównywanie wartości typu float czy double ze sobą nie jest takie proste jak liczb całkowitych. Weryfikacja testu odbywa się właśnie przez porównanie, a wyniki zapisane w liczbach zmiennoprzecinkowych mogą się nieznacznie różnić od tych oczekiwanych. Dlaczego tak się dzieje? Spora część liczb zmiennoprzecinkowych nie ma idealnej reprezentacji w systemie binarnym. Dlatego komputer musi zaokrąglać wyliczoną wartość do najbliższej zero-jedynkowej wartości. Jest nawet na to określony standard “IEEE 754”. Właśnie ze względu na te zaokrąglenia, porównywanie wartości zmiennoprzecinkowych, może dać fałszywe wyniki. Dlatego stosuje się porównywanie z tolerancją, tak zwany epsilon. To mi przypomina moje początki nauki pisania unit testów i pracy z Google Test. Tak, mniej więcej, wyglądał jeden z moich pierwszych unit testów w zakresie weryfikacji wyniku zapisanego właśnie w double. TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr) { const std::complex&lt;double&gt; sample { 1.0, 0.0 }; const double noise { 0.394 }; const auto resultLlr { llr16QamIMsb(sample, noise) }; EXPECT_EQ(5.0761421319796952, resultLlr); } Teraz, gdy o tym myślę, chce mi się śmiać, ale kto nie popełnia błędów? Ten kto nic nie robi ;) Dziś sobie z przed lat powiedziałbym co trzeba zrobić w takim przypadku, poprawilibyśmy ten test i wyglądałby następująco. TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr) { const std::complex&lt;double&gt; sample { 1.0, 0.0 }; const double noise { 0.394 }; const auto resultLlr { llr16QamIMsb(sample, noise) }; EXPECT_NEAR(5.07614, resultLlr, 0.00001); } Zmieniła się tylko sama asercja i z pewnością test stał się niewrażliwy na zmianę platformy, która ma inną precyzję operacji na liczbach zmiennoprzecinkowych. Dodatkowo dzięki właśnie EXPECT_NEAR możemy jasno określić tolerancję, czyli już wcześniej wspomniany epsilon. Logika w Mocku Wraz z Google Test dostajemy również Google Mock, jest on dodawany jako osobny nagłówek gmock.h. Mock to w tłumaczeniu na polski - makieta. Czyli, w kontekście programowania obiektowego, coś co tylko udaje implementację klasy. Nieraz jednak widziałem, mocki, które przysłaniały tylko część metod, pozostawiając lub nadpisując implementację klasy, z której dziedziczyły. Możemy podejść do mockowania na przynajmniej dwa sposoby. Pierowysz to bazowanie na interfejsie. Wprowadzamy klasę czysto abstrakcyjną, do której nasza testowana klasa się odwołuje, nie znając prawdziwej wersji implementacji. Poniżej przykład interfejsu RenderSceneBuilder. Klasa ta ma za zadanie budowanie sceny gry złożonej z obiektów klasy RenderItem (również interfejs) w oparciu o strukturę SceneUdate. class RenderSceneBuilder { public: virtual ~RenderSceneBuilder() = default; virtual auto build(const SceneUpdate&amp; sceneUpdate) -&gt; void = 0; virtual auto popRenderItems() -&gt; RenderItems = 0; }; A tutaj przykład jego wykorzystania (uproszczony by nie zaciemniać obrazu). class SfmlWindow { public: SfmlWindow( //... std::unique_ptr&lt;RenderSceneBuilder&gt; inputSceneBuilder = nullptr //... ); //... virtual auto update(const SceneUpdate&amp; sceneUpdate) override -&gt; void; private: //... std::unique_ptr&lt;RenderSceneBuilder&gt; sceneBuilder; //... }; Teraz utworzymy mocka z interfejsu, MockRenderSceneBuilder. class MockRenderSceneBuilder : public RenderSceneBuilder { public: MOCK_METHOD(void, build, (const SceneUpdate&amp;), (override)); MOCK_METHOD(RenderItems, popRenderItems, (), (override)); }; W tym przypadku klasa mocka przysłania tylko interfejs i wszystko mamy czyste. Wstrzykujemy mocka do naszej testowanej klasy poprzez konstruktor i voilà! Drugi sposób - do destruktora oraz wszystkich publicznych metod klasy, którą chcemy zamockować dodajemy virtual. Dla przykładu mamy klasę GameSession. class GameSession { public: explicit GameSession(std::unique_ptr&lt;SceneItemFactory&gt; inputFactory = nullptr); virtual ~GameSession() = default; virtual auto addPlayer() -&gt; PlayerID; virtual auto removePlayer(const PlayerID&amp; playerId) -&gt; void; virtual auto queuePlayerStatus(const PlayerID&amp; playerId, const PlayerStatus&amp; playerStatus) -&gt; void; virtual auto updateGameWorld() -&gt; void; virtual auto getUpdateForPlayer(const PlayerID&amp; playerId) const -&gt; GameplayUpdate; private: //... }; I mockujemy. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, (), (override)); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override)); MOCK_METHOD(void, updateGameWorld, (), (override)); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override)); }; Jeśli pozostawimy część publicznych metod jako niewirtualne i nie przysłonimy ich w mocku to nie odcinamy w pełni zależności między naszą testowaną klasą, a klasą zmockowaną. Taki test de facto nie jest już unit testem lecz czymś w rodzaju karykatury module testu. Poniżej przykład class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, (), (override)); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override)); MOCK_METHOD(void, updateGameWorld, (), (override)); GameplayUpdate getUpdateForPlayer(const PlayerID&amp;) const override { // Generuje losowe wartości i wypełnia nimi GameplayUpdate } }; W przypadku, gdy dopisujemy jakąś część logiki w kodzie mocka ograniczamy widoczność tych operacji w naszych testach. Mock sam z siebie nie powinien nic robić. Służy on do weryfikacji zachowania naszej testowanej klasy, tj. jego interakcji z mockowaną klasą. Jeśli potrzebujemy, by nasz mock reagował na te interakcje Google Mock udostępnia szereg narzędzi jak ON_CALL i EXPECT_CALL z odpowiednią kombinacją na przykład WillOnce i Invoke (są też inne metody na sterowanie zachowaniem mocka). Wtedy wszystko jest zapisane w naszym unit teście, w bloku “Arrange”. Testowanie Mocka Jak już wspomniałem mocki służą do weryfikacji interakcji z naszą testowaną klasą. Spotkałem się jednak z innym sposobem wykorzystywania mocków w unit testach. Kiedy nie znamy dobrych podstaw pisania unit testów (o których jeszcze napiszę ;) ), mogą powstać naprawdę dziwne rzeczy. W unit testach widziałem wiele nietypowych konstrukcji, i w rzeczy samej testowanie mocka jest jedną z nich. Chcąc odciąć jakąś zależność możemy zastosować mocka, aby przysłonić część implementacji lub wręcz zastąpić ją inną. Co de facto mija się z celem testowania. Dla przykładu, mamy mocka klasy MockGameSession z poprzedniego punktu. Tym razem jak najbardziej poprawnego. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, ()); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;)); MOCK_METHOD(void, updateGameWorld, ()); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const)); MOCK_METHOD(Texture, getTexture, (const std::string), (const)); // metoda protected w GameSession }; Natomiast w unit testach chcemy przetestować metodę addPlayer klasy GameSession, jednak korzysta ona z metody getTexture odczytującej teksturę gracza z pliku. W takim przypadku moglibyśmy zastosować “Wrapper” lub wprowadzić osobny obiekt klasy Factory i zacmokocwać ją stosująć Dependency Injection. Jednak nie znając jeszcze tych technik możemy pokusić się o użycie mocka w taki sposób, by podczas testowania metody addPlayer przysłonić tylko metodę getTexture, która to odpowiedzialna jest za odczyt pliku. TEST_F(GameSessionTests, addPlayer_OneNewPlayer_ReturnNewPlayerId) { auto factory { std::make_unique&lt;MockSceneItemFactory&gt;() }; EXPECT_CALL(*factory, create(_, _, _)); MockGameSession gameSession { std::move(factory) }; EXPECT_CALL(gameSession, getTexture(_)).WillOnce(Return(Texture())); // Mockowanie zależności odczytu z pliku EXPECT_CALL(gameSession, addPlayer()).WillOnce(Invoke([&amp;](){ // Mockowana metoda wykonuje tą prawdziwą return gameSession.GameSession::addPlayer(); })); const auto resultPlayerId { gameSession.addPlayer() }; // Wywołanie mockowanej metody EXPECT_EQ(0, resultPlayerId); } Dlaczego uważam to za fatalny pomysł? W końcu działa… No cóż to tak jakby używać spawarki do wbijania gwoździ, no niby da się tylko po co? Mocki zostały wymyślone po to by odcinać zależności między klasami, a nie do grzebania w implementacji naszej testowanej klasy. Gdy widzę test, w którym nie ma normalnej klasy, tylko same mocki to coś tu jest nie tak. Taki test jest bardzo nieczytelny. Gdy dodamy do tego enigmatyczną nazwę to praktycznie na pierwszy czy nawet drugi rzut oka, nie jesteśmy w stanie stwierdzić, która klasa jest testowana. W GoogleTest są oczywiście nazwa test suity, która może w tym przypadku podpowiedzieć to i owo, niemniej, czytelność i tak spada diametralnie. Używajmy narzędzi zgodnie z ich pierwotnym przeznaczeniem, zwłaszcza podczas testowania. Dbamy tym samym o wysoką czytelność i przejrzystość w naszych unit testach. Brak override w mockach Słowo kluczowe (a dokładnie specyfikator) override możemy stosować również w mockowanych metodach i działa ono dokładnie tak samo jak w zwykłych klasach. W MOCK_METHOD na końcu, w sekcji gdzie dodajemy kwalifikatory i specyfikatory. Dla przykładu, wróćmy do MockGameSession. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, ()); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;)); MOCK_METHOD(void, updateGameWorld, ()); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const)); }; Jeśli w takim przypadku metoda removePlayer w klasie GameSession nie będzie wirtualna, kompilator i tak nie zwróci błędu. Kod skompiluje się, a my będziemy zachodzić w głowę czemu nasz mock nie jest wywoływany. Użycie override eliminuje problem. W przypadku, gdy dodamy ten specyfikator, a metoda w klasie bazowej nie będzie wirtualna, kompilator zwróci błąd. Tak jak na poniższym przykładzie. Tutaj już poprawiony mock. class MockGameSession : public GameSession { public: MockGameSession() = default; MOCK_METHOD(PlayerID, addPlayer, (), (override)); MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override)); MOCK_METHOD(void, updateGameWorld, (), (override)); MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override)); }; Oraz błąd zwracany przez kompilator. /.../MockGameSession.hpp:16:23: error: &#39;testing::internal::Function&lt;void(const int&amp;)&gt;::Result MockGameSession::removePlayer(testing::internal::ElemFromList&lt;0, const int&amp;&gt;::type)&#39; marked &#39;override&#39;, but does not override 16 | MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override)); | Podsumowanie To już wszystko w tym wpisie. Mam nadzieję, że będzie dla Ciebie choć trochę pomocny w zmaganiach z Google Test’em. Czy któryś z wymienionych w tym wpisie błędów Cię zaskoczył? Może inny jest dość znajomy? Daj znać w komentarzu! Popełnianie błędów jest czymś normalnym. Ważne by się rozwijać i uczyć od siebie nawzajem. Jeśli znasz inne przypadki, chętnie się z nimi zapoznam. Możesz również napisać do mnie email lub wysłać wiadomość na LinkedIn. Będzie mi bardzo miło :) Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn","headline":"6 najczęstszych błędów z Google Test.","mainEntityOfPage":{"@type":"WebPage","@id":"https://cpptested.com/clean%20code/gtest-mistakes/"},"url":"https://cpptested.com/clean%20code/gtest-mistakes/"}</script>
<!-- End Jekyll SEO tag -->


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HKF97SJC9Z"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HKF97SJC9Z');
</script>

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<link rel="icon" type="image/png" href="/favicon.png">

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Przejdź do nawigacji</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Przejdź do treści</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Przejdź do stopki</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
	<a href="/" class="site-logo">
	  <span style="color: white; font-family: Courier, monospace;">Cpp</span>
  	  <span style="color: #28a745; font-family: Courier, monospace;">Tested</span>
	  <span class="blinking-cursor">|</span>
	</a>	
        <a class="site-title" href="/">
          CppTested
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/posts/"
                
                
              >Wpisy</a>
            </li><li class="masthead__menu-item">
              <a
                href="/categories/"
                
                
              >Kategorie</a>
            </li><li class="masthead__menu-item">
              <a
                href="/tags/"
                
                
              >Tagi</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >O mnie</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Przełącz wyszukiwanie</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Przełącz menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="6 najczęstszych błędów z Google Test.">
    <meta itemprop="description" content="Google Test to chyba najbardziej znany i używany framework testowy w projektach C++. Zawiera w sobie masę przydatnych narzędzi do tworzenia różnych rodzajów testów. Ja osobiście stosuję go w swoich projektach pisząc unit testy, ale nic nie stoi na przeszkodzie by tworzyć testy modułowe czy komponentowe (typu black box). Ceniony za swą uniwersalność oraz rozbudowany system asercji jest narzędziem bardzo potężnym. Mimo to nie jest również bez wad. Im bardziej złożone jest narzędzie tym trudniej się go nauczyć i korzystać z niego poprawnie.Popełniamy błędy. To normalne, ważne jest co z tym zrobimy. Warto wyciągnąć z nich lekcje na przyszłość. Poniższa lista to nic innego jak moje własne obserwacje, jak programiści C++(w tym ja) wykorzystują GTest i gdzie najczęściej popełniają błędy.Kolejność parametrów asercjiCzy kolejność w asercji typu EXPECT_EQ jest ważna? Owszem! Choć nie wynika ona z samej definicji makra w nagłówku gtest.h. Wspomniana definicja wygląda następująco.#define EXPECT_EQ(val1, val2) \  EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)Sam Google Test nie informuje gdzie ma być umieszczona wartość oczekiwania, a gdzie wynikowa. Skąd więc założenie, że wartość expected powinna być pierwsza? Głównie z przykładów z repozytorium Google Test.Przykład z folderu samples repozytorium Google Test, a dokładnie ten “sample4_unittest”.TEST(Counter, Increment) {  Counter c;  // Test that counter 0 returns 0  EXPECT_EQ(0, c.Decrement());  // EXPECT_EQ() evaluates its arguments exactly once, so they  // can have side effects.  EXPECT_EQ(0, c.Increment());  EXPECT_EQ(1, c.Increment());  EXPECT_EQ(2, c.Increment());  EXPECT_EQ(3, c.Decrement());}Oczywiście jest ich znacznie więcej.Są dwa powody dlaczego warto najpierw podawać wartość oczekiwaną, a potem wynikową.  Czytelność - przeglądając test, czytamy linijkę od lewej do prawej. Gdy wartością oczekiwaną jest po prostu stałą liczbową lub tekstową, szybciej dowiemy się co jest oczekiwane względem testowanej metody.  Spójność z warunkami w kodzie - znasz ten ból, gdy w if zamiast użyć operatora porównania ==, użyłeś operator przypisania =? Ja tak, dlatego warto najpierw wartość oczekiwaną podawać jako pierwszą. Jeśli jest to stała, kompilator szybko poinformuje nas o pomyłce.if(i = 5) // Kompilator nie zgłosi błęduif(5 = i) // a tutaj już takLogika jest zachowana ale zwiększa się odporność na błędy.To która wersja będzie poprawna?EXPECT_EQ(resultValue, expectedValue); // Ta?EXPECT_EQ(expectedValue, resultValue); // czy ta?Tak naprawdę - to zależy. Choć sama kolejność jest sugerowana przykładami, nie jest ona napisana wprost. Którą więc wybrać? Jeśli wchodzisz do projektu, gdzie pierwsza wartość to ta wynikowa. Dostosuj się do konwencji już panującej w projekcie. Jeśli to nowy projekt, lub brak jest spójnej konwencji, wybierz wersję, gdzie wartość oczekiwana podawana jest jako pierwsza.Używanie EXPECT zamiast ASSERTTen błąd może kosztować życie (naszego wątku uruchamiającego testy). Dlaczego? Najpierw omówmy różnicę w zachowaniu EXPECT_EQ i ASSERT_EQ (lub dowolnej innej pary tych typów asercji). Obie asercje mają za zadanie sprawdzać czy dana wartość zgadza się z oczekiwaną. Różnica polega na tym co wydarzy się w przypadku niepowodzenia asercji. EXPECT spowoduje, że test nie zostanie zaliczony, wypisze komunikat i przejdzie do następnej linii testu.TEST_F(WidgetFactoryTests, create_ButtonWidgetType_ReturnButtonWidget){    const Rect expectedRect { 300, 400, 120, 30 };    const std::string expectedText { &quot;Test Button&quot; };    WidgetFactory factory {};    const auto resultWidget { factory.create(WidgetType::BUTTON, expectedRect, expectedText)};    EXPECT_EQ(WidgetType::LABEL, resultWidget.getType()); // Ta asercja się nie powiedzie    EXPECT_EQ(expectedRect, resultWidget.getRect()); // Ta i następna zostaną wywołane    EXPECT_EQ(expectedText, resultWidget.getText());}ASSERT również spowoduje fail testu, wypisze komunikat, ale już nie przejdzie dalej do kolejnej części testu. Test zostaje przerwany w tym miejscu i dalej nie będzie kontynuowany.TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget){    const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() };    EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow()));    EXPECT_CALL(*sfmlWindow, add(_));    WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr };    const auto resultWidget {        factory.create(            WidgetType::LABEL,            WidgetGeometry {},            WidgetText {},            WidgetStyle {}        )    }; // Jeśli ta metoda zwróci nullptr    ASSERT_TRUE(resultWidget != nullptr); // to ta asercja się nie powiedzie i test przerywa wykonywanie.    EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType()); // Ta i następna asercja nie zostaną wywołane    EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr);}Co nam to daje? Bardzo wiele, zwłaszcza gdy kolejne asercje opierają się na naszym ASSERT. Jeśli zastosujemy zwykły EXPECT to test zakończy swoje działanie poprzez brutalne przerwanie w stylu segfaulta.TEST_F(WidgetsFactorySfmlTests, create_LabelType_CreateLabelWidget){    const auto sfmlWindow { std::make_shared&lt;MockSfmlWindow&gt;() };    EXPECT_CALL(*sfmlWindow, getRenderTarget()).WillOnce(ReturnRef(getWindow()));    EXPECT_CALL(*sfmlWindow, add(_));    WidgetsFactorySfml factory { nullptr, sfmlWindow, nullptr };    const auto resultWidget {        factory.create(            WidgetType::LABEL,            WidgetGeometry {},            WidgetText {},            WidgetStyle {}        )    };     EXPECT_TRUE(resultWidget != nullptr); // zamiast ASSERT jest EXPECT    EXPECT_EQ(WidgetType::LABEL, resultWidget-&gt;getType());    EXPECT_TRUE(dynamic_cast&lt;LabelWidget*&gt;(resultWidget.get()) != nullptr);}Test nie przejdzie, na dodatek, jeśli w naszej suicie będzie więcej testów i miały być one uruchomione po tym, to do tego nie dojdzie. Cały wątek z naszą suitą zostanie przerwany. Czyli inne testy nawet się nie wykonają.[ RUN      ] WidgetsFactorySfmlTests.create_LabelType_CreateLabelWidgetSetting vertical sync not supported/usr/src/heisttown/src/Sfml/SfmlWidgets/Tests/WidgetsFactorySfmlTests.cpp:42: FailureValue of: resultWidget != nullptr  Actual: falseExpected: trueW tym przypadku mamy chociaż informacje co poszło nie tak. Jeśli nie dodalibyśmy, w ogóle asercji na sprawdzanie czy resultWidget nie jest nullptr, nie wiedzielibyśmy nic. Dlatego ważne jest, aby stosować ASSERT czy EXPECT zgodnie z ich przeznaczeniem.Dlaczego więc nie stosować ASSERT zawsze? Jak już pisałem, ASSERT zatrzymuje test, dalsza jego część nie jest weryfikowana. Jeśli następne asercje nie są zależne od poprzednich to, w takim przypadku zostaną pominięte i nie będziemy wiedzieli, czy tylko ta jedna asercja nie została spełniona, czy cały ich szereg. Obraz sytuacji będzie niekompletny.Jeśli oczekiwanym wynikiem może być kontener to sprawdź jego rozmiar ASSERTem zanim zaczniesz weryfikować jego konkretne elementy. Albo, gdy wynikiem będzie wskaźnik, sprawdź czy nie jest on nullptr zanim zaczniesz odwoływać się do obiektu pod nim. To tylko najczęściej powtarzające się sytuacje, gdzie należy stosować ASSERT. Z pewnością jest ich więcej.Porównywanie float’ów bez precyzjiReprezentacja liczb zmiennoprzecinkowych przez komputer nie jest doskonała i wie to każdy doświadczony programista. Porównywanie wartości typu float czy double ze sobą nie jest takie proste jak liczb całkowitych. Weryfikacja testu odbywa się właśnie przez porównanie, a wyniki zapisane w liczbach zmiennoprzecinkowych mogą się nieznacznie różnić od tych oczekiwanych.Dlaczego tak się dzieje?Spora część liczb zmiennoprzecinkowych nie ma idealnej reprezentacji w systemie binarnym. Dlatego komputer musi zaokrąglać wyliczoną wartość do najbliższej zero-jedynkowej wartości. Jest nawet na to określony standard “IEEE 754”. Właśnie ze względu na te zaokrąglenia, porównywanie wartości zmiennoprzecinkowych, może dać fałszywe wyniki. Dlatego stosuje się porównywanie z tolerancją, tak zwany epsilon.To mi przypomina moje początki nauki pisania unit testów i pracy z Google Test. Tak, mniej więcej, wyglądał jeden z moich pierwszych unit testów w zakresie weryfikacji wyniku zapisanego właśnie w double.TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr){    const std::complex&lt;double&gt; sample { 1.0, 0.0 };    const double noise { 0.394 };      const auto resultLlr { llr16QamIMsb(sample, noise) };    EXPECT_EQ(5.0761421319796952, resultLlr);}Teraz, gdy o tym myślę, chce mi się śmiać, ale kto nie popełnia błędów? Ten kto nic nie robi ;) Dziś sobie z przed lat powiedziałbym co trzeba zrobić w takim przypadku, poprawilibyśmy ten test i wyglądałby następująco.TEST(DemodulationTests, llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr){    const std::complex&lt;double&gt; sample { 1.0, 0.0 };    const double noise { 0.394 };      const auto resultLlr { llr16QamIMsb(sample, noise) };    EXPECT_NEAR(5.07614, resultLlr, 0.00001);}Zmieniła się tylko sama asercja i z pewnością test stał się niewrażliwy na zmianę platformy, która ma inną precyzję operacji na liczbach zmiennoprzecinkowych. Dodatkowo dzięki właśnie EXPECT_NEAR możemy jasno określić tolerancję, czyli już wcześniej wspomniany epsilon.Logika w MockuWraz z Google Test dostajemy również Google Mock, jest on dodawany jako osobny nagłówek gmock.h. Mock to w tłumaczeniu na polski - makieta. Czyli, w kontekście programowania obiektowego, coś co tylko udaje implementację klasy. Nieraz jednak widziałem, mocki, które przysłaniały tylko część metod, pozostawiając lub nadpisując implementację klasy, z której dziedziczyły.Możemy podejść do mockowania na przynajmniej dwa sposoby. Pierowysz to bazowanie na interfejsie. Wprowadzamy klasę czysto abstrakcyjną, do której nasza testowana klasa się odwołuje, nie znając prawdziwej wersji implementacji.Poniżej przykład interfejsu RenderSceneBuilder. Klasa ta ma za zadanie budowanie sceny gry złożonej z obiektów klasy RenderItem (również interfejs) w oparciu o strukturę SceneUdate.class RenderSceneBuilder{public:    virtual ~RenderSceneBuilder() = default;    virtual auto build(const SceneUpdate&amp; sceneUpdate) -&gt; void = 0;    virtual auto popRenderItems() -&gt; RenderItems = 0;};A tutaj przykład jego wykorzystania (uproszczony by nie zaciemniać obrazu).class SfmlWindow{public:    SfmlWindow(        //...        std::unique_ptr&lt;RenderSceneBuilder&gt; inputSceneBuilder = nullptr        //...    );    //...    virtual auto update(const SceneUpdate&amp; sceneUpdate) override -&gt; void;private:    //...    std::unique_ptr&lt;RenderSceneBuilder&gt; sceneBuilder;    //...};Teraz utworzymy mocka z interfejsu, MockRenderSceneBuilder.class MockRenderSceneBuilder : public RenderSceneBuilder{public:    MOCK_METHOD(void, build, (const SceneUpdate&amp;), (override));    MOCK_METHOD(RenderItems, popRenderItems, (), (override));};W tym przypadku klasa mocka przysłania tylko interfejs i wszystko mamy czyste. Wstrzykujemy mocka do naszej testowanej klasy poprzez konstruktor i voilà!Drugi sposób - do destruktora oraz wszystkich publicznych metod klasy, którą chcemy zamockować dodajemy virtual. Dla przykładu mamy klasę GameSession.class GameSession{public:    explicit GameSession(std::unique_ptr&lt;SceneItemFactory&gt; inputFactory = nullptr);    virtual ~GameSession() = default;    virtual auto addPlayer() -&gt; PlayerID;    virtual auto removePlayer(const PlayerID&amp; playerId) -&gt; void;    virtual auto queuePlayerStatus(const PlayerID&amp; playerId, const PlayerStatus&amp; playerStatus) -&gt; void;    virtual auto updateGameWorld() -&gt; void;    virtual auto getUpdateForPlayer(const PlayerID&amp; playerId) const -&gt; GameplayUpdate;private:    //...};I mockujemy.class MockGameSession : public GameSession{public:    MockGameSession() = default;    MOCK_METHOD(PlayerID, addPlayer, (), (override));    MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override));    MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override));    MOCK_METHOD(void, updateGameWorld, (), (override));    MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override));};Jeśli pozostawimy część publicznych metod jako niewirtualne i nie przysłonimy ich w mocku to nie odcinamy w pełni zależności między naszą testowaną klasą, a klasą zmockowaną. Taki test de facto nie jest już unit testem lecz czymś w rodzaju karykatury module testu. Poniżej przykładclass MockGameSession : public GameSession{public:    MockGameSession() = default;    MOCK_METHOD(PlayerID, addPlayer, (), (override));    MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override));    MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override));    MOCK_METHOD(void, updateGameWorld, (), (override));    GameplayUpdate getUpdateForPlayer(const PlayerID&amp;) const override    {        // Generuje losowe wartości i wypełnia nimi GameplayUpdate    } };W przypadku, gdy dopisujemy jakąś część logiki w kodzie mocka ograniczamy widoczność tych operacji w naszych testach. Mock sam z siebie nie powinien nic robić. Służy on do weryfikacji zachowania naszej testowanej klasy, tj. jego interakcji z mockowaną klasą. Jeśli potrzebujemy, by nasz mock reagował na te interakcje Google Mock udostępnia szereg narzędzi jak ON_CALL i EXPECT_CALL z odpowiednią kombinacją na przykład WillOnce i Invoke (są też inne metody na sterowanie zachowaniem mocka). Wtedy wszystko jest zapisane w naszym unit teście, w bloku “Arrange”.Testowanie MockaJak już wspomniałem mocki służą do weryfikacji interakcji z naszą testowaną klasą. Spotkałem się jednak z innym sposobem wykorzystywania mocków w unit testach. Kiedy nie znamy dobrych podstaw pisania unit testów (o których jeszcze napiszę ;) ), mogą powstać naprawdę dziwne rzeczy.W unit testach widziałem wiele nietypowych konstrukcji, i w rzeczy samej testowanie mocka jest jedną z nich. Chcąc odciąć jakąś zależność możemy zastosować mocka, aby przysłonić część implementacji lub wręcz zastąpić ją inną. Co de facto mija się z celem testowania.Dla przykładu, mamy mocka klasy MockGameSession z poprzedniego punktu. Tym razem jak najbardziej poprawnego.class MockGameSession : public GameSession{public:    MockGameSession() = default;    MOCK_METHOD(PlayerID, addPlayer, ());    MOCK_METHOD(void, removePlayer, (const PlayerID&amp;));    MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;));    MOCK_METHOD(void, updateGameWorld, ());    MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const));    MOCK_METHOD(Texture, getTexture, (const std::string), (const)); // metoda protected w GameSession};Natomiast w unit testach chcemy przetestować metodę addPlayer klasy GameSession, jednak korzysta ona z metody getTexture odczytującej teksturę gracza z pliku. W takim przypadku moglibyśmy zastosować “Wrapper” lub wprowadzić osobny obiekt klasy Factory i zacmokocwać ją stosująć Dependency Injection. Jednak nie znając jeszcze tych technik możemy pokusić się o użycie mocka w taki sposób, by podczas testowania metody addPlayer przysłonić tylko metodę getTexture, która to odpowiedzialna jest za odczyt pliku.TEST_F(GameSessionTests, addPlayer_OneNewPlayer_ReturnNewPlayerId){    auto factory { std::make_unique&lt;MockSceneItemFactory&gt;() };    EXPECT_CALL(*factory, create(_, _, _));    MockGameSession gameSession { std::move(factory) };    EXPECT_CALL(gameSession, getTexture(_)).WillOnce(Return(Texture())); // Mockowanie zależności odczytu z pliku    EXPECT_CALL(gameSession, addPlayer()).WillOnce(Invoke([&amp;](){ // Mockowana metoda wykonuje tą prawdziwą        return gameSession.GameSession::addPlayer();    }));    const auto resultPlayerId { gameSession.addPlayer() }; // Wywołanie mockowanej metody    EXPECT_EQ(0, resultPlayerId);}Dlaczego uważam to za fatalny pomysł? W końcu działa…No cóż to tak jakby używać spawarki do wbijania gwoździ, no niby da się tylko po co? Mocki zostały wymyślone po to by odcinać zależności między klasami, a nie do grzebania w implementacji naszej testowanej klasy. Gdy widzę test, w którym nie ma normalnej klasy, tylko same mocki to coś tu jest nie tak.Taki test jest bardzo nieczytelny. Gdy dodamy do tego enigmatyczną nazwę to praktycznie na pierwszy czy nawet drugi rzut oka, nie jesteśmy w stanie stwierdzić, która klasa jest testowana. W GoogleTest są oczywiście nazwa test suity, która może w tym przypadku podpowiedzieć to i owo, niemniej, czytelność i tak spada diametralnie.Używajmy narzędzi zgodnie z ich pierwotnym przeznaczeniem, zwłaszcza podczas testowania. Dbamy tym samym o wysoką czytelność i przejrzystość w naszych unit testach.Brak override w mockachSłowo kluczowe (a dokładnie specyfikator) override możemy stosować również w mockowanych metodach i działa ono dokładnie tak samo jak w zwykłych klasach. W MOCK_METHOD na końcu, w sekcji gdzie dodajemy kwalifikatory i specyfikatory. Dla przykładu, wróćmy do MockGameSession.class MockGameSession : public GameSession{public:    MockGameSession() = default;    MOCK_METHOD(PlayerID, addPlayer, ());    MOCK_METHOD(void, removePlayer, (const PlayerID&amp;));    MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;));    MOCK_METHOD(void, updateGameWorld, ());    MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const));};Jeśli w takim przypadku metoda removePlayer w klasie GameSession nie będzie wirtualna, kompilator i tak nie zwróci błędu. Kod skompiluje się, a my będziemy zachodzić w głowę czemu nasz mock nie jest wywoływany.Użycie override eliminuje problem. W przypadku, gdy dodamy ten specyfikator, a metoda w klasie bazowej nie będzie wirtualna, kompilator zwróci błąd. Tak jak na poniższym przykładzie.Tutaj już poprawiony mock.class MockGameSession : public GameSession{public:    MockGameSession() = default;    MOCK_METHOD(PlayerID, addPlayer, (), (override));    MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override));    MOCK_METHOD(void, queuePlayerStatus, (const PlayerID&amp;, const PlayerStatus&amp;), (override));    MOCK_METHOD(void, updateGameWorld, (), (override));    MOCK_METHOD(GameplayUpdate, getUpdateForPlayer, (const PlayerID&amp;), (const, override));};Oraz błąd zwracany przez kompilator./.../MockGameSession.hpp:16:23: error: &#39;testing::internal::Function&lt;void(const int&amp;)&gt;::Result MockGameSession::removePlayer(testing::internal::ElemFromList&lt;0, const int&amp;&gt;::type)&#39; marked &#39;override&#39;, but does not override   16 |     MOCK_METHOD(void, removePlayer, (const PlayerID&amp;), (override));      | PodsumowanieTo już wszystko w tym wpisie. Mam nadzieję, że będzie dla Ciebie choć trochę pomocny w zmaganiach z Google Test’em. Czy któryś z wymienionych w tym wpisie błędów Cię zaskoczył? Może inny jest dość znajomy? Daj znać w komentarzu! Popełnianie błędów jest czymś normalnym. Ważne by się rozwijać i uczyć od siebie nawzajem. Jeśli znasz inne przypadki, chętnie się z nimi zapoznam. Możesz również napisać do mnie email lub wysłać wiadomość na LinkedIn. Będzie mi bardzo miło :)Autor: Tadeusz BielaProgramista C++ | Entuzjasta TDD | Fan unit testówLinkedIn">
    <meta itemprop="datePublished" content="2026-01-26T00:00:00+01:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://cpptested.com/clean%20code/gtest-mistakes/" itemprop="url">6 najczęstszych błędów z Google Test.
</a>
          </h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2026-01-26T00:00:00+01:00">26 stycznia 2026</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          11 minut(y)
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Spis treści</h4></header>
              <ul class="toc__menu"><li><a href="#kolejność-parametrów-asercji">Kolejność parametrów asercji</a></li><li><a href="#używanie-expect-zamiast-assert">Używanie EXPECT zamiast ASSERT</a></li><li><a href="#porównywanie-floatów-bez-precyzji">Porównywanie float’ów bez precyzji</a></li><li><a href="#logika-wmocku">Logika w Mocku</a></li><li><a href="#testowanie-mocka">Testowanie Mocka</a></li><li><a href="#brak-override-w-mockach">Brak override w mockach</a></li><li><a href="#podsumowanie">Podsumowanie</a></li></ul>
            </nav>
          </aside>
        
        <p>Google Test to chyba najbardziej znany i używany framework testowy w projektach C++. Zawiera w sobie masę przydatnych narzędzi do tworzenia różnych rodzajów testów. Ja osobiście stosuję go w swoich projektach pisząc unit testy, ale nic nie stoi na przeszkodzie by tworzyć testy modułowe czy komponentowe (typu black box). Ceniony za swą uniwersalność oraz rozbudowany system asercji jest narzędziem bardzo potężnym. Mimo to nie jest również bez wad. Im bardziej złożone jest narzędzie tym trudniej się go nauczyć i korzystać z niego poprawnie.</p>

<p>Popełniamy błędy. To normalne, ważne jest co z tym zrobimy. Warto wyciągnąć z nich lekcje na przyszłość. Poniższa lista to nic innego jak moje własne obserwacje, jak programiści C++(w tym ja) wykorzystują <strong>GTest</strong> i gdzie najczęściej popełniają błędy.</p>

<h3 id="kolejność-parametrów-asercji">Kolejność parametrów asercji</h3>

<p>Czy kolejność w asercji typu EXPECT_EQ jest ważna? Owszem! Choć nie wynika ona z samej definicji makra w nagłówku <strong>gtest.h</strong>. Wspomniana definicja wygląda następująco.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define EXPECT_EQ(val1, val2) \
  EXPECT_PRED_FORMAT2(::testing::internal::EqHelper::Compare, val1, val2)
</span></code></pre></div></div>

<p>Sam Google Test nie informuje gdzie ma być umieszczona wartość oczekiwania, a gdzie wynikowa. Skąd więc założenie, że wartość <strong>expected</strong> powinna być pierwsza? Głównie z przykładów z repozytorium Google Test.</p>

<p>Przykład z folderu <strong>samples</strong> repozytorium Google Test, a dokładnie ten <a href="https://github.com/google/googletest/blob/main/googletest/samples/sample4_unittest.cc" target="_blank" rel="noopener">“sample4_unittest”</a>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST</span><span class="p">(</span><span class="n">Counter</span><span class="p">,</span> <span class="n">Increment</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Counter</span> <span class="n">c</span><span class="p">;</span>

  <span class="c1">// Test that counter 0 returns 0</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">Decrement</span><span class="p">());</span>

  <span class="c1">// EXPECT_EQ() evaluates its arguments exactly once, so they</span>
  <span class="c1">// can have side effects.</span>

  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">Increment</span><span class="p">());</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">Increment</span><span class="p">());</span>
  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">Increment</span><span class="p">());</span>

  <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">c</span><span class="p">.</span><span class="n">Decrement</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Oczywiście jest ich znacznie więcej.</p>

<p>Są dwa powody dlaczego warto najpierw podawać wartość oczekiwaną, a potem wynikową.</p>

<ol>
  <li>Czytelność - przeglądając test, czytamy linijkę od lewej do prawej. Gdy wartością oczekiwaną jest po prostu stałą liczbową lub tekstową, szybciej dowiemy się co jest oczekiwane względem testowanej metody.</li>
  <li>Spójność z warunkami w kodzie - znasz ten ból, gdy w <strong>if</strong> zamiast użyć operatora porównania <strong>==</strong>, użyłeś operator przypisania <strong>=</strong>? Ja tak, dlatego warto najpierw wartość oczekiwaną podawać jako pierwszą. Jeśli jest to stała, kompilator szybko poinformuje nas o pomyłce.</li>
</ol>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">if</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">)</span> <span class="c1">// Kompilator nie zgłosi błędu</span>

<span class="k">if</span><span class="p">(</span><span class="mi">5</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span> <span class="c1">// a tutaj już tak</span>

</code></pre></div></div>

<p>Logika jest zachowana ale zwiększa się odporność na błędy.</p>

<p>To która wersja będzie poprawna?</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">resultValue</span><span class="p">,</span> <span class="n">expectedValue</span><span class="p">);</span> <span class="c1">// Ta?</span>
<span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedValue</span><span class="p">,</span> <span class="n">resultValue</span><span class="p">);</span> <span class="c1">// czy ta?</span>
</code></pre></div></div>

<p>Tak naprawdę - to zależy. Choć sama kolejność jest sugerowana przykładami, nie jest ona napisana wprost. Którą więc wybrać? Jeśli wchodzisz do projektu, gdzie pierwsza wartość to ta wynikowa. Dostosuj się do konwencji już panującej w projekcie. Jeśli to nowy projekt, lub brak jest spójnej konwencji, wybierz wersję, gdzie wartość oczekiwana podawana jest jako pierwsza.</p>

<h3 id="używanie-expect-zamiast-assert">Używanie EXPECT zamiast ASSERT</h3>

<p>Ten błąd może kosztować życie (naszego wątku uruchamiającego testy). Dlaczego? Najpierw omówmy różnicę w zachowaniu <strong>EXPECT_EQ</strong> i <strong>ASSERT_EQ</strong> (lub dowolnej innej pary tych typów asercji). Obie asercje mają za zadanie sprawdzać czy dana wartość zgadza się z oczekiwaną. Różnica polega na tym co wydarzy się w przypadku niepowodzenia asercji. <strong>EXPECT</strong> spowoduje, że test nie zostanie zaliczony, wypisze komunikat i przejdzie do następnej linii testu.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">WidgetFactoryTests</span><span class="p">,</span> <span class="n">create_ButtonWidgetType_ReturnButtonWidget</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">Rect</span> <span class="n">expectedRect</span> <span class="p">{</span> <span class="mi">300</span><span class="p">,</span> <span class="mi">400</span><span class="p">,</span> <span class="mi">120</span><span class="p">,</span> <span class="mi">30</span> <span class="p">};</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expectedText</span> <span class="p">{</span> <span class="s">"Test Button"</span> <span class="p">};</span>
    <span class="n">WidgetFactory</span> <span class="n">factory</span> <span class="p">{};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">resultWidget</span> <span class="p">{</span> <span class="n">factory</span><span class="p">.</span><span class="n">create</span><span class="p">(</span><span class="n">WidgetType</span><span class="o">::</span><span class="n">BUTTON</span><span class="p">,</span> <span class="n">expectedRect</span><span class="p">,</span> <span class="n">expectedText</span><span class="p">)};</span>

    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">WidgetType</span><span class="o">::</span><span class="n">LABEL</span><span class="p">,</span> <span class="n">resultWidget</span><span class="p">.</span><span class="n">getType</span><span class="p">());</span> <span class="c1">// Ta asercja się nie powiedzie</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedRect</span><span class="p">,</span> <span class="n">resultWidget</span><span class="p">.</span><span class="n">getRect</span><span class="p">());</span> <span class="c1">// Ta i następna zostaną wywołane</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">expectedText</span><span class="p">,</span> <span class="n">resultWidget</span><span class="p">.</span><span class="n">getText</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>ASSERT</strong> również spowoduje fail testu, wypisze komunikat, ale już nie przejdzie dalej do kolejnej części testu. Test zostaje przerwany w tym miejscu i dalej nie będzie kontynuowany.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">WidgetsFactorySfmlTests</span><span class="p">,</span> <span class="n">create_LabelType_CreateLabelWidget</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">sfmlWindow</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">MockSfmlWindow</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">sfmlWindow</span><span class="p">,</span> <span class="n">getRenderTarget</span><span class="p">()).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnRef</span><span class="p">(</span><span class="n">getWindow</span><span class="p">()));</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">sfmlWindow</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">_</span><span class="p">));</span>
    <span class="n">WidgetsFactorySfml</span> <span class="n">factory</span> <span class="p">{</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">sfmlWindow</span><span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">resultWidget</span> <span class="p">{</span>
        <span class="n">factory</span><span class="p">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">WidgetType</span><span class="o">::</span><span class="n">LABEL</span><span class="p">,</span>
            <span class="n">WidgetGeometry</span> <span class="p">{},</span>
            <span class="n">WidgetText</span> <span class="p">{},</span>
            <span class="n">WidgetStyle</span> <span class="p">{}</span>
        <span class="p">)</span>
    <span class="p">};</span> <span class="c1">// Jeśli ta metoda zwróci nullptr</span>

    <span class="n">ASSERT_TRUE</span><span class="p">(</span><span class="n">resultWidget</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span> <span class="c1">// to ta asercja się nie powiedzie i test przerywa wykonywanie.</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">WidgetType</span><span class="o">::</span><span class="n">LABEL</span><span class="p">,</span> <span class="n">resultWidget</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span> <span class="c1">// Ta i następna asercja nie zostaną wywołane</span>
    <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">LabelWidget</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">resultWidget</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Co nam to daje? Bardzo wiele, zwłaszcza gdy kolejne asercje opierają się na naszym <strong>ASSERT</strong>. Jeśli zastosujemy zwykły <strong>EXPECT</strong> to test zakończy swoje działanie poprzez brutalne przerwanie w stylu segfaulta.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">WidgetsFactorySfmlTests</span><span class="p">,</span> <span class="n">create_LabelType_CreateLabelWidget</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">sfmlWindow</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">MockSfmlWindow</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">sfmlWindow</span><span class="p">,</span> <span class="n">getRenderTarget</span><span class="p">()).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">ReturnRef</span><span class="p">(</span><span class="n">getWindow</span><span class="p">()));</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">sfmlWindow</span><span class="p">,</span> <span class="n">add</span><span class="p">(</span><span class="n">_</span><span class="p">));</span>
    <span class="n">WidgetsFactorySfml</span> <span class="n">factory</span> <span class="p">{</span> <span class="nb">nullptr</span><span class="p">,</span> <span class="n">sfmlWindow</span><span class="p">,</span> <span class="nb">nullptr</span> <span class="p">};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">resultWidget</span> <span class="p">{</span>
        <span class="n">factory</span><span class="p">.</span><span class="n">create</span><span class="p">(</span>
            <span class="n">WidgetType</span><span class="o">::</span><span class="n">LABEL</span><span class="p">,</span>
            <span class="n">WidgetGeometry</span> <span class="p">{},</span>
            <span class="n">WidgetText</span> <span class="p">{},</span>
            <span class="n">WidgetStyle</span> <span class="p">{}</span>
        <span class="p">)</span>
    <span class="p">};</span> 

    <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">resultWidget</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span> <span class="c1">// zamiast ASSERT jest EXPECT</span>
    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">WidgetType</span><span class="o">::</span><span class="n">LABEL</span><span class="p">,</span> <span class="n">resultWidget</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">());</span>
    <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">LabelWidget</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">resultWidget</span><span class="p">.</span><span class="n">get</span><span class="p">())</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Test nie przejdzie, na dodatek, jeśli w naszej suicie będzie więcej testów i miały być one uruchomione po tym, to do tego nie dojdzie. Cały wątek z naszą suitą zostanie przerwany. Czyli inne testy nawet się nie wykonają.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span> RUN      <span class="o">]</span> WidgetsFactorySfmlTests.create_LabelType_CreateLabelWidget
Setting vertical <span class="nb">sync </span>not supported
/usr/src/heisttown/src/Sfml/SfmlWidgets/Tests/WidgetsFactorySfmlTests.cpp:42: Failure
Value of: resultWidget <span class="o">!=</span> nullptr
  Actual: <span class="nb">false
</span>Expected: <span class="nb">true</span>
</code></pre></div></div>

<p>W tym przypadku mamy chociaż informacje co poszło nie tak. Jeśli nie dodalibyśmy, w ogóle asercji na sprawdzanie czy <strong>resultWidget</strong> nie jest <strong>nullptr</strong>, nie wiedzielibyśmy nic. Dlatego ważne jest, aby stosować <strong>ASSERT</strong> czy <strong>EXPECT</strong> zgodnie z ich przeznaczeniem.</p>

<p>Dlaczego więc nie stosować <strong>ASSERT</strong> zawsze? Jak już pisałem, <strong>ASSERT</strong> zatrzymuje test, dalsza jego część nie jest weryfikowana. Jeśli następne asercje nie są zależne od poprzednich to, w takim przypadku zostaną pominięte i nie będziemy wiedzieli, czy tylko ta jedna asercja nie została spełniona, czy cały ich szereg. Obraz sytuacji będzie niekompletny.</p>

<p>Jeśli oczekiwanym wynikiem może być kontener to sprawdź jego rozmiar <strong>ASSERT</strong>em zanim zaczniesz weryfikować jego konkretne elementy. Albo, gdy wynikiem będzie wskaźnik, sprawdź czy nie jest on <strong>nullptr</strong> zanim zaczniesz odwoływać się do obiektu pod nim. To tylko najczęściej powtarzające się sytuacje, gdzie należy stosować <strong>ASSERT</strong>. Z pewnością jest ich więcej.</p>

<h3 id="porównywanie-floatów-bez-precyzji">Porównywanie float’ów bez precyzji</h3>

<p>Reprezentacja liczb zmiennoprzecinkowych przez komputer nie jest doskonała i wie to każdy doświadczony programista. Porównywanie wartości typu <strong>float</strong> czy <strong>double</strong> ze sobą nie jest takie proste jak liczb całkowitych. Weryfikacja testu odbywa się właśnie przez porównanie, a wyniki zapisane w liczbach zmiennoprzecinkowych mogą się nieznacznie różnić od tych oczekiwanych.</p>

<p>Dlaczego tak się dzieje?</p>

<p>Spora część liczb zmiennoprzecinkowych nie ma idealnej reprezentacji w systemie binarnym. Dlatego komputer musi zaokrąglać wyliczoną wartość do najbliższej zero-jedynkowej wartości. Jest nawet na to określony standard <a href="https://pl.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">“IEEE 754”</a>. Właśnie ze względu na te zaokrąglenia, porównywanie wartości zmiennoprzecinkowych, może dać fałszywe wyniki. Dlatego stosuje się porównywanie z tolerancją, tak zwany <strong>epsilon</strong>.</p>

<p>To mi przypomina moje początki nauki pisania unit testów i pracy z Google Test. Tak, mniej więcej, wyglądał jeden z moich pierwszych unit testów w zakresie weryfikacji wyniku zapisanego właśnie w <strong>double</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST</span><span class="p">(</span><span class="n">DemodulationTests</span><span class="p">,</span> <span class="n">llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">sample</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">};</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">noise</span> <span class="p">{</span> <span class="mf">0.394</span> <span class="p">};</span>
  
    <span class="k">const</span> <span class="k">auto</span> <span class="n">resultLlr</span> <span class="p">{</span> <span class="n">llr16QamIMsb</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">noise</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mf">5.0761421319796952</span><span class="p">,</span> <span class="n">resultLlr</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Teraz, gdy o tym myślę, chce mi się śmiać, ale kto nie popełnia błędów? Ten kto nic nie robi ;) Dziś sobie z przed lat powiedziałbym co trzeba zrobić w takim przypadku, poprawilibyśmy ten test i wyglądałby następująco.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST</span><span class="p">(</span><span class="n">DemodulationTests</span><span class="p">,</span> <span class="n">llr16QamIMsb_PositiveRealSampleValueAndPositiveNoise_ReturnCorrectLlr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">sample</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span> <span class="p">};</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">noise</span> <span class="p">{</span> <span class="mf">0.394</span> <span class="p">};</span>
  
    <span class="k">const</span> <span class="k">auto</span> <span class="n">resultLlr</span> <span class="p">{</span> <span class="n">llr16QamIMsb</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">noise</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">EXPECT_NEAR</span><span class="p">(</span><span class="mf">5.07614</span><span class="p">,</span> <span class="n">resultLlr</span><span class="p">,</span> <span class="mf">0.00001</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Zmieniła się tylko sama asercja i z pewnością test stał się niewrażliwy na zmianę platformy, która ma inną precyzję operacji na liczbach zmiennoprzecinkowych. Dodatkowo dzięki właśnie <strong>EXPECT_NEAR</strong> możemy jasno określić tolerancję, czyli już wcześniej wspomniany <strong>epsilon</strong>.</p>

<h3 id="logika-wmocku">Logika w Mocku</h3>

<p>Wraz z Google Test dostajemy również Google Mock, jest on dodawany jako osobny nagłówek <strong>gmock.h</strong>. Mock to w tłumaczeniu na polski - makieta. Czyli, w kontekście programowania obiektowego, coś co tylko udaje implementację klasy. Nieraz jednak widziałem, mocki, które przysłaniały tylko część metod, pozostawiając lub nadpisując implementację klasy, z której dziedziczyły.</p>

<p>Możemy podejść do mockowania na przynajmniej dwa sposoby. Pierowysz to bazowanie na interfejsie. Wprowadzamy klasę czysto abstrakcyjną, do której nasza testowana klasa się odwołuje, nie znając prawdziwej wersji implementacji.</p>

<p>Poniżej przykład interfejsu <strong>RenderSceneBuilder</strong>. Klasa ta ma za zadanie budowanie sceny gry złożonej z obiektów klasy <strong>RenderItem</strong> (również interfejs) w oparciu o strukturę <strong>SceneUdate</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">RenderSceneBuilder</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">RenderSceneBuilder</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">build</span><span class="p">(</span><span class="k">const</span> <span class="n">SceneUpdate</span><span class="o">&amp;</span> <span class="n">sceneUpdate</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">popRenderItems</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">RenderItems</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>A tutaj przykład jego wykorzystania (uproszczony by nie zaciemniać obrazu).</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">SfmlWindow</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">SfmlWindow</span><span class="p">(</span>
        <span class="c1">//...</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RenderSceneBuilder</span><span class="o">&gt;</span> <span class="n">inputSceneBuilder</span> <span class="o">=</span> <span class="nb">nullptr</span>
        <span class="c1">//...</span>
    <span class="p">);</span>

    <span class="c1">//...</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">update</span><span class="p">(</span><span class="k">const</span> <span class="n">SceneUpdate</span><span class="o">&amp;</span> <span class="n">sceneUpdate</span><span class="p">)</span> <span class="k">override</span> <span class="o">-&gt;</span> <span class="kt">void</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="c1">//...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">RenderSceneBuilder</span><span class="o">&gt;</span> <span class="n">sceneBuilder</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Teraz utworzymy mocka z interfejsu, <strong>MockRenderSceneBuilder</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MockRenderSceneBuilder</span> <span class="o">:</span> <span class="k">public</span> <span class="n">RenderSceneBuilder</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">build</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">SceneUpdate</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">RenderItems</span><span class="p">,</span> <span class="n">popRenderItems</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</code></pre></div></div>

<p>W tym przypadku klasa mocka przysłania tylko interfejs i wszystko mamy czyste. Wstrzykujemy mocka do naszej testowanej klasy poprzez konstruktor i voilà!</p>

<p>Drugi sposób - do destruktora oraz wszystkich publicznych metod klasy, którą chcemy zamockować dodajemy <strong>virtual</strong>. Dla przykładu mamy klasę <strong>GameSession</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GameSession</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">GameSession</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">SceneItemFactory</span><span class="o">&gt;</span> <span class="n">inputFactory</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">GameSession</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">addPlayer</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">PlayerID</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">removePlayer</span><span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span> <span class="n">playerId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">queuePlayerStatus</span><span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span> <span class="n">playerId</span><span class="p">,</span> <span class="k">const</span> <span class="n">PlayerStatus</span><span class="o">&amp;</span> <span class="n">playerStatus</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">updateGameWorld</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="kt">void</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">auto</span> <span class="n">getUpdateForPlayer</span><span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span> <span class="n">playerId</span><span class="p">)</span> <span class="k">const</span> <span class="o">-&gt;</span> <span class="n">GameplayUpdate</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>I mockujemy.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MockGameSession</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameSession</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MockGameSession</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">PlayerID</span><span class="p">,</span> <span class="n">addPlayer</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">removePlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">queuePlayerStatus</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">PlayerStatus</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">updateGameWorld</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">GameplayUpdate</span><span class="p">,</span> <span class="n">getUpdateForPlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span><span class="p">,</span> <span class="k">override</span><span class="p">));</span>
<span class="p">};</span>

</code></pre></div></div>

<p>Jeśli pozostawimy część publicznych metod jako niewirtualne i nie przysłonimy ich w mocku to nie odcinamy w pełni zależności między naszą testowaną klasą, a klasą zmockowaną. Taki test de facto nie jest już unit testem lecz czymś w rodzaju karykatury module testu. Poniżej przykład</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MockGameSession</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameSession</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MockGameSession</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">PlayerID</span><span class="p">,</span> <span class="n">addPlayer</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">removePlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">queuePlayerStatus</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">PlayerStatus</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">updateGameWorld</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">GameplayUpdate</span> <span class="n">getUpdateForPlayer</span><span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="c1">// Generuje losowe wartości i wypełnia nimi GameplayUpdate</span>
    <span class="p">}</span> 
<span class="p">};</span>
</code></pre></div></div>

<p>W przypadku, gdy dopisujemy jakąś część logiki w kodzie mocka ograniczamy widoczność tych operacji w naszych testach. Mock sam z siebie nie powinien nic robić. Służy on do weryfikacji zachowania naszej testowanej klasy, tj. jego interakcji z mockowaną klasą. Jeśli potrzebujemy, by nasz mock reagował na te interakcje Google Mock udostępnia szereg narzędzi jak <strong>ON_CALL</strong> i <strong>EXPECT_CALL</strong> z odpowiednią kombinacją na przykład <strong>WillOnce</strong> i <strong>Invoke</strong> (są też inne metody na sterowanie zachowaniem mocka). Wtedy wszystko jest zapisane w naszym unit teście, w bloku <a href="https://cpptested.com/unit%20testing/AAA-golden-standard/" target="_blank" rel="noopener">“Arrange”</a>.</p>

<h3 id="testowanie-mocka">Testowanie Mocka</h3>

<p>Jak już wspomniałem mocki służą do weryfikacji interakcji z naszą testowaną klasą. Spotkałem się jednak z innym sposobem wykorzystywania mocków w unit testach. Kiedy nie znamy dobrych podstaw pisania unit testów (o których jeszcze napiszę ;) ), mogą powstać naprawdę dziwne rzeczy.</p>

<p>W unit testach widziałem wiele nietypowych konstrukcji, i w rzeczy samej testowanie mocka jest jedną z nich. Chcąc odciąć jakąś zależność możemy zastosować mocka, aby przysłonić część implementacji lub wręcz zastąpić ją inną. Co de facto mija się z celem testowania.</p>

<p>Dla przykładu, mamy mocka klasy <strong>MockGameSession</strong> z poprzedniego punktu. Tym razem jak najbardziej poprawnego.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MockGameSession</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameSession</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MockGameSession</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">PlayerID</span><span class="p">,</span> <span class="n">addPlayer</span><span class="p">,</span> <span class="p">());</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">removePlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">queuePlayerStatus</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">PlayerStatus</span><span class="o">&amp;</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">updateGameWorld</span><span class="p">,</span> <span class="p">());</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">GameplayUpdate</span><span class="p">,</span> <span class="n">getUpdateForPlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">Texture</span><span class="p">,</span> <span class="n">getTexture</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span><span class="p">));</span> <span class="c1">// metoda protected w GameSession</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Natomiast w unit testach chcemy przetestować metodę <strong>addPlayer</strong> klasy <strong>GameSession</strong>, jednak korzysta ona z metody <strong>getTexture</strong> odczytującej teksturę gracza z pliku. W takim przypadku moglibyśmy zastosować <a href="https://cpptested.com/unit%20testing/handling-globals/" target="_blank" rel="noopener">“Wrapper”</a> lub wprowadzić osobny obiekt klasy <strong>Factory</strong> i zacmokocwać ją stosująć Dependency Injection. Jednak nie znając jeszcze tych technik możemy pokusić się o użycie mocka w taki sposób, by podczas testowania metody <strong>addPlayer</strong> przysłonić tylko metodę <strong>getTexture</strong>, która to odpowiedzialna jest za odczyt pliku.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">GameSessionTests</span><span class="p">,</span> <span class="n">addPlayer_OneNewPlayer_ReturnNewPlayerId</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">factory</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">MockSceneItemFactory</span><span class="o">&gt;</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="o">*</span><span class="n">factory</span><span class="p">,</span> <span class="n">create</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">));</span>
    <span class="n">MockGameSession</span> <span class="n">gameSession</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">factory</span><span class="p">)</span> <span class="p">};</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">gameSession</span><span class="p">,</span> <span class="n">getTexture</span><span class="p">(</span><span class="n">_</span><span class="p">)).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="n">Texture</span><span class="p">()));</span> <span class="c1">// Mockowanie zależności odczytu z pliku</span>
    <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">gameSession</span><span class="p">,</span> <span class="n">addPlayer</span><span class="p">()).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Invoke</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span> <span class="c1">// Mockowana metoda wykonuje tą prawdziwą</span>
        <span class="k">return</span> <span class="n">gameSession</span><span class="p">.</span><span class="n">GameSession</span><span class="o">::</span><span class="n">addPlayer</span><span class="p">();</span>
    <span class="p">}));</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">resultPlayerId</span> <span class="p">{</span> <span class="n">gameSession</span><span class="p">.</span><span class="n">addPlayer</span><span class="p">()</span> <span class="p">};</span> <span class="c1">// Wywołanie mockowanej metody</span>

    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">resultPlayerId</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dlaczego uważam to za fatalny pomysł? W końcu działa…</p>

<p>No cóż to tak jakby używać spawarki do wbijania gwoździ, no niby da się tylko po co? Mocki zostały wymyślone po to by odcinać zależności między klasami, a nie do grzebania w implementacji naszej testowanej klasy. Gdy widzę test, w którym nie ma normalnej klasy, tylko same mocki to coś tu jest nie tak.</p>

<p>Taki test jest bardzo nieczytelny. Gdy dodamy do tego enigmatyczną nazwę to praktycznie na pierwszy czy nawet drugi rzut oka, nie jesteśmy w stanie stwierdzić, która klasa jest testowana. W GoogleTest są oczywiście nazwa test suity, która może w tym przypadku podpowiedzieć to i owo, niemniej, czytelność i tak spada diametralnie.</p>

<p>Używajmy narzędzi zgodnie z ich pierwotnym przeznaczeniem, zwłaszcza podczas testowania. Dbamy tym samym o wysoką czytelność i przejrzystość w naszych unit testach.</p>

<h3 id="brak-override-w-mockach">Brak override w mockach</h3>

<p>Słowo kluczowe (a dokładnie specyfikator) <strong>override</strong> możemy stosować również w mockowanych metodach i działa ono dokładnie tak samo jak w zwykłych klasach. W <strong>MOCK_METHOD</strong> na końcu, w sekcji gdzie dodajemy kwalifikatory i specyfikatory. Dla przykładu, wróćmy do <strong>MockGameSession</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MockGameSession</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameSession</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MockGameSession</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">PlayerID</span><span class="p">,</span> <span class="n">addPlayer</span><span class="p">,</span> <span class="p">());</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">removePlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">queuePlayerStatus</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">PlayerStatus</span><span class="o">&amp;</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">updateGameWorld</span><span class="p">,</span> <span class="p">());</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">GameplayUpdate</span><span class="p">,</span> <span class="n">getUpdateForPlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span><span class="p">));</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Jeśli w takim przypadku metoda <strong>removePlayer</strong> w klasie <strong>GameSession</strong> nie będzie wirtualna, kompilator i tak nie zwróci błędu. Kod skompiluje się, a my będziemy zachodzić w głowę czemu nasz mock nie jest wywoływany.</p>

<p>Użycie <strong>override</strong> eliminuje problem. W przypadku, gdy dodamy ten specyfikator, a metoda w klasie bazowej nie będzie wirtualna, kompilator zwróci błąd. Tak jak na poniższym przykładzie.</p>

<p>Tutaj już poprawiony mock.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MockGameSession</span> <span class="o">:</span> <span class="k">public</span> <span class="n">GameSession</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MockGameSession</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">PlayerID</span><span class="p">,</span> <span class="n">addPlayer</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">removePlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">queuePlayerStatus</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">PlayerStatus</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="kt">void</span><span class="p">,</span> <span class="n">updateGameWorld</span><span class="p">,</span> <span class="p">(),</span> <span class="p">(</span><span class="k">override</span><span class="p">));</span>
    <span class="n">MOCK_METHOD</span><span class="p">(</span><span class="n">GameplayUpdate</span><span class="p">,</span> <span class="n">getUpdateForPlayer</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="n">PlayerID</span><span class="o">&amp;</span><span class="p">),</span> <span class="p">(</span><span class="k">const</span><span class="p">,</span> <span class="k">override</span><span class="p">));</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Oraz błąd zwracany przez kompilator.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/.../MockGameSession.hpp:16:23: error: <span class="s1">'testing::internal::Function&lt;void(const int&amp;)&gt;::Result MockGameSession::removePlayer(testing::internal::ElemFromList&lt;0, const int&amp;&gt;::type)'</span> marked <span class="s1">'override'</span>, but does not override
   16 |     MOCK_METHOD<span class="o">(</span>void, removePlayer, <span class="o">(</span>const PlayerID&amp;<span class="o">)</span>, <span class="o">(</span>override<span class="o">))</span><span class="p">;</span>
      | 
</code></pre></div></div>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>To już wszystko w tym wpisie. Mam nadzieję, że będzie dla Ciebie choć trochę pomocny w zmaganiach z Google Test’em. Czy któryś z wymienionych w tym wpisie błędów Cię zaskoczył? Może inny jest dość znajomy? Daj znać w komentarzu! Popełnianie błędów jest czymś normalnym. Ważne by się rozwijać i uczyć od siebie nawzajem. Jeśli znasz inne przypadki, chętnie się z nimi zapoznam. Możesz również napisać do mnie email lub wysłać wiadomość na LinkedIn. Będzie mi bardzo miło :)</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tagi: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#clean-code" class="page__taxonomy-item p-category" rel="tag">clean code</a><span class="sep">, </span>
    
      <a href="/tags/#code-quality" class="page__taxonomy-item p-category" rel="tag">code quality</a><span class="sep">, </span>
    
      <a href="/tags/#developer-practices" class="page__taxonomy-item p-category" rel="tag">developer practices</a><span class="sep">, </span>
    
      <a href="/tags/#software" class="page__taxonomy-item p-category" rel="tag">software</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Kategorie: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#clean-code" class="page__taxonomy-item p-category" rel="tag">clean code</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Ostatnia aktualizacja:</strong> <time class="dt-published" datetime="2026-01-26T00:00:00+01:00">26 stycznia 2026</time></p>

      </footer>

      <section class="page__share">
  <h4 class="page__share-title">Udostępnij</h4>

  <a href="https://x.com/intent/tweet?text=6+najcz%C4%99stszych+b%C5%82%C4%99d%C3%B3w+z%26nbsp%3BGoogle+Test.%20https%3A%2F%2Fcpptested.com%2Fclean%2520code%2Fgtest-mistakes%2F" class="btn btn--x" aria-label="Share on X" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Udostępnij X">
    <i class="fas fa-fw fa-share-alt" aria-hidden="true"></i><span> X</span>
  </a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fcpptested.com%2Fclean%2520code%2Fgtest-mistakes%2F" class="btn btn--facebook" aria-label="Share on Facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Udostępnij Facebook">
    <i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span>
  </a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://cpptested.com/clean%20code/gtest-mistakes/" class="btn btn--linkedin" aria-label="Share on LinkedIn" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Udostępnij LinkedIn">
    <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span>
  </a>
</section>


      
  <nav class="pagination">
    
      <a href="/unit-testing/handling-globals/" class="pagination--pager" title="Zależności globalne - jak poradzić sobie z nimi w unit testach">Poprzednia</a>
    
    
      <a href="#" class="pagination--pager disabled">Następna</a>
    
  </nav>


    </div>

    
      
        <div class="page__comments">
  
  
      <h4 class="page__comments-title">Zostaw komentarz</h4>
      <div class="giscus"></div>
      <script src="https://giscus.app/client.js"
              data-repo="TadekBiela/cpptested"
              data-repo-id="R_kgDOPEW3uQ"
              data-category="Announcements"
              data-category-id="DIC_kwDOPEW3uc4CsbpH"
              data-mapping="pathname"
              data-strict="0"
              data-reactions-enabled="1"
              data-emit-metadata="0"
              data-input-position="top"
              data-theme="light"
              data-lang="pl"
              crossorigin="anonymous"
              async>
      </script>
    
</div>

      
    
  </article>

  
  
    
<div class="page__related">
  
  <h2 class="page__related-title">Także może Ci się spodobać</h2>
  <div class="grid__wrapper">
    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/unit-testing/handling-globals/" rel="permalink">Zależności globalne - jak poradzić sobie z nimi w unit testach
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-12-16T00:00:00+01:00">16 grudnia 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          7 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Każdy dobry unit test powinien nie tylko weryfikować nasz kod ale również odcinać zewnętrzne zależności, tak, aby przeprowadzenie testu odbywało się w izolac...</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/clean-code/dry-and-other-principles/" rel="permalink">DRY, YAGNI, KISS i inne. Uniwersalne zasady dla każdego programisty.
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-11-17T00:00:00+01:00">17 listopada 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          12 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Te tajemnicze akronimy skrywają w sobie dekady doświadczeń naszych programistycznych poprzedników. Choć brzmi to nieco patetycznie, tak właśnie jest. Zasady,...</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/multithreading/exception-in-thread/" rel="permalink">Wątki i wyjątki. Jak radzić sobie z nieoczekiwanymi zachowaniami w wielowątkowym kodzie.
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-10-13T00:00:00+02:00">13 października 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          10 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Nieoczekiwane zachowanie czyli wyjątek to sytuacja, w której nasz kod zachował się w sposób, który normalnie nie występuje. Może być to wywołane problemami z...</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/unit-testing/AAA-golden-standard/" rel="permalink">AAA - złoty standard unit testów.
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-09-15T00:00:00+02:00">15 września 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          4 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Arrange Act Assert – to game changer dla jakości unit testów. Dzięki tym prostym zasadom testy stają się nie tylko bardziej czytelne, lecz mogą stanowić dosk...</p>
  </article>
</div>

    
  </div>
</div>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Wprowadź kryteria wyszukiwania...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Wprowadź kryteria wyszukiwania..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    <li style="justify-content: space-between; align-items: center;">
      <img src="/favicon.png" alt="Logo" style="">
    </li>

    
      <li><strong>Obserwuj:</strong></li>
    

    
      
        
          <li><a href="https://www.linkedin.com/in/tadeuszbiela/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://github.com/TadekBiela" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> RSS</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2026 <a href="https://cpptested.com">CppTested</a>. Powstało dzięki <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function () {
    var commentContainer = document.querySelector('#giscus-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');

    script.setAttribute('src', 'https://giscus.app/client.js');
    script.setAttribute('data-repo', '');
    script.setAttribute('data-repo-id', 'R_kgDOPEW3uQ');
    script.setAttribute('data-category', '');
    script.setAttribute('data-category-id', 'DIC_kwDOPEW3uc4CsbpH');
    script.setAttribute('data-mapping', 'pathname');
    script.setAttribute('data-strict', '0');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-emit-metadata', '0');
    script.setAttribute('data-input-position', 'top');
    script.setAttribute('data-theme', 'light');
    script.setAttribute('data-lang',  'pl');
    
    script.setAttribute('crossorigin', 'anonymous');

    script.setAttribute('async', '');

    commentContainer.appendChild(script);
  })();
</script>

  




  </body>
</html>
