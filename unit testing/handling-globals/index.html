<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.0 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="pl" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Zależności globalne - jak poradzić sobie z nimi w unit testach - CppTested</title>
<meta name="description" content="Każdy dobry unit test powinien nie tylko weryfikować nasz kod ale również odcinać zewnętrzne zależności, tak, aby przeprowadzenie testu odbywało się w izolacji. Typów zależności jest kilka, jednak najbardziej problematycznym są te globalne. Zaszyte w naszym kodzie potrafią skutecznie uniemożliwić nam odizolowanie naszej testowanej jednostki. Czy można coś z tym zrobić? Oczywiście! Jest na to kilka naprawdę dobrych technik. A więc zacznijmy od podstaw.  Czym są zależności globalne  Celowo nie użyłem słowa “zmienne” bo to nie jedyny problem. Możemy natrafić na stałe lub makra, które są zależne od platformy, na której nasz kod jest uruchamiany. Innym rodzajem zależności globalnej będzie “Singleton”, z którego nasza testowana klasa korzysta. Kolejnym rodzajem zależności globalnej mogą być zmienne statyczne.  Ostatnią kategorią zależności globalnej jest wolna funkcja! Pewnie pomyślisz coś w stylu: “Ale jak to? To coś złego? Po prostu przetestuję logikę mojej klasy wraz z logiką funkcji!” Oczywiście, jak najbardziej możesz to zrobić i nawet nie będzie to takie złe. Tylko wolna funkcja powinna mieć swój zestaw testów. Po co więc powielać je jako część naszych nowych unit testów? Dobrze by było zasymulować co wolna funkcja ma zwrócić, tak, aby uzyskać pożądany przepływ sterowania w naszym kodzie, bez “wstrzeliwania się” w jej logikę. Do wolnych funkcji zaliczamy również funkcje i obiekty z biblioteki standardowej lub frameworków oraz statyczne metody klas.  Jak widzisz zależności globalne mają różne formy. W świetnej książce “Praca z zastanym kodem. Najlepsze techniki” autora Michael’a Feathers’a, polskie tłumaczenie wykonane przez Ireneusza Jakóbika, określa tego rodzaju rozwiązania jako “spoiny”. Jak dla mnie bardzo trafne i ciekawe tłumaczenie, które również w moim wpisie się pojawi. Przejdźmy zatem do metod radzenia sobie z nimi.  Linkowanie  Jednym z rozwiązań, którym możemy się posłużyć, by odciąć zależności globalne jest proces linkowania. Jeżeli implementacja wolnej funkcji czy Singleton’u jest w pliku .cpp. Możemy stworzyć ich odpowiedniki tylko dla testów, które będą zwracać cały czas te same wartości lub mieć implementację z możliwością sterowania co i jak ma być zwracane w testach, tak aby każdy test był niezależny.  Mamy klasę TemperatureSensor, która do komunikacji z czujnikiem temperatury wykorzystuje protokół “I²C”, który jest zaimplementowany jako wolne funkcje w pliku I2cBus.hpp i I2cBus.cpp.  Tutaj fragment z implementacji klasy TemperatureSensor z użyciem zależności globalnej.  float TemperatureSensor::getAvgTemperature() {     if(sensorDrivers.empty())       return 0.0f;      float tempSum { 0.0f };     for(const auto&amp; sensorDriver : sensorDrivers)     {         tempSum += i2c::getSensorTemp(sensorDriver.address);     }      return tempSum / sensorDrivers.size(); }   Spoinę linkowania możemy zastosować, gdy w pliku nagłówkowym mamy tylko deklarację.  namespace i2c {  float getSensorTemp(const int sensorAddress);  }   Natomiast definicja znajduje się w pliku źródłowym (.cpp).  namespace i2c {  float getSensorTemp(const int sensorAddress) {     //Tutaj produkcyjna implementacja }  }   W takiej sytuacji możemy stworzyć osobną definicję dla testów w pliku I2cBusStub.cpp.  namespace i2c {  float getSensorTemp(const int sensorAddress) {     return 32.1f; }  }   Struktura projektu mogłaby wyglądać tak:  -project \   - src\     - temperatureSensor \       - I2cBus.hpp       - I2cBus.cpp       - TemperatureSensor.hpp       - TemperatureSensor.cpp     - tests \       - stubs         - I2cBusStub.cpp       - ut         - TemperatureSensorTests.cpp   W systemie budowany dla testów jako plik źródłowy do nagłówka I2cBus.hpp podajemy implementację z folderu stubs i spoina gotowa.  W ten sposób w naszych unit testach, nie będziemy korzystać z produkcyjnej implementacji tylko z stubowej/mockowej wersji. O różnicach między stubem, a mockiem pewnie jeszcze napiszę ;).  Podsumowując zastosowanie spoiny linkowania odbywa się tak:    Jeśli trzeba przenosisz implementację zależności globalnej do pliku źródłowego.   Tworzysz stuba lub mocka zależności globalnej i dostosowujesz system budowania.   Spoina linkowania jest w mojej ocenie jednak rozwiązaniem ostatecznym. Rozwiązuje wprawdzie problem zależności globalnych lecz ma spore wady. Po pierwsze wymaga dużo czasu. Nie tylko musimy zaimplementować stuba/mocka, ale dodatkowo zmienić także pliki budowania. Drugą wadą jest bardzo słaba czytelność. Nawet dobrze skonfigurowane IDE nieraz ma problem, by otworzyć odpowiedni plik źródłowy zależności globalnej i pracując przy testach otwiera produkcyjną implementację, co może być bardzo mylące, zwłaszcza dla mniej doświadczonych programistów. Po trzecie, nie jest rozwiązaniem dla wszystkich typów zależności globalnych. Spoiną linkowania nie odetniemy zależności do zmiennych statycznych, funkcji inline i innych zależności definiowanych w nagłówkach, których z jakiś powodów nie możemy przenieść do plików źródłowych.  Przejdźmy zatem do spoin obiektowych.  Dependency Injection  Wstrzykiwanie zależności to ogólnie dobra metoda separowania zależnych od siebie klas. W przypadku globalnych zależności ta technika również może pomóc. Możemy ją wykorzystać, gdy nasz kod zależny jest od zmiennych globalnych, Singleton’u, a nawet wolnych funkcji.  Technika ta polega na zmianie bezpośredniego wywołania zależności globalnej, w pole klasy i inicjalizowanie go poprzez dodanie parametru konstruktora. Weźmy na warsztat zmienną globalną.   int g_gameObjectsCounter { 0 };    Tutaj przykład jej użycia  void Weapon::fire(const Position&amp; position, const Rotation&amp; position) {     auto bullet { std::make_unique&lt;Bullet&gt;(g_gameObjectsCounter++, bulletTexture, position, position) };      display-&gt;add(std::move(bullet)); }   W takiej wersji zmienna globalna będzie trzymała stan między testami co prowadzi do zależności i złamania zasady I z “F.I.R.S.T.”.  Teraz spróbujmy przekazywać wartość zmiennej globalnej jako parametr konstruktora testowanej klasy. Plik nagłówkowy będzie wyglądał następująco.  class Weapon { public:     Weapon(int&amp; inputBulletId = g_gameObjectsCounter);     //... private:     int&amp; bulletId;     //... };   Jak widać, możemy nadać bardziej konkretną nazwę, przekazanej zmiennej globalnej, co poprawia czytelność dodając więcej kontekstu do miejsca jej użycia.  Weapon::Weapon(int&amp; inputBulletId)   : bulletId(inputBulletId) {}  void Weapon::fire(const Position&amp; position, const Rotation&amp; position) {     auto bullet { std::make_unique&lt;Bullet&gt;(bulletId++, bulletTexture, position, position) };      display-&gt;add(std::move(bullet)); }   W każdym teście możemy przekazywać dowolną zmienną, a testy stają się niezależne. W kodzie produkcyjnym niewiele się zmieni. Dodatkowo możemy zdefiniować domyślną wartość nowego parametru i ustawić ją właśnie na zmienną globalną. Zaletą takiego podejścia jest wyrzucenie użycia zmiennej globalnej poza implementację klasy. Możemy też nadać jej lepszą nazwę, bardziej związaną z kontekstem samej klasy. Zmienne globalne zazwyczaj mają bardziej ogólne nazwy. Możemy nawet dojść do miejsca, w którym ta zmienna globalna stanie się tak naprawdę lokalną zmienną tworzoną na stosie funkcji main.  Spróbujmy teraz nieco trudniejszy przypadek - Singleton. Wystarczy nam jego plik nagłówkowy. Sama implementacja do zastosowania Dependency Injection nie jest nam potrzebna.  class TextureStorage { public:     TextureStorage(const TextureStorage&amp;) = delete;     TextureStorage&amp; operator=(const TextureStorage&amp;) = delete;     TextureStorage(TextureStorage&amp;&amp;) = delete;     TextureStorage&amp; operator=(TextureStorage&amp;&amp;) = delete;      static const TextureStorage&amp; instance();     const Texture&amp; getTexture(const TextureId id);  private:     std::map&lt;TextureId, Texture&gt; textures;      TextureStorage();     ~TextureStorage(); };   A tutaj jego użycie w naszej testowanej klasie Player.  Player::Player(const Position&amp; inputPosition, const Rotation&amp; inputRotation)   : position(inputPosition)   , rotation(inputRotation) {     const auto&amp; graphicsStorage { TextureStorage::instance() };     texture = getTexture(TextureId::PLAYER);      //Reszta implementacji konstruktora... }  void Player::changeLook(const TextureId&amp; newTexture) {     const auto&amp; graphicsStorage { TextureStorage::instance() };     texture = getTexture(newTexture); }   Najpierw będziemy potrzebowali wydzielić potrzebny interfejs dla Singleton’u.  class ITextureStorage { public:     virtual const Texture&amp; getTexture(const TextureId id) = 0;     virtual ~TextureStorage() = 0; };   Czasem spotykam się z opinią, że dodawanie litery I do nazwy interfejsu to zły pomysł. Jak dla mnie uwidacznia on zastosowanie interfejsu co jest zaletą.  Teraz sam Singleton będzie dziedziczył po nowym interfejsie.  class TextureStorage : public ITextureStorage { public: //... };   W naszej klasie Player należy dodać referencję do ITextureStorage i przekazać ją w konstruktorze.  class Player { public:     Player(const Position&amp; inputPosition, const Rotation&amp; rotation inputRotation, const ITextureStorage&amp; inputTextureStorage);      //... private:     const ITextureStorage&amp; textureStorage;     //... };   Dzięki takiemu zabiegowi, będziemy mogli w testach przekazać mocka, który również dziedziczy po tym samym interfejsie co Singleton. Umożliwi nam to pełne i dowolne sterowanie jego zachowaniem w naszej testowanej klasie. W podobny sposób możemy poradzić sobie ze statycznymi obiektami.  Ogólna zasada jest taka:    Dodajesz parametr do konstruktora   Tworzysz pole i przekazujesz zależność globalną poprzez konstruktor.   Jedyną wadę jaką mogę tutaj dostrzec jest czasochłonność takiego rozwiązania. Trzeba dodać nieraz sporo kodu, aby móc skorzystać w pełni z tej techniki. Choć i tak wydaje mi się, że nakładu pracy jest mniej niż w spoinie linkowania.  Wrapper  Ostatnim i w mojej ocenie najlepszym rozwiązaniem do szybkiego, poprawnego i efektywnego odcięcia zależności globalnej jest wrapper. To nic innego jak opakowanie użycia globala w metodę. Metodę tą definiujemy jako virtual w sekcji protected. Tylko co nam to daje? Chyba najłatwiej będzie to zrozumieć na przykładzie.  Mamy klasę LoanScheduleGenerator, która wykorzystuje zmienną globalną g_interestRate w metodzie generate.  double g_interestRate = 0.035;  PaymentSchedule LoanScheduleGenerator::generate(const Loan&amp; loan) {     const unsigned numOfMonths { 12 };     double monthlyRate = g_interestRate / numOfMonths;     // dalsza część implementacji generowania harmonogramu spłaty kredytu }   Dodajemy wirtualną metodę getInterestRate w sekcji protected.  class LoanScheduleGenerator { public:     //... protected:     virtual double getInterestRate() const;     //... };   Następnie umieszczamy w niej globalną zależność. I zastępujemy bezpośrednie użycie globala wrapperem.  double LoanScheduleGenerator::getInterestRate() const {     return g_interestRate; }  PaymentSchedule LoanScheduleGenerator::generate(const Loan&amp; loan) {     const unsigned numOfMonths { 12 };     double monthlyRate = getInterestRate() / numOfMonths;     // dalsza część implementacji generowania harmonogramu spłaty kredytu }   Przejdźmy do testów. Dzięki wrapperowi możemy stworzyć klasę Testable, dziedziczącą po klasie LoanScheduleGenerator, którą chcemy przetestować i właśnie w niej przysłaniamy wrappera nadając mu potrzebne zachowanie.  class LoanScheduleGeneratorTestable : public LoanScheduleGenerator { public:     //...  private:     double getInterestRate() const     {         return 1.0;     } };   W ten sposób odcinamy zależność, minimalizując przy tym ingerencję w kod produkcyjny. Zastosowanie wrappera sprowadza się do kilku kroków:    Tworzysz wirtualną metodę w sekcji protected testowanej klasy (wrapper).   Przenosisz wywołanie zależności globalnej do tej metody.   Zastępujesz użycie globala wrapperem.   Tworzysz klasę pochodną od klasy testowanej z postfixem Testable i przysłaniasz w niej wrapper.   Podsumowanie  I to już wszystko co chciałem przekazać Ci w temacie odcinania zależności globalnych w testach. Mam nadzieję, że dzięki tym technikom, dużo prościej będzie Ci pracować z Twoimi testami. Celowo nie wspomniałem o spoinach kompilacyjnych (z użyciem preprocesora), gdyż uważam je za bardzo mało intuicyjne i z powodzeniem można użyć spoin obiektowych. Niemniej dla ciekawych odsyłam do książki, o której wspomniałem na początku wpisu.  Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów  LinkedIn">



<meta property="og:type" content="article">
<meta property="og:locale" content="pl">
<meta property="og:site_name" content="CppTested">
<meta property="og:title" content="Zależności globalne - jak poradzić sobie z nimi w unit testach">
<meta property="og:url" content="/unit%20testing/handling-globals/">


  <meta property="og:description" content="Każdy dobry unit test powinien nie tylko weryfikować nasz kod ale również odcinać zewnętrzne zależności, tak, aby przeprowadzenie testu odbywało się w izolacji. Typów zależności jest kilka, jednak najbardziej problematycznym są te globalne. Zaszyte w naszym kodzie potrafią skutecznie uniemożliwić nam odizolowanie naszej testowanej jednostki. Czy można coś z tym zrobić? Oczywiście! Jest na to kilka naprawdę dobrych technik. A więc zacznijmy od podstaw.  Czym są zależności globalne  Celowo nie użyłem słowa “zmienne” bo to nie jedyny problem. Możemy natrafić na stałe lub makra, które są zależne od platformy, na której nasz kod jest uruchamiany. Innym rodzajem zależności globalnej będzie “Singleton”, z którego nasza testowana klasa korzysta. Kolejnym rodzajem zależności globalnej mogą być zmienne statyczne.  Ostatnią kategorią zależności globalnej jest wolna funkcja! Pewnie pomyślisz coś w stylu: “Ale jak to? To coś złego? Po prostu przetestuję logikę mojej klasy wraz z logiką funkcji!” Oczywiście, jak najbardziej możesz to zrobić i nawet nie będzie to takie złe. Tylko wolna funkcja powinna mieć swój zestaw testów. Po co więc powielać je jako część naszych nowych unit testów? Dobrze by było zasymulować co wolna funkcja ma zwrócić, tak, aby uzyskać pożądany przepływ sterowania w naszym kodzie, bez “wstrzeliwania się” w jej logikę. Do wolnych funkcji zaliczamy również funkcje i obiekty z biblioteki standardowej lub frameworków oraz statyczne metody klas.  Jak widzisz zależności globalne mają różne formy. W świetnej książce “Praca z zastanym kodem. Najlepsze techniki” autora Michael’a Feathers’a, polskie tłumaczenie wykonane przez Ireneusza Jakóbika, określa tego rodzaju rozwiązania jako “spoiny”. Jak dla mnie bardzo trafne i ciekawe tłumaczenie, które również w moim wpisie się pojawi. Przejdźmy zatem do metod radzenia sobie z nimi.  Linkowanie  Jednym z rozwiązań, którym możemy się posłużyć, by odciąć zależności globalne jest proces linkowania. Jeżeli implementacja wolnej funkcji czy Singleton’u jest w pliku .cpp. Możemy stworzyć ich odpowiedniki tylko dla testów, które będą zwracać cały czas te same wartości lub mieć implementację z możliwością sterowania co i jak ma być zwracane w testach, tak aby każdy test był niezależny.  Mamy klasę TemperatureSensor, która do komunikacji z czujnikiem temperatury wykorzystuje protokół “I²C”, który jest zaimplementowany jako wolne funkcje w pliku I2cBus.hpp i I2cBus.cpp.  Tutaj fragment z implementacji klasy TemperatureSensor z użyciem zależności globalnej.  float TemperatureSensor::getAvgTemperature() {     if(sensorDrivers.empty())       return 0.0f;      float tempSum { 0.0f };     for(const auto&amp; sensorDriver : sensorDrivers)     {         tempSum += i2c::getSensorTemp(sensorDriver.address);     }      return tempSum / sensorDrivers.size(); }   Spoinę linkowania możemy zastosować, gdy w pliku nagłówkowym mamy tylko deklarację.  namespace i2c {  float getSensorTemp(const int sensorAddress);  }   Natomiast definicja znajduje się w pliku źródłowym (.cpp).  namespace i2c {  float getSensorTemp(const int sensorAddress) {     //Tutaj produkcyjna implementacja }  }   W takiej sytuacji możemy stworzyć osobną definicję dla testów w pliku I2cBusStub.cpp.  namespace i2c {  float getSensorTemp(const int sensorAddress) {     return 32.1f; }  }   Struktura projektu mogłaby wyglądać tak:  -project \   - src\     - temperatureSensor \       - I2cBus.hpp       - I2cBus.cpp       - TemperatureSensor.hpp       - TemperatureSensor.cpp     - tests \       - stubs         - I2cBusStub.cpp       - ut         - TemperatureSensorTests.cpp   W systemie budowany dla testów jako plik źródłowy do nagłówka I2cBus.hpp podajemy implementację z folderu stubs i spoina gotowa.  W ten sposób w naszych unit testach, nie będziemy korzystać z produkcyjnej implementacji tylko z stubowej/mockowej wersji. O różnicach między stubem, a mockiem pewnie jeszcze napiszę ;).  Podsumowując zastosowanie spoiny linkowania odbywa się tak:    Jeśli trzeba przenosisz implementację zależności globalnej do pliku źródłowego.   Tworzysz stuba lub mocka zależności globalnej i dostosowujesz system budowania.   Spoina linkowania jest w mojej ocenie jednak rozwiązaniem ostatecznym. Rozwiązuje wprawdzie problem zależności globalnych lecz ma spore wady. Po pierwsze wymaga dużo czasu. Nie tylko musimy zaimplementować stuba/mocka, ale dodatkowo zmienić także pliki budowania. Drugą wadą jest bardzo słaba czytelność. Nawet dobrze skonfigurowane IDE nieraz ma problem, by otworzyć odpowiedni plik źródłowy zależności globalnej i pracując przy testach otwiera produkcyjną implementację, co może być bardzo mylące, zwłaszcza dla mniej doświadczonych programistów. Po trzecie, nie jest rozwiązaniem dla wszystkich typów zależności globalnych. Spoiną linkowania nie odetniemy zależności do zmiennych statycznych, funkcji inline i innych zależności definiowanych w nagłówkach, których z jakiś powodów nie możemy przenieść do plików źródłowych.  Przejdźmy zatem do spoin obiektowych.  Dependency Injection  Wstrzykiwanie zależności to ogólnie dobra metoda separowania zależnych od siebie klas. W przypadku globalnych zależności ta technika również może pomóc. Możemy ją wykorzystać, gdy nasz kod zależny jest od zmiennych globalnych, Singleton’u, a nawet wolnych funkcji.  Technika ta polega na zmianie bezpośredniego wywołania zależności globalnej, w pole klasy i inicjalizowanie go poprzez dodanie parametru konstruktora. Weźmy na warsztat zmienną globalną.   int g_gameObjectsCounter { 0 };    Tutaj przykład jej użycia  void Weapon::fire(const Position&amp; position, const Rotation&amp; position) {     auto bullet { std::make_unique&lt;Bullet&gt;(g_gameObjectsCounter++, bulletTexture, position, position) };      display-&gt;add(std::move(bullet)); }   W takiej wersji zmienna globalna będzie trzymała stan między testami co prowadzi do zależności i złamania zasady I z “F.I.R.S.T.”.  Teraz spróbujmy przekazywać wartość zmiennej globalnej jako parametr konstruktora testowanej klasy. Plik nagłówkowy będzie wyglądał następująco.  class Weapon { public:     Weapon(int&amp; inputBulletId = g_gameObjectsCounter);     //... private:     int&amp; bulletId;     //... };   Jak widać, możemy nadać bardziej konkretną nazwę, przekazanej zmiennej globalnej, co poprawia czytelność dodając więcej kontekstu do miejsca jej użycia.  Weapon::Weapon(int&amp; inputBulletId)   : bulletId(inputBulletId) {}  void Weapon::fire(const Position&amp; position, const Rotation&amp; position) {     auto bullet { std::make_unique&lt;Bullet&gt;(bulletId++, bulletTexture, position, position) };      display-&gt;add(std::move(bullet)); }   W każdym teście możemy przekazywać dowolną zmienną, a testy stają się niezależne. W kodzie produkcyjnym niewiele się zmieni. Dodatkowo możemy zdefiniować domyślną wartość nowego parametru i ustawić ją właśnie na zmienną globalną. Zaletą takiego podejścia jest wyrzucenie użycia zmiennej globalnej poza implementację klasy. Możemy też nadać jej lepszą nazwę, bardziej związaną z kontekstem samej klasy. Zmienne globalne zazwyczaj mają bardziej ogólne nazwy. Możemy nawet dojść do miejsca, w którym ta zmienna globalna stanie się tak naprawdę lokalną zmienną tworzoną na stosie funkcji main.  Spróbujmy teraz nieco trudniejszy przypadek - Singleton. Wystarczy nam jego plik nagłówkowy. Sama implementacja do zastosowania Dependency Injection nie jest nam potrzebna.  class TextureStorage { public:     TextureStorage(const TextureStorage&amp;) = delete;     TextureStorage&amp; operator=(const TextureStorage&amp;) = delete;     TextureStorage(TextureStorage&amp;&amp;) = delete;     TextureStorage&amp; operator=(TextureStorage&amp;&amp;) = delete;      static const TextureStorage&amp; instance();     const Texture&amp; getTexture(const TextureId id);  private:     std::map&lt;TextureId, Texture&gt; textures;      TextureStorage();     ~TextureStorage(); };   A tutaj jego użycie w naszej testowanej klasie Player.  Player::Player(const Position&amp; inputPosition, const Rotation&amp; inputRotation)   : position(inputPosition)   , rotation(inputRotation) {     const auto&amp; graphicsStorage { TextureStorage::instance() };     texture = getTexture(TextureId::PLAYER);      //Reszta implementacji konstruktora... }  void Player::changeLook(const TextureId&amp; newTexture) {     const auto&amp; graphicsStorage { TextureStorage::instance() };     texture = getTexture(newTexture); }   Najpierw będziemy potrzebowali wydzielić potrzebny interfejs dla Singleton’u.  class ITextureStorage { public:     virtual const Texture&amp; getTexture(const TextureId id) = 0;     virtual ~TextureStorage() = 0; };   Czasem spotykam się z opinią, że dodawanie litery I do nazwy interfejsu to zły pomysł. Jak dla mnie uwidacznia on zastosowanie interfejsu co jest zaletą.  Teraz sam Singleton będzie dziedziczył po nowym interfejsie.  class TextureStorage : public ITextureStorage { public: //... };   W naszej klasie Player należy dodać referencję do ITextureStorage i przekazać ją w konstruktorze.  class Player { public:     Player(const Position&amp; inputPosition, const Rotation&amp; rotation inputRotation, const ITextureStorage&amp; inputTextureStorage);      //... private:     const ITextureStorage&amp; textureStorage;     //... };   Dzięki takiemu zabiegowi, będziemy mogli w testach przekazać mocka, który również dziedziczy po tym samym interfejsie co Singleton. Umożliwi nam to pełne i dowolne sterowanie jego zachowaniem w naszej testowanej klasie. W podobny sposób możemy poradzić sobie ze statycznymi obiektami.  Ogólna zasada jest taka:    Dodajesz parametr do konstruktora   Tworzysz pole i przekazujesz zależność globalną poprzez konstruktor.   Jedyną wadę jaką mogę tutaj dostrzec jest czasochłonność takiego rozwiązania. Trzeba dodać nieraz sporo kodu, aby móc skorzystać w pełni z tej techniki. Choć i tak wydaje mi się, że nakładu pracy jest mniej niż w spoinie linkowania.  Wrapper  Ostatnim i w mojej ocenie najlepszym rozwiązaniem do szybkiego, poprawnego i efektywnego odcięcia zależności globalnej jest wrapper. To nic innego jak opakowanie użycia globala w metodę. Metodę tą definiujemy jako virtual w sekcji protected. Tylko co nam to daje? Chyba najłatwiej będzie to zrozumieć na przykładzie.  Mamy klasę LoanScheduleGenerator, która wykorzystuje zmienną globalną g_interestRate w metodzie generate.  double g_interestRate = 0.035;  PaymentSchedule LoanScheduleGenerator::generate(const Loan&amp; loan) {     const unsigned numOfMonths { 12 };     double monthlyRate = g_interestRate / numOfMonths;     // dalsza część implementacji generowania harmonogramu spłaty kredytu }   Dodajemy wirtualną metodę getInterestRate w sekcji protected.  class LoanScheduleGenerator { public:     //... protected:     virtual double getInterestRate() const;     //... };   Następnie umieszczamy w niej globalną zależność. I zastępujemy bezpośrednie użycie globala wrapperem.  double LoanScheduleGenerator::getInterestRate() const {     return g_interestRate; }  PaymentSchedule LoanScheduleGenerator::generate(const Loan&amp; loan) {     const unsigned numOfMonths { 12 };     double monthlyRate = getInterestRate() / numOfMonths;     // dalsza część implementacji generowania harmonogramu spłaty kredytu }   Przejdźmy do testów. Dzięki wrapperowi możemy stworzyć klasę Testable, dziedziczącą po klasie LoanScheduleGenerator, którą chcemy przetestować i właśnie w niej przysłaniamy wrappera nadając mu potrzebne zachowanie.  class LoanScheduleGeneratorTestable : public LoanScheduleGenerator { public:     //...  private:     double getInterestRate() const     {         return 1.0;     } };   W ten sposób odcinamy zależność, minimalizując przy tym ingerencję w kod produkcyjny. Zastosowanie wrappera sprowadza się do kilku kroków:    Tworzysz wirtualną metodę w sekcji protected testowanej klasy (wrapper).   Przenosisz wywołanie zależności globalnej do tej metody.   Zastępujesz użycie globala wrapperem.   Tworzysz klasę pochodną od klasy testowanej z postfixem Testable i przysłaniasz w niej wrapper.   Podsumowanie  I to już wszystko co chciałem przekazać Ci w temacie odcinania zależności globalnych w testach. Mam nadzieję, że dzięki tym technikom, dużo prościej będzie Ci pracować z Twoimi testami. Celowo nie wspomniałem o spoinach kompilacyjnych (z użyciem preprocesora), gdyż uważam je za bardzo mało intuicyjne i z powodzeniem można użyć spoin obiektowych. Niemniej dla ciekawych odsyłam do książki, o której wspomniałem na początku wpisu.  Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów  LinkedIn">







  <meta property="article:published_time" content="2025-12-16T00:00:00+01:00">






<link rel="canonical" href="/unit%20testing/handling-globals/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="CppTested Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HKF97SJC9Z"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HKF97SJC9Z');
</script>

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<link rel="icon" type="image/png" href="/favicon.png">

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Przejdź do nawigacji</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Przejdź do treści</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Przejdź do stopki</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
	<a href="/" class="site-logo">
	  <span style="color: white; font-family: Courier, monospace;">Cpp</span>
  	  <span style="color: #28a745; font-family: Courier, monospace;">Tested</span>
	  <span class="blinking-cursor">|</span>
	</a>	
        <a class="site-title" href="/">
          CppTested
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/posts/"
                
                
              >Wpisy</a>
            </li><li class="masthead__menu-item">
              <a
                href="/categories/"
                
                
              >Kategorie</a>
            </li><li class="masthead__menu-item">
              <a
                href="/tags/"
                
                
              >Tagi</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >O mnie</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Przełącz wyszukiwanie</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Przełącz menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Zależności globalne - jak poradzić sobie z nimi w unit testach">
    <meta itemprop="description" content="Każdy dobry unit test powinien nie tylko weryfikować nasz kod ale również odcinać zewnętrzne zależności, tak, aby przeprowadzenie testu odbywało się w izolacji. Typów zależności jest kilka, jednak najbardziej problematycznym są te globalne. Zaszyte w naszym kodzie potrafią skutecznie uniemożliwić nam odizolowanie naszej testowanej jednostki. Czy można coś z tym zrobić? Oczywiście! Jest na to kilka naprawdę dobrych technik. A więc zacznijmy od podstaw.Czym są zależności globalneCelowo nie użyłem słowa “zmienne” bo to nie jedyny problem. Możemy natrafić na stałe lub makra, które są zależne od platformy, na której nasz kod jest uruchamiany. Innym rodzajem zależności globalnej będzie “Singleton”, z którego nasza testowana klasa korzysta. Kolejnym rodzajem zależności globalnej mogą być zmienne statyczne.Ostatnią kategorią zależności globalnej jest wolna funkcja! Pewnie pomyślisz coś w stylu: “Ale jak to? To coś złego? Po prostu przetestuję logikę mojej klasy wraz z logiką funkcji!” Oczywiście, jak najbardziej możesz to zrobić i nawet nie będzie to takie złe. Tylko wolna funkcja powinna mieć swój zestaw testów. Po co więc powielać je jako część naszych nowych unit testów? Dobrze by było zasymulować co wolna funkcja ma zwrócić, tak, aby uzyskać pożądany przepływ sterowania w naszym kodzie, bez “wstrzeliwania się” w jej logikę.Do wolnych funkcji zaliczamy również funkcje i obiekty z biblioteki standardowej lub frameworków oraz statyczne metody klas.Jak widzisz zależności globalne mają różne formy. W świetnej książce “Praca z zastanym kodem. Najlepsze techniki” autora Michael’a Feathers’a, polskie tłumaczenie wykonane przez Ireneusza Jakóbika, określa tego rodzaju rozwiązania jako “spoiny”. Jak dla mnie bardzo trafne i ciekawe tłumaczenie, które również w moim wpisie się pojawi. Przejdźmy zatem do metod radzenia sobie z nimi.LinkowanieJednym z rozwiązań, którym możemy się posłużyć, by odciąć zależności globalne jest proces linkowania. Jeżeli implementacja wolnej funkcji czy Singleton’u jest w pliku .cpp. Możemy stworzyć ich odpowiedniki tylko dla testów, które będą zwracać cały czas te same wartości lub mieć implementację z możliwością sterowania co i jak ma być zwracane w testach, tak aby każdy test był niezależny.Mamy klasę TemperatureSensor, która do komunikacji z czujnikiem temperatury wykorzystuje protokół “I²C”, który jest zaimplementowany jako wolne funkcje w pliku I2cBus.hpp i I2cBus.cpp.Tutaj fragment z implementacji klasy TemperatureSensor z użyciem zależności globalnej.float TemperatureSensor::getAvgTemperature(){    if(sensorDrivers.empty())      return 0.0f;    float tempSum { 0.0f };    for(const auto&amp; sensorDriver : sensorDrivers)    {        tempSum += i2c::getSensorTemp(sensorDriver.address);    }    return tempSum / sensorDrivers.size();}Spoinę linkowania możemy zastosować, gdy w pliku nagłówkowym mamy tylko deklarację.namespace i2c{float getSensorTemp(const int sensorAddress);}Natomiast definicja znajduje się w pliku źródłowym (.cpp).namespace i2c{float getSensorTemp(const int sensorAddress){    //Tutaj produkcyjna implementacja}}W takiej sytuacji możemy stworzyć osobną definicję dla testów w pliku I2cBusStub.cpp.namespace i2c{float getSensorTemp(const int sensorAddress){    return 32.1f;}}Struktura projektu mogłaby wyglądać tak:-project \  - src\    - temperatureSensor \      - I2cBus.hpp      - I2cBus.cpp      - TemperatureSensor.hpp      - TemperatureSensor.cpp    - tests \      - stubs        - I2cBusStub.cpp      - ut        - TemperatureSensorTests.cppW systemie budowany dla testów jako plik źródłowy do nagłówka I2cBus.hpp podajemy implementację z folderu stubs i spoina gotowa.W ten sposób w naszych unit testach, nie będziemy korzystać z produkcyjnej implementacji tylko z stubowej/mockowej wersji. O różnicach między stubem, a mockiem pewnie jeszcze napiszę ;).Podsumowując zastosowanie spoiny linkowania odbywa się tak:  Jeśli trzeba przenosisz implementację zależności globalnej do pliku źródłowego.  Tworzysz stuba lub mocka zależności globalnej i dostosowujesz system budowania.Spoina linkowania jest w mojej ocenie jednak rozwiązaniem ostatecznym. Rozwiązuje wprawdzie problem zależności globalnych lecz ma spore wady. Po pierwsze wymaga dużo czasu. Nie tylko musimy zaimplementować stuba/mocka, ale dodatkowo zmienić także pliki budowania. Drugą wadą jest bardzo słaba czytelność. Nawet dobrze skonfigurowane IDE nieraz ma problem, by otworzyć odpowiedni plik źródłowy zależności globalnej i pracując przy testach otwiera produkcyjną implementację, co może być bardzo mylące, zwłaszcza dla mniej doświadczonych programistów. Po trzecie, nie jest rozwiązaniem dla wszystkich typów zależności globalnych. Spoiną linkowania nie odetniemy zależności do zmiennych statycznych, funkcji inline i innych zależności definiowanych w nagłówkach, których z jakiś powodów nie możemy przenieść do plików źródłowych.Przejdźmy zatem do spoin obiektowych.Dependency InjectionWstrzykiwanie zależności to ogólnie dobra metoda separowania zależnych od siebie klas. W przypadku globalnych zależności ta technika również może pomóc. Możemy ją wykorzystać, gdy nasz kod zależny jest od zmiennych globalnych, Singleton’u, a nawet wolnych funkcji.Technika ta polega na zmianie bezpośredniego wywołania zależności globalnej, w pole klasy i inicjalizowanie go poprzez dodanie parametru konstruktora. Weźmy na warsztat zmienną globalną.int g_gameObjectsCounter { 0 };Tutaj przykład jej użyciavoid Weapon::fire(const Position&amp; position, const Rotation&amp; position){    auto bullet { std::make_unique&lt;Bullet&gt;(g_gameObjectsCounter++, bulletTexture, position, position) };    display-&gt;add(std::move(bullet));}W takiej wersji zmienna globalna będzie trzymała stan między testami co prowadzi do zależności i złamania zasady I z “F.I.R.S.T.”.Teraz spróbujmy przekazywać wartość zmiennej globalnej jako parametr konstruktora testowanej klasy. Plik nagłówkowy będzie wyglądał następująco.class Weapon{public:    Weapon(int&amp; inputBulletId = g_gameObjectsCounter);    //...private:    int&amp; bulletId;    //...};Jak widać, możemy nadać bardziej konkretną nazwę, przekazanej zmiennej globalnej, co poprawia czytelność dodając więcej kontekstu do miejsca jej użycia.Weapon::Weapon(int&amp; inputBulletId)  : bulletId(inputBulletId){}void Weapon::fire(const Position&amp; position, const Rotation&amp; position){    auto bullet { std::make_unique&lt;Bullet&gt;(bulletId++, bulletTexture, position, position) };    display-&gt;add(std::move(bullet));}W każdym teście możemy przekazywać dowolną zmienną, a testy stają się niezależne. W kodzie produkcyjnym niewiele się zmieni. Dodatkowo możemy zdefiniować domyślną wartość nowego parametru i ustawić ją właśnie na zmienną globalną. Zaletą takiego podejścia jest wyrzucenie użycia zmiennej globalnej poza implementację klasy. Możemy też nadać jej lepszą nazwę, bardziej związaną z kontekstem samej klasy. Zmienne globalne zazwyczaj mają bardziej ogólne nazwy. Możemy nawet dojść do miejsca, w którym ta zmienna globalna stanie się tak naprawdę lokalną zmienną tworzoną na stosie funkcji main.Spróbujmy teraz nieco trudniejszy przypadek - Singleton. Wystarczy nam jego plik nagłówkowy. Sama implementacja do zastosowania Dependency Injection nie jest nam potrzebna.class TextureStorage{public:    TextureStorage(const TextureStorage&amp;) = delete;    TextureStorage&amp; operator=(const TextureStorage&amp;) = delete;    TextureStorage(TextureStorage&amp;&amp;) = delete;    TextureStorage&amp; operator=(TextureStorage&amp;&amp;) = delete;    static const TextureStorage&amp; instance();    const Texture&amp; getTexture(const TextureId id);private:    std::map&lt;TextureId, Texture&gt; textures;    TextureStorage();    ~TextureStorage();};A tutaj jego użycie w naszej testowanej klasie Player.Player::Player(const Position&amp; inputPosition, const Rotation&amp; inputRotation)  : position(inputPosition)  , rotation(inputRotation){    const auto&amp; graphicsStorage { TextureStorage::instance() };    texture = getTexture(TextureId::PLAYER);    //Reszta implementacji konstruktora...}void Player::changeLook(const TextureId&amp; newTexture){    const auto&amp; graphicsStorage { TextureStorage::instance() };    texture = getTexture(newTexture);}Najpierw będziemy potrzebowali wydzielić potrzebny interfejs dla Singleton’u.class ITextureStorage{public:    virtual const Texture&amp; getTexture(const TextureId id) = 0;    virtual ~TextureStorage() = 0;};Czasem spotykam się z opinią, że dodawanie litery I do nazwy interfejsu to zły pomysł. Jak dla mnie uwidacznia on zastosowanie interfejsu co jest zaletą.Teraz sam Singleton będzie dziedziczył po nowym interfejsie.class TextureStorage : public ITextureStorage{public://...};W naszej klasie Player należy dodać referencję do ITextureStorage i przekazać ją w konstruktorze.class Player{public:    Player(const Position&amp; inputPosition, const Rotation&amp; rotation inputRotation, const ITextureStorage&amp; inputTextureStorage);    //...private:    const ITextureStorage&amp; textureStorage;    //...};Dzięki takiemu zabiegowi, będziemy mogli w testach przekazać mocka, który również dziedziczy po tym samym interfejsie co Singleton. Umożliwi nam to pełne i dowolne sterowanie jego zachowaniem w naszej testowanej klasie. W podobny sposób możemy poradzić sobie ze statycznymi obiektami.Ogólna zasada jest taka:  Dodajesz parametr do konstruktora  Tworzysz pole i przekazujesz zależność globalną poprzez konstruktor.Jedyną wadę jaką mogę tutaj dostrzec jest czasochłonność takiego rozwiązania. Trzeba dodać nieraz sporo kodu, aby móc skorzystać w pełni z tej techniki. Choć i tak wydaje mi się, że nakładu pracy jest mniej niż w spoinie linkowania.WrapperOstatnim i w mojej ocenie najlepszym rozwiązaniem do szybkiego, poprawnego i efektywnego odcięcia zależności globalnej jest wrapper. To nic innego jak opakowanie użycia globala w metodę. Metodę tą definiujemy jako virtual w sekcji protected. Tylko co nam to daje? Chyba najłatwiej będzie to zrozumieć na przykładzie.Mamy klasę LoanScheduleGenerator, która wykorzystuje zmienną globalną g_interestRate w metodzie generate.double g_interestRate = 0.035;PaymentSchedule LoanScheduleGenerator::generate(const Loan&amp; loan){    const unsigned numOfMonths { 12 };    double monthlyRate = g_interestRate / numOfMonths;    // dalsza część implementacji generowania harmonogramu spłaty kredytu}Dodajemy wirtualną metodę getInterestRate w sekcji protected.class LoanScheduleGenerator{public:    //...protected:    virtual double getInterestRate() const;    //...};Następnie umieszczamy w niej globalną zależność. I zastępujemy bezpośrednie użycie globala wrapperem.double LoanScheduleGenerator::getInterestRate() const{    return g_interestRate;}PaymentSchedule LoanScheduleGenerator::generate(const Loan&amp; loan){    const unsigned numOfMonths { 12 };    double monthlyRate = getInterestRate() / numOfMonths;    // dalsza część implementacji generowania harmonogramu spłaty kredytu}Przejdźmy do testów. Dzięki wrapperowi możemy stworzyć klasę Testable, dziedziczącą po klasie LoanScheduleGenerator, którą chcemy przetestować i właśnie w niej przysłaniamy wrappera nadając mu potrzebne zachowanie.class LoanScheduleGeneratorTestable : public LoanScheduleGenerator{public:    //...private:    double getInterestRate() const    {        return 1.0;    }};W ten sposób odcinamy zależność, minimalizując przy tym ingerencję w kod produkcyjny. Zastosowanie wrappera sprowadza się do kilku kroków:  Tworzysz wirtualną metodę w sekcji protected testowanej klasy (wrapper).  Przenosisz wywołanie zależności globalnej do tej metody.  Zastępujesz użycie globala wrapperem.  Tworzysz klasę pochodną od klasy testowanej z postfixem Testable i przysłaniasz w niej wrapper.PodsumowanieI to już wszystko co chciałem przekazać Ci w temacie odcinania zależności globalnych w testach. Mam nadzieję, że dzięki tym technikom, dużo prościej będzie Ci pracować z Twoimi testami. Celowo nie wspomniałem o spoinach kompilacyjnych (z użyciem preprocesora), gdyż uważam je za bardzo mało intuicyjne i z powodzeniem można użyć spoin obiektowych. Niemniej dla ciekawych odsyłam do książki, o której wspomniałem na początku wpisu.Autor: Tadeusz BielaProgramista C++ | Entuzjasta TDD | Fan unit testówLinkedIn">
    <meta itemprop="datePublished" content="2025-12-16T00:00:00+01:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="/unit%20testing/handling-globals/" itemprop="url">Zależności globalne - jak poradzić sobie z nimi w unit testach
</a>
          </h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-12-16T00:00:00+01:00">16 grudnia 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          7 minut(y)
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Spis treści</h4></header>
              <ul class="toc__menu"><li><a href="#czym-są-zależności-globalne">Czym są zależności globalne</a></li><li><a href="#linkowanie">Linkowanie</a></li><li><a href="#dependency-injection">Dependency Injection</a></li><li><a href="#wrapper">Wrapper</a></li><li><a href="#podsumowanie">Podsumowanie</a></li></ul>
            </nav>
          </aside>
        
        <p>Każdy dobry unit test powinien nie tylko weryfikować nasz kod ale również odcinać zewnętrzne zależności, tak, aby przeprowadzenie testu odbywało się w izolacji. Typów zależności jest kilka, jednak najbardziej problematycznym są te globalne. Zaszyte w naszym kodzie potrafią skutecznie uniemożliwić nam odizolowanie naszej testowanej jednostki. Czy można coś z tym zrobić? Oczywiście! Jest na to kilka naprawdę dobrych technik. A więc zacznijmy od podstaw.</p>

<h3 id="czym-są-zależności-globalne">Czym są zależności globalne</h3>

<p>Celowo nie użyłem słowa “zmienne” bo to nie jedyny problem. Możemy natrafić na stałe lub makra, które są zależne od platformy, na której nasz kod jest uruchamiany. Innym rodzajem zależności globalnej będzie <a href="https://pl.wikipedia.org/wiki/Singleton_(wzorzec_projektowy)" target="_blank" rel="noopener">“Singleton”</a>, z którego nasza testowana klasa korzysta. Kolejnym rodzajem zależności globalnej mogą być zmienne statyczne.</p>

<p>Ostatnią kategorią zależności globalnej jest wolna funkcja! Pewnie pomyślisz coś w stylu: “Ale jak to? To coś złego? Po prostu przetestuję logikę mojej klasy wraz z logiką funkcji!” Oczywiście, jak najbardziej możesz to zrobić i nawet nie będzie to takie złe. Tylko wolna funkcja powinna mieć swój zestaw testów. Po co więc powielać je jako część naszych nowych unit testów? Dobrze by było zasymulować co wolna funkcja ma zwrócić, tak, aby uzyskać pożądany przepływ sterowania w naszym kodzie, bez “wstrzeliwania się” w jej logikę.
Do wolnych funkcji zaliczamy również funkcje i obiekty z biblioteki standardowej lub frameworków oraz statyczne metody klas.</p>

<p>Jak widzisz zależności globalne mają różne formy. W świetnej książce <a href="https://lubimyczytac.pl/ksiazka/238260/praca-z-zastanym-kodem-najlepsze-techniki" target="_blank" rel="noopener">“Praca z zastanym kodem. Najlepsze techniki”</a> autora Michael’a Feathers’a, polskie tłumaczenie wykonane przez Ireneusza Jakóbika, określa tego rodzaju rozwiązania jako <strong>“spoiny”</strong>. Jak dla mnie bardzo trafne i ciekawe tłumaczenie, które również w moim wpisie się pojawi. Przejdźmy zatem do metod radzenia sobie z nimi.</p>

<h3 id="linkowanie">Linkowanie</h3>

<p>Jednym z rozwiązań, którym możemy się posłużyć, by odciąć zależności globalne jest proces linkowania. Jeżeli implementacja wolnej funkcji czy Singleton’u jest w pliku <strong>.cpp</strong>. Możemy stworzyć ich odpowiedniki tylko dla testów, które będą zwracać cały czas te same wartości lub mieć implementację z możliwością sterowania co i jak ma być zwracane w testach, tak aby każdy test był niezależny.</p>

<p>Mamy klasę <strong>TemperatureSensor</strong>, która do komunikacji z czujnikiem temperatury wykorzystuje protokół <a href="https://pl.wikipedia.org/wiki/I%C2%B2C" target="_blank" rel="noopener">“I²C”</a>, który jest zaimplementowany jako wolne funkcje w pliku <strong>I2cBus.hpp</strong> i <strong>I2cBus.cpp</strong>.</p>

<p>Tutaj fragment z implementacji klasy <strong>TemperatureSensor</strong> z użyciem zależności globalnej.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="n">TemperatureSensor</span><span class="o">::</span><span class="n">getAvgTemperature</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">sensorDrivers</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
      <span class="k">return</span> <span class="mf">0.0</span><span class="n">f</span><span class="p">;</span>

    <span class="kt">float</span> <span class="n">tempSum</span> <span class="p">{</span> <span class="mf">0.0</span><span class="n">f</span> <span class="p">};</span>
    <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">sensorDriver</span> <span class="o">:</span> <span class="n">sensorDrivers</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">tempSum</span> <span class="o">+=</span> <span class="n">i2c</span><span class="o">::</span><span class="n">getSensorTemp</span><span class="p">(</span><span class="n">sensorDriver</span><span class="p">.</span><span class="n">address</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tempSum</span> <span class="o">/</span> <span class="n">sensorDrivers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Spoinę linkowania możemy zastosować, gdy w pliku nagłówkowym mamy tylko deklarację.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">i2c</span>
<span class="p">{</span>

<span class="kt">float</span> <span class="n">getSensorTemp</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">sensorAddress</span><span class="p">);</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Natomiast definicja znajduje się w pliku źródłowym (.cpp).</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">i2c</span>
<span class="p">{</span>

<span class="kt">float</span> <span class="n">getSensorTemp</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">sensorAddress</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//Tutaj produkcyjna implementacja</span>
<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>W takiej sytuacji możemy stworzyć osobną definicję dla testów w pliku <strong>I2cBusStub.cpp</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">i2c</span>
<span class="p">{</span>

<span class="kt">float</span> <span class="n">getSensorTemp</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">sensorAddress</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mf">32.1</span><span class="n">f</span><span class="p">;</span>
<span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>Struktura projektu mogłaby wyglądać tak:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">-project</span> <span class="se">\</span>
  - src<span class="se">\</span>
    - temperatureSensor <span class="se">\</span>
      - I2cBus.hpp
      - I2cBus.cpp
      - TemperatureSensor.hpp
      - TemperatureSensor.cpp
    - tests <span class="se">\</span>
      - stubs
        - I2cBusStub.cpp
      - ut
        - TemperatureSensorTests.cpp
</code></pre></div></div>

<p>W systemie budowany dla testów jako plik źródłowy do nagłówka <strong>I2cBus.hpp</strong> podajemy implementację z folderu <strong>stubs</strong> i spoina gotowa.</p>

<p>W ten sposób w naszych unit testach, nie będziemy korzystać z produkcyjnej implementacji tylko z stubowej/mockowej wersji. O różnicach między stubem, a mockiem pewnie jeszcze napiszę ;).</p>

<p>Podsumowując zastosowanie spoiny linkowania odbywa się tak:</p>
<ol>
  <li>Jeśli trzeba przenosisz implementację zależności globalnej do pliku źródłowego.</li>
  <li>Tworzysz stuba lub mocka zależności globalnej i dostosowujesz system budowania.</li>
</ol>

<p>Spoina linkowania jest w mojej ocenie jednak rozwiązaniem ostatecznym. Rozwiązuje wprawdzie problem zależności globalnych lecz ma spore wady. Po pierwsze wymaga dużo czasu. Nie tylko musimy zaimplementować stuba/mocka, ale dodatkowo zmienić także pliki budowania. Drugą wadą jest bardzo słaba czytelność. Nawet dobrze skonfigurowane IDE nieraz ma problem, by otworzyć odpowiedni plik źródłowy zależności globalnej i pracując przy testach otwiera produkcyjną implementację, co może być bardzo mylące, zwłaszcza dla mniej doświadczonych programistów. Po trzecie, nie jest rozwiązaniem dla wszystkich typów zależności globalnych. Spoiną linkowania nie odetniemy zależności do zmiennych statycznych, funkcji <strong>inline</strong> i innych zależności definiowanych w nagłówkach, których z jakiś powodów nie możemy przenieść do plików źródłowych.</p>

<p>Przejdźmy zatem do spoin obiektowych.</p>

<h3 id="dependency-injection">Dependency Injection</h3>

<p>Wstrzykiwanie zależności to ogólnie dobra metoda separowania zależnych od siebie klas. W przypadku globalnych zależności ta technika również może pomóc. Możemy ją wykorzystać, gdy nasz kod zależny jest od zmiennych globalnych, Singleton’u, a nawet wolnych funkcji.</p>

<p>Technika ta polega na zmianie bezpośredniego wywołania zależności globalnej, w pole klasy i inicjalizowanie go poprzez dodanie parametru konstruktora. Weźmy na warsztat zmienną globalną.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">g_gameObjectsCounter</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

</code></pre></div></div>

<p>Tutaj przykład jej użycia</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">Weapon</span><span class="o">::</span><span class="n">fire</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">position</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rotation</span><span class="o">&amp;</span> <span class="n">position</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">bullet</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">g_gameObjectsCounter</span><span class="o">++</span><span class="p">,</span> <span class="n">bulletTexture</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">display</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bullet</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>W takiej wersji zmienna globalna będzie trzymała stan między testami co prowadzi do zależności i złamania zasady <strong>I</strong> z <a href="https://cpptested.com/unit%20testing/first-reguly-ut/" target="_blank" rel="noopener">“F.I.R.S.T.”</a>.</p>

<p>Teraz spróbujmy przekazywać wartość zmiennej globalnej jako parametr konstruktora testowanej klasy. Plik nagłówkowy będzie wyglądał następująco.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Weapon</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Weapon</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">inputBulletId</span> <span class="o">=</span> <span class="n">g_gameObjectsCounter</span><span class="p">);</span>
    <span class="c1">//...</span>
<span class="nl">private:</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">bulletId</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Jak widać, możemy nadać bardziej konkretną nazwę, przekazanej zmiennej globalnej, co poprawia czytelność dodając więcej kontekstu do miejsca jej użycia.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Weapon</span><span class="o">::</span><span class="n">Weapon</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">inputBulletId</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">bulletId</span><span class="p">(</span><span class="n">inputBulletId</span><span class="p">)</span>
<span class="p">{}</span>

<span class="kt">void</span> <span class="n">Weapon</span><span class="o">::</span><span class="n">fire</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">position</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rotation</span><span class="o">&amp;</span> <span class="n">position</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">bullet</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bullet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bulletId</span><span class="o">++</span><span class="p">,</span> <span class="n">bulletTexture</span><span class="p">,</span> <span class="n">position</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">display</span><span class="o">-&gt;</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">bullet</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>W każdym teście możemy przekazywać dowolną zmienną, a testy stają się niezależne. W kodzie produkcyjnym niewiele się zmieni. Dodatkowo możemy zdefiniować domyślną wartość nowego parametru i ustawić ją właśnie na zmienną globalną. Zaletą takiego podejścia jest wyrzucenie użycia zmiennej globalnej poza implementację klasy. Możemy też nadać jej lepszą nazwę, bardziej związaną z kontekstem samej klasy. Zmienne globalne zazwyczaj mają bardziej ogólne nazwy. Możemy nawet dojść do miejsca, w którym ta zmienna globalna stanie się tak naprawdę lokalną zmienną tworzoną na stosie funkcji <strong>main</strong>.</p>

<p>Spróbujmy teraz nieco trudniejszy przypadek - Singleton. Wystarczy nam jego plik nagłówkowy. Sama implementacja do zastosowania <strong>Dependency Injection</strong> nie jest nam potrzebna.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TextureStorage</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TextureStorage</span><span class="p">(</span><span class="k">const</span> <span class="n">TextureStorage</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">TextureStorage</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TextureStorage</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">TextureStorage</span><span class="p">(</span><span class="n">TextureStorage</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="n">TextureStorage</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">TextureStorage</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">const</span> <span class="n">TextureStorage</span><span class="o">&amp;</span> <span class="n">instance</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Texture</span><span class="o">&amp;</span> <span class="n">getTexture</span><span class="p">(</span><span class="k">const</span> <span class="n">TextureId</span> <span class="n">id</span><span class="p">);</span>

<span class="nl">private:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">TextureId</span><span class="p">,</span> <span class="n">Texture</span><span class="o">&gt;</span> <span class="n">textures</span><span class="p">;</span>

    <span class="n">TextureStorage</span><span class="p">();</span>
    <span class="o">~</span><span class="n">TextureStorage</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>

<p>A tutaj jego użycie w naszej testowanej klasie <strong>Player</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Player</span><span class="o">::</span><span class="n">Player</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">inputPosition</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rotation</span><span class="o">&amp;</span> <span class="n">inputRotation</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">position</span><span class="p">(</span><span class="n">inputPosition</span><span class="p">)</span>
  <span class="p">,</span> <span class="n">rotation</span><span class="p">(</span><span class="n">inputRotation</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">graphicsStorage</span> <span class="p">{</span> <span class="n">TextureStorage</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">texture</span> <span class="o">=</span> <span class="n">getTexture</span><span class="p">(</span><span class="n">TextureId</span><span class="o">::</span><span class="n">PLAYER</span><span class="p">);</span>

    <span class="c1">//Reszta implementacji konstruktora...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Player</span><span class="o">::</span><span class="n">changeLook</span><span class="p">(</span><span class="k">const</span> <span class="n">TextureId</span><span class="o">&amp;</span> <span class="n">newTexture</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">graphicsStorage</span> <span class="p">{</span> <span class="n">TextureStorage</span><span class="o">::</span><span class="n">instance</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">texture</span> <span class="o">=</span> <span class="n">getTexture</span><span class="p">(</span><span class="n">newTexture</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Najpierw będziemy potrzebowali wydzielić potrzebny interfejs dla Singleton’u.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">ITextureStorage</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Texture</span><span class="o">&amp;</span> <span class="n">getTexture</span><span class="p">(</span><span class="k">const</span> <span class="n">TextureId</span> <span class="n">id</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">TextureStorage</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Czasem spotykam się z opinią, że dodawanie litery <strong>I</strong> do nazwy interfejsu to zły pomysł. Jak dla mnie uwidacznia on zastosowanie interfejsu co jest zaletą.</p>

<p>Teraz sam Singleton będzie dziedziczył po nowym interfejsie.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">TextureStorage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ITextureStorage</span>
<span class="p">{</span>
<span class="nl">public:</span>
<span class="c1">//...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>W naszej klasie <strong>Player</strong> należy dodać referencję do <strong>ITextureStorage</strong> i przekazać ją w konstruktorze.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Player</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Player</span><span class="p">(</span><span class="k">const</span> <span class="n">Position</span><span class="o">&amp;</span> <span class="n">inputPosition</span><span class="p">,</span> <span class="k">const</span> <span class="n">Rotation</span><span class="o">&amp;</span> <span class="n">rotation</span> <span class="n">inputRotation</span><span class="p">,</span> <span class="k">const</span> <span class="n">ITextureStorage</span><span class="o">&amp;</span> <span class="n">inputTextureStorage</span><span class="p">);</span>

    <span class="c1">//...</span>
<span class="nl">private:</span>
    <span class="k">const</span> <span class="n">ITextureStorage</span><span class="o">&amp;</span> <span class="n">textureStorage</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Dzięki takiemu zabiegowi, będziemy mogli w testach przekazać mocka, który również dziedziczy po tym samym interfejsie co Singleton. Umożliwi nam to pełne i dowolne sterowanie jego zachowaniem w naszej testowanej klasie. W podobny sposób możemy poradzić sobie ze statycznymi obiektami.</p>

<p>Ogólna zasada jest taka:</p>
<ol>
  <li>Dodajesz parametr do konstruktora</li>
  <li>Tworzysz pole i przekazujesz zależność globalną poprzez konstruktor.</li>
</ol>

<p>Jedyną wadę jaką mogę tutaj dostrzec jest czasochłonność takiego rozwiązania. Trzeba dodać nieraz sporo kodu, aby móc skorzystać w pełni z tej techniki. Choć i tak wydaje mi się, że nakładu pracy jest mniej niż w spoinie linkowania.</p>

<h3 id="wrapper">Wrapper</h3>

<p>Ostatnim i w mojej ocenie najlepszym rozwiązaniem do szybkiego, poprawnego i efektywnego odcięcia zależności globalnej jest <strong>wrapper</strong>. To nic innego jak opakowanie użycia globala w metodę. Metodę tą definiujemy jako <strong>virtual</strong> w sekcji <strong>protected</strong>. Tylko co nam to daje? Chyba najłatwiej będzie to zrozumieć na przykładzie.</p>

<p>Mamy klasę <strong>LoanScheduleGenerator</strong>, która wykorzystuje zmienną globalną <strong>g_interestRate</strong> w metodzie <strong>generate</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">g_interestRate</span> <span class="o">=</span> <span class="mf">0.035</span><span class="p">;</span>

<span class="n">PaymentSchedule</span> <span class="n">LoanScheduleGenerator</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="k">const</span> <span class="n">Loan</span><span class="o">&amp;</span> <span class="n">loan</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">numOfMonths</span> <span class="p">{</span> <span class="mi">12</span> <span class="p">};</span>
    <span class="kt">double</span> <span class="n">monthlyRate</span> <span class="o">=</span> <span class="n">g_interestRate</span> <span class="o">/</span> <span class="n">numOfMonths</span><span class="p">;</span>
    <span class="c1">// dalsza część implementacji generowania harmonogramu spłaty kredytu</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dodajemy wirtualną metodę <strong>getInterestRate</strong> w sekcji <strong>protected</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LoanScheduleGenerator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">//...</span>
<span class="nl">protected:</span>
    <span class="k">virtual</span> <span class="kt">double</span> <span class="n">getInterestRate</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Następnie umieszczamy w niej globalną zależność. I zastępujemy bezpośrednie użycie globala <strong>wrapperem</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="n">LoanScheduleGenerator</span><span class="o">::</span><span class="n">getInterestRate</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">g_interestRate</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">PaymentSchedule</span> <span class="n">LoanScheduleGenerator</span><span class="o">::</span><span class="n">generate</span><span class="p">(</span><span class="k">const</span> <span class="n">Loan</span><span class="o">&amp;</span> <span class="n">loan</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">numOfMonths</span> <span class="p">{</span> <span class="mi">12</span> <span class="p">};</span>
    <span class="kt">double</span> <span class="n">monthlyRate</span> <span class="o">=</span> <span class="n">getInterestRate</span><span class="p">()</span> <span class="o">/</span> <span class="n">numOfMonths</span><span class="p">;</span>
    <span class="c1">// dalsza część implementacji generowania harmonogramu spłaty kredytu</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Przejdźmy do testów. Dzięki <strong>wrapperowi</strong> możemy stworzyć klasę <strong>Testable</strong>, dziedziczącą po klasie <strong>LoanScheduleGenerator</strong>, którą chcemy przetestować i właśnie w niej przysłaniamy <strong>wrappera</strong> nadając mu potrzebne zachowanie.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">LoanScheduleGeneratorTestable</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LoanScheduleGenerator</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">//...</span>

<span class="nl">private:</span>
    <span class="kt">double</span> <span class="n">getInterestRate</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>W ten sposób odcinamy zależność, minimalizując przy tym ingerencję w kod produkcyjny. Zastosowanie <strong>wrappera</strong> sprowadza się do kilku kroków:</p>
<ol>
  <li>Tworzysz wirtualną metodę w sekcji <strong>protected</strong> testowanej klasy (<strong>wrapper</strong>).</li>
  <li>Przenosisz wywołanie zależności globalnej do tej metody.</li>
  <li>Zastępujesz użycie globala <strong>wrapperem</strong>.</li>
  <li>Tworzysz klasę pochodną od klasy testowanej z postfixem <strong>Testable</strong> i przysłaniasz w niej <strong>wrapper</strong>.</li>
</ol>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>I to już wszystko co chciałem przekazać Ci w temacie odcinania zależności globalnych w testach. Mam nadzieję, że dzięki tym technikom, dużo prościej będzie Ci pracować z Twoimi testami. Celowo nie wspomniałem o spoinach kompilacyjnych (z użyciem preprocesora), gdyż uważam je za bardzo mało intuicyjne i z powodzeniem można użyć spoin obiektowych. Niemniej dla ciekawych odsyłam do książki, o której wspomniałem na początku wpisu.</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tagi: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#code-quality" class="page__taxonomy-item p-category" rel="tag">code quality</a><span class="sep">, </span>
    
      <a href="/tags/#developer-practices" class="page__taxonomy-item p-category" rel="tag">developer practices</a><span class="sep">, </span>
    
      <a href="/tags/#refactoring" class="page__taxonomy-item p-category" rel="tag">refactoring</a><span class="sep">, </span>
    
      <a href="/tags/#software-testing" class="page__taxonomy-item p-category" rel="tag">software testing</a><span class="sep">, </span>
    
      <a href="/tags/#unit-testing" class="page__taxonomy-item p-category" rel="tag">unit testing</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Kategorie: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#unit-testing" class="page__taxonomy-item p-category" rel="tag">unit testing</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Ostatnia aktualizacja:</strong> <time class="dt-published" datetime="2025-12-16T00:00:00+01:00">16 grudnia 2025</time></p>

      </footer>

      <section class="page__share">
  <h4 class="page__share-title">Udostępnij</h4>

  <a href="https://x.com/intent/tweet?text=Zale%C5%BCno%C5%9Bci+globalne+-+jak+poradzi%C4%87+sobie+z%26nbsp%3Bnimi+w+unit+testach%20%2Funit%2520testing%2Fhandling-globals%2F" class="btn btn--x" aria-label="Share on X" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Udostępnij X">
    <i class="fas fa-fw fa-share-alt" aria-hidden="true"></i><span> X</span>
  </a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=%2Funit%2520testing%2Fhandling-globals%2F" class="btn btn--facebook" aria-label="Share on Facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Udostępnij Facebook">
    <i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span>
  </a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=/unit%20testing/handling-globals/" class="btn btn--linkedin" aria-label="Share on LinkedIn" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Udostępnij LinkedIn">
    <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span>
  </a>
</section>


      
  <nav class="pagination">
    
      <a href="/clean%20code/dry-and-other-principles/" class="pagination--pager" title="DRY, YAGNI, KISS i inne. Uniwersalne zasady dla każdego programisty.">Poprzednia</a>
    
    
      <a href="#" class="pagination--pager disabled">Następna</a>
    
  </nav>


    </div>

    
      
        <div class="page__comments">
  
  
      <h4 class="page__comments-title">Zostaw komentarz</h4>
      <div class="giscus"></div>
      <script src="https://giscus.app/client.js"
              data-repo="TadekBiela/cpptested"
              data-repo-id="R_kgDOPEW3uQ"
              data-category="Announcements"
              data-category-id="DIC_kwDOPEW3uc4CsbpH"
              data-mapping="pathname"
              data-strict="0"
              data-reactions-enabled="1"
              data-emit-metadata="0"
              data-input-position="top"
              data-theme="light"
              data-lang="pl"
              crossorigin="anonymous"
              async>
      </script>
    
</div>

      
    
  </article>

  
  
    
<div class="page__related">
  
  <h2 class="page__related-title">Także może Ci się spodobać</h2>
  <div class="grid__wrapper">
    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/clean%20code/dry-and-other-principles/" rel="permalink">DRY, YAGNI, KISS i inne. Uniwersalne zasady dla każdego programisty.
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-11-17T00:00:00+01:00">17 listopada 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          12 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Te tajemnicze akronimy skrywają w sobie dekady doświadczeń naszych programistycznych poprzedników. Choć brzmi to nieco patetycznie, tak właśnie jest. Zasady,...</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/multithreading/exception-in-thread/" rel="permalink">Wątki i wyjątki. Jak radzić sobie z nieoczekiwanymi zachowaniami w wielowątkowym kodzie.
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-10-13T00:00:00+02:00">13 października 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          10 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Nieoczekiwane zachowanie czyli wyjątek to sytuacja, w której nasz kod zachował się w sposób, który normalnie nie występuje. Może być to wywołane problemami z...</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/unit%20testing/AAA-golden-standard/" rel="permalink">AAA - złoty standard unit testów.
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-09-15T00:00:00+02:00">15 września 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          4 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Arrange Act Assert – to game changer dla jakości unit testów. Dzięki tym prostym zasadom testy stają się nie tylko bardziej czytelne, lecz mogą stanowić dosk...</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/tdd/about-tdd/" rel="permalink">Czym jest TDD i czy warto je stosować?
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-08-26T00:00:00+02:00">26 sierpnia 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          5 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jes...</p>
  </article>
</div>

    
  </div>
</div>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Wprowadź kryteria wyszukiwania...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Wprowadź kryteria wyszukiwania..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    <li style="justify-content: space-between; align-items: center;">
      <img src="/favicon.png" alt="Logo" style="">
    </li>

    
      <li><strong>Obserwuj:</strong></li>
    

    
      
        
          <li><a href="https://www.linkedin.com/in/tadeuszbiela/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://github.com/TadekBiela" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> RSS</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2026 <a href="">CppTested</a>. Powstało dzięki <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function () {
    var commentContainer = document.querySelector('#giscus-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');

    script.setAttribute('src', 'https://giscus.app/client.js');
    script.setAttribute('data-repo', '');
    script.setAttribute('data-repo-id', 'R_kgDOPEW3uQ');
    script.setAttribute('data-category', '');
    script.setAttribute('data-category-id', 'DIC_kwDOPEW3uc4CsbpH');
    script.setAttribute('data-mapping', 'pathname');
    script.setAttribute('data-strict', '0');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-emit-metadata', '0');
    script.setAttribute('data-input-position', 'top');
    script.setAttribute('data-theme', 'light');
    script.setAttribute('data-lang',  'pl');
    
    script.setAttribute('crossorigin', 'anonymous');

    script.setAttribute('async', '');

    commentContainer.appendChild(script);
  })();
</script>

  




  </body>
</html>
