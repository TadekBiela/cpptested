<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.0 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="pl" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Czym jest TDD i czy warto je stosować? - CppTested</title>
<meta name="description" content="Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem.  Czym jest TDD  Dla niektórych TDD to zasada, najpierw test (test first), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi, jednak przyjrzyjmy się jej bliżej.  Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada test first to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie.  Metodologia TDD jest jedną z technik programowania ekstremalnego (XP - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować.  Cykl pracy w TDD  We wpisie o F.I.R.S.T. wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządźmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe.  Red - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach.  Green - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”.  Refactor - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post).  Pracując w cyklach, często uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla programistów - “pustego ekranu” :) ).  Zalety TDD  Podczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii.  1) Praca w TDD prowadzi do generowania kodu łatwego w testowaniu. W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować.  2) Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone. Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni.  3) Zyskujemy zaufanie, że nasza implementacja działa. Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”.  4) Konkretyzujemy wymagania, zanim kod jest napisany. W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać.  5) Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy. Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty.  6) Poczucie ciągłego postępu - zwiększona satysfakcja. Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza.  Wady TDD  TDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować.  1) W mojej ocenie TDD nie jest łatwe do nauki. Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nieraz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą.  2) Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste. Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać.  3) Dodatkowy narzut czasowy. Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem.  Podsumowanie  Porównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę.  W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - TDD. Sztuka tworzenia dobrego kodu  Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów  LinkedIn">



<meta property="og:type" content="article">
<meta property="og:locale" content="pl">
<meta property="og:site_name" content="CppTested">
<meta property="og:title" content="Czym jest TDD i czy warto je stosować?">
<meta property="og:url" content="https://cpptested.com/tdd/about-tdd/">


  <meta property="og:description" content="Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem.  Czym jest TDD  Dla niektórych TDD to zasada, najpierw test (test first), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi, jednak przyjrzyjmy się jej bliżej.  Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada test first to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie.  Metodologia TDD jest jedną z technik programowania ekstremalnego (XP - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować.  Cykl pracy w TDD  We wpisie o F.I.R.S.T. wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządźmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe.  Red - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach.  Green - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”.  Refactor - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post).  Pracując w cyklach, często uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla programistów - “pustego ekranu” :) ).  Zalety TDD  Podczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii.  1) Praca w TDD prowadzi do generowania kodu łatwego w testowaniu. W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować.  2) Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone. Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni.  3) Zyskujemy zaufanie, że nasza implementacja działa. Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”.  4) Konkretyzujemy wymagania, zanim kod jest napisany. W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać.  5) Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy. Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty.  6) Poczucie ciągłego postępu - zwiększona satysfakcja. Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza.  Wady TDD  TDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować.  1) W mojej ocenie TDD nie jest łatwe do nauki. Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nieraz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą.  2) Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste. Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać.  3) Dodatkowy narzut czasowy. Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem.  Podsumowanie  Porównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę.  W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - TDD. Sztuka tworzenia dobrego kodu  Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów  LinkedIn">







  <meta property="article:published_time" content="2025-08-26T00:00:00+02:00">






<link rel="canonical" href="https://cpptested.com/tdd/about-tdd/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="CppTested Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<script type="text/javascript" charset="UTF-8" src="//cdn.cookie-script.com/s/e646ffbf6c153feb4a722a4017c1873b.js"></script>

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Czym jest TDD i czy warto je stosować? | CppTested</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Czym jest TDD i czy warto je stosować?" />
<meta name="author" content="Tadeusz Biela" />
<meta property="og:locale" content="pl" />
<meta name="description" content="Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem. Czym jest TDD Dla niektórych TDD to zasada, najpierw test (test first), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi, jednak przyjrzyjmy się jej bliżej. Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada test first to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie. Metodologia TDD jest jedną z technik programowania ekstremalnego (XP - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować. Cykl pracy w TDD We wpisie o F.I.R.S.T. wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządźmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe. Red - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach. Green - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”. Refactor - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post). Pracując w cyklach, często uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla programistów - “pustego ekranu” :) ). Zalety TDD Podczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii. 1) Praca w TDD prowadzi do generowania kodu łatwego w testowaniu. W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować. 2) Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone. Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni. 3) Zyskujemy zaufanie, że nasza implementacja działa. Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”. 4) Konkretyzujemy wymagania, zanim kod jest napisany. W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać. 5) Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy. Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty. 6) Poczucie ciągłego postępu - zwiększona satysfakcja. Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza. Wady TDD TDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować. 1) W mojej ocenie TDD nie jest łatwe do nauki. Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nieraz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą. 2) Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste. Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać. 3) Dodatkowy narzut czasowy. Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem. Podsumowanie Porównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę. W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - TDD. Sztuka tworzenia dobrego kodu Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn" />
<meta property="og:description" content="Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem. Czym jest TDD Dla niektórych TDD to zasada, najpierw test (test first), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi, jednak przyjrzyjmy się jej bliżej. Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada test first to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie. Metodologia TDD jest jedną z technik programowania ekstremalnego (XP - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować. Cykl pracy w TDD We wpisie o F.I.R.S.T. wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządźmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe. Red - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach. Green - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”. Refactor - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post). Pracując w cyklach, często uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla programistów - “pustego ekranu” :) ). Zalety TDD Podczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii. 1) Praca w TDD prowadzi do generowania kodu łatwego w testowaniu. W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować. 2) Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone. Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni. 3) Zyskujemy zaufanie, że nasza implementacja działa. Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”. 4) Konkretyzujemy wymagania, zanim kod jest napisany. W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać. 5) Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy. Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty. 6) Poczucie ciągłego postępu - zwiększona satysfakcja. Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza. Wady TDD TDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować. 1) W mojej ocenie TDD nie jest łatwe do nauki. Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nieraz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą. 2) Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste. Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać. 3) Dodatkowy narzut czasowy. Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem. Podsumowanie Porównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę. W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - TDD. Sztuka tworzenia dobrego kodu Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn" />
<link rel="canonical" href="https://cpptested.com/tdd/about-tdd/" />
<meta property="og:url" content="https://cpptested.com/tdd/about-tdd/" />
<meta property="og:site_name" content="CppTested" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-08-26T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Czym jest TDD i czy warto je stosować?" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Tadeusz Biela"},"dateModified":"2025-08-26T00:00:00+02:00","datePublished":"2025-08-26T00:00:00+02:00","description":"Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem. Czym jest TDD Dla niektórych TDD to zasada, najpierw test (test first), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi, jednak przyjrzyjmy się jej bliżej. Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada test first to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie. Metodologia TDD jest jedną z technik programowania ekstremalnego (XP - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować. Cykl pracy w TDD We wpisie o F.I.R.S.T. wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządźmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe. Red - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach. Green - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”. Refactor - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post). Pracując w cyklach, często uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla programistów - “pustego ekranu” :) ). Zalety TDD Podczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii. 1) Praca w TDD prowadzi do generowania kodu łatwego w testowaniu. W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować. 2) Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone. Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni. 3) Zyskujemy zaufanie, że nasza implementacja działa. Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”. 4) Konkretyzujemy wymagania, zanim kod jest napisany. W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać. 5) Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy. Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty. 6) Poczucie ciągłego postępu - zwiększona satysfakcja. Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza. Wady TDD TDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować. 1) W mojej ocenie TDD nie jest łatwe do nauki. Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nieraz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą. 2) Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste. Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać. 3) Dodatkowy narzut czasowy. Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem. Podsumowanie Porównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę. W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - TDD. Sztuka tworzenia dobrego kodu Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn","headline":"Czym jest TDD i czy warto je stosować?","mainEntityOfPage":{"@type":"WebPage","@id":"https://cpptested.com/tdd/about-tdd/"},"url":"https://cpptested.com/tdd/about-tdd/"}</script>
<!-- End Jekyll SEO tag -->


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HKF97SJC9Z"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HKF97SJC9Z');
</script>

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<link rel="icon" type="image/png" href="/favicon.png">

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Przejdź do nawigacji</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Przejdź do treści</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Przejdź do stopki</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
	<a href="/" class="site-logo">
	  <span style="color: white; font-family: Courier, monospace;">Cpp</span>
  	  <span style="color: #28a745; font-family: Courier, monospace;">Tested</span>
	  <span class="blinking-cursor">|</span>
	</a>	
        <a class="site-title" href="/">
          CppTested
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/posts/"
                
                
              >Wpisy</a>
            </li><li class="masthead__menu-item">
              <a
                href="/categories/"
                
                
              >Kategorie</a>
            </li><li class="masthead__menu-item">
              <a
                href="/tags/"
                
                
              >Tagi</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >O mnie</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Przełącz wyszukiwanie</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Przełącz menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Czym jest TDD i czy warto je stosować?">
    <meta itemprop="description" content="Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem.Czym jest TDDDla niektórych TDD to zasada, najpierw test (test first), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi, jednak przyjrzyjmy się jej bliżej.Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada test first to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie.Metodologia TDD jest jedną z technik programowania ekstremalnego (XP - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować.Cykl pracy w TDDWe wpisie o F.I.R.S.T. wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządźmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe.Red - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach.Green - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”.Refactor - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post).Pracując w cyklach, często uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla programistów - “pustego ekranu” :) ).Zalety TDDPodczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii.1) Praca w TDD prowadzi do generowania kodu łatwego w testowaniu.W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować.2) Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone.Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni.3) Zyskujemy zaufanie, że nasza implementacja działa.Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”.4) Konkretyzujemy wymagania, zanim kod jest napisany.W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać.5) Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy.Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty.6) Poczucie ciągłego postępu - zwiększona satysfakcja.Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza.Wady TDDTDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować.1) W mojej ocenie TDD nie jest łatwe do nauki.Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nieraz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą.2) Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste.Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać.3) Dodatkowy narzut czasowy.Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem.PodsumowaniePorównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę.W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - TDD. Sztuka tworzenia dobrego koduAutor: Tadeusz BielaProgramista C++ | Entuzjasta TDD | Fan unit testówLinkedIn">
    <meta itemprop="datePublished" content="2025-08-26T00:00:00+02:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://cpptested.com/tdd/about-tdd/" itemprop="url">Czym jest TDD i czy warto je stosować?
</a>
          </h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-08-26T00:00:00+02:00">26 sierpnia 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          5 minut(y)
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Spis treści</h4></header>
              <ul class="toc__menu"><li><a href="#czym-jest-tdd">Czym jest TDD</a></li><li><a href="#cykl-pracy-w-tdd">Cykl pracy w TDD</a></li><li><a href="#zalety-tdd">Zalety TDD</a></li><li><a href="#wady-tdd">Wady TDD</a></li><li><a href="#podsumowanie">Podsumowanie</a></li></ul>
            </nav>
          </aside>
        
        <p>Test Driven Development to metoda pracy, która bazuje głównie na unit testach. Tworzymy oprogramowanie w cyklach, przyrostowo, a każda zmiana poprzedzona jest testem.</p>

<h3 id="czym-jest-tdd">Czym jest TDD</h3>

<p>Dla niektórych TDD to zasada, najpierw test (<strong>test first</strong>), dla innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W pewnym stopniu zgodzę się ze wszystkimi, jednak przyjrzyjmy się jej bliżej.</p>

<p>Test Driven Development to metodologia stawiająca unit testy na kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada <strong>test first</strong> to pierwszy krok w TDD, ale to nie wszystko. W miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest to pewien dodatkowy narzut i wydłuża nam czas implementacji, jednak tylko pozornie. Nie tracimy go w tak dużym stopniu przy debugowaniu i próbie przetestowania naszego rozwiązania, gdy jest już gotowe, a testów jeszcze nie ma. Podczas rozwoju naszego kodu w metodologii TDD tworzymy testowalne rozwiązanie.</p>

<p>Metodologia TDD jest jedną z technik programowania ekstremalnego (<a href="https://en.wikipedia.org/wiki/Extreme_programming" target="_blank" rel="noopener">XP</a> - eXtreme Programming). Jej autorem jest Kent Beck, znany i ceniony specjalista IT, choć sam siebie uważa za odtwórcę TDD :). O wszystkich technikach XP z pewnością napiszę osobny post bo warto je znać i stosować.</p>

<h3 id="cykl-pracy-w-tdd">Cykl pracy w TDD</h3>

<p>We wpisie o <a href="https://cpptested.com/unit%20testing/first-reguly-ut/" target="_blank" rel="noopener">F.I.R.S.T.</a> wspominałem o cyklu Red -&gt; Green -&gt; Refactor, używanym w Test Driven Development. Cykl ten to pewien rytm wyznaczający naszą pracę w tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządźmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe.</p>

<p><strong>Red</strong> - każdy cykl rozpoczynamy od napisania testu. W tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który ma sprawdzać następny krok rozwoju naszej implementacji. Nie tworzymy wszystkich testów naraz. Tylko jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w kolejnych krokach.</p>

<p><strong>Green</strong> - kiedy test jest już gotowy i nie przechodzi, czas dopisać brakującą implementację tak, aby kod spełniał wymagania testu. Nie więcej. Ważne jest to, że potrzebujemy implementacji, która ma za zadanie sprawić, aby test przeszedł. Nie musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile wystarczy, aby test się “zazielenił”.</p>

<p><strong>Refactor</strong> - tutaj jest miejsce na poprawki i pracę z kodem. Na początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak najbardziej możemy popracować też nad testami. Tak, aby zarówno kod, jak i testy trzymały pewien poziom. Unit testy to nie dziki zachód, też powinny spełniać dobre praktyki, jak DRY czy AAA (o tym złotym standardzie napiszę z pewnością post).</p>

<p>Pracując w cyklach, często uruchamiamy testy. Mamy więc pewność, że nasz kod działa, a w przypadku pomyłki, szybko ją zlokalizujemy i naprawimy. W tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na odcięcie zależności. W TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom “pustej kartki” (wersja dla programistów - “pustego ekranu” :) ).</p>

<h3 id="zalety-tdd">Zalety TDD</h3>

<p>Podczas nauki i pracy w TDD zauważyłem sporo zalet, które mogą nie być widoczne na początku, gdy jeszcze nie mamy doświadczenia w tej metodologii.</p>

<p><strong>1)</strong> Praca w TDD prowadzi do generowania kodu łatwego w testowaniu.
W przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a gdy już uznamy, że robi to, co wydaje nam się, że powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by odciąć zależności, aby móc go przetestować.</p>

<p><strong>2)</strong> Koniec ze statusem naszego taska w stylu: “Mam już gotowe, tylko testy muszę dopisać”. Po czym mijają kolejne dni, a zadanie wciąż nie jest ukończone.
Ta zaleta mocno łączy się z pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy mówimy, że coś jest gotowe, to jest i tyle. Stajemy się bardziej wiarygodni i profesjonalni.</p>

<p><strong>3)</strong> Zyskujemy zaufanie, że nasza implementacja działa.
Oczywiście musimy zagwarantować, że wszystkie przypadki testowe są uwzględnione. Nie tylko tak zwany “happy path”.</p>

<p><strong>4)</strong> Konkretyzujemy wymagania, zanim kod jest napisany.
W tradycyjnym podejściu, gdy otrzymujemy lub wybieramy zadanie, tworzy się nam w głowie wstępny koncept, co nowa implementacja ma robić i jak ma to robić. Ten koncept może jednak być błędny, a my możemy dojść do momentu, w którym kod jest gotowy, ale nie do końca robi to, co powinien. W TDD najpierw siadamy do testu i zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie wymagania nasz kod powinien spełniać.</p>

<p><strong>5)</strong> Plastyczność kodu. Dzięki temu, że nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z różnymi rozwiązaniami bez obaw, że coś zepsujemy.
Odkrycie tej zalety TDD zajęło mi trochę czasu, ale było niczym przebłysk. Gdy już wszystkie testy są napisane, a pierwsza wersja rozwiązania działa i przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty.</p>

<p><strong>6)</strong> Poczucie ciągłego postępu - zwiększona satysfakcja.
Gdy kolejny test zmienia swój wynik z czerwonego na zielony, ta prosta rzecz naprawdę cieszy. Odczuwamy, że idziemy do przodu. Ta zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest bardzo cenną zaletą sprawiającą, że nasza codzienna praca jest po prostu przyjemniejsza.</p>

<h3 id="wady-tdd">Wady TDD</h3>

<p>TDD nie jest jednak lekiem na wszystko. To narzędzie, jak każde inne, ma pewien zakres zastosowań. W pewnych sytuacjach jednak nie należy go stosować.</p>

<p><strong>1)</strong> W mojej ocenie TDD nie jest łatwe do nauki.
Aby móc w pełni czerpać z tej metodologii, trzeba przestawić swój sposób myślenia o pisaniu kodu. TDD wymaga innego trybu pracy i na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli nie zna się w pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja tak miałem. Na początku myślałem, że jest to prosta zasada test first. Nieraz porzucałem ją na wczesnym etapie nauki. Po kilku podejściach i dokształceniu się z dobrych źródeł, udało mi się opanować TDD i stałem się jego entuzjastą.</p>

<p><strong>2)</strong> Cykl Red -&gt; Green -&gt; Refactor nie sprawdza się przy rozwiązaniach, które są zbyt małe i oczywiste.
Czasem natrafiamy na takie przypadki, gdzie implementacja nasuwa się sama. Jeśli tylko dobrze znamy wymagania, po napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by mieć pewność, że nie popełniliśmy błędu, i to jest w porządku! TDD ma nam pomagać w naszej pracy, a nie być świętą zasadą, której należy zawsze się trzymać.</p>

<p><strong>3)</strong> Dodatkowy narzut czasowy.
Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż część czasu musimy poświęcić na napisanie unit testów. Nie jest to jednak duża wada, gdyż czas ten zwraca nam się w dłuższej perspektywie. Warto jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem.</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>Porównując zalety i wady TDD myślę, że można stwierdzić, że zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po prostu spróbuj - jednak nie raz czy dwa. Daj tej metodologii trochę czasu, a gwarantuję, że odczujesz różnicę.</p>

<p>W tym wpisie chciałem przybliżyć i w prostych słowach opisać, na czym polega praca w TDD. Jestem przekonany, że opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na wyższy poziom i jest warte wysiłku jego nauki i praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli “ojca” TDD, Kenta Becka. Napisał on świetną książkę - <a href="https://lubimyczytac.pl/ksiazka/223586/tdd-sztuka-tworzenia-dobrego-kodu" target="_blank" rel="noopener">TDD. Sztuka tworzenia dobrego kodu</a></p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tagi: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#clean-code" class="page__taxonomy-item p-category" rel="tag">clean code</a><span class="sep">, </span>
    
      <a href="/tags/#code-quality" class="page__taxonomy-item p-category" rel="tag">code quality</a><span class="sep">, </span>
    
      <a href="/tags/#developer-practices" class="page__taxonomy-item p-category" rel="tag">developer practices</a><span class="sep">, </span>
    
      <a href="/tags/#refactoring" class="page__taxonomy-item p-category" rel="tag">refactoring</a><span class="sep">, </span>
    
      <a href="/tags/#test-driven-development" class="page__taxonomy-item p-category" rel="tag">test driven development</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Kategorie: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#tdd" class="page__taxonomy-item p-category" rel="tag">tdd</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Ostatnia aktualizacja:</strong> <time class="dt-published" datetime="2025-08-26T00:00:00+02:00">26 sierpnia 2025</time></p>

      </footer>

      <section class="page__share">
  <h4 class="page__share-title">Udostępnij</h4>

  <a href="https://x.com/intent/tweet?text=Czym+jest+TDD+i+czy+warto+je+stosowa%C4%87%3F%20https%3A%2F%2Fcpptested.com%2Ftdd%2Fabout-tdd%2F" class="btn btn--x" aria-label="Share on X" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Udostępnij X">
    <i class="fas fa-fw fa-share-alt" aria-hidden="true"></i><span> X</span>
  </a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fcpptested.com%2Ftdd%2Fabout-tdd%2F" class="btn btn--facebook" aria-label="Share on Facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Udostępnij Facebook">
    <i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span>
  </a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://cpptested.com/tdd/about-tdd/" class="btn btn--linkedin" aria-label="Share on LinkedIn" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Udostępnij LinkedIn">
    <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span>
  </a>
</section>


      
  <nav class="pagination">
    
      <a href="/unit-testing/first-reguly-ut/" class="pagination--pager" title="F.I.R.S.T. - jak pisać unit testy lepiej.">Poprzednia</a>
    
    
      <a href="/unit-testing/AAA-golden-standard/" class="pagination--pager" title="AAA - złoty standard unit testów.">Następna</a>
    
  </nav>


    </div>

    
      
        <div class="page__comments">
  
  
      <h4 class="page__comments-title">Zostaw komentarz</h4>
      <div class="giscus"></div>
      <script src="https://giscus.app/client.js"
              data-repo="TadekBiela/cpptested"
              data-repo-id="R_kgDOPEW3uQ"
              data-category="Announcements"
              data-category-id="DIC_kwDOPEW3uc4CsbpH"
              data-mapping="pathname"
              data-strict="0"
              data-reactions-enabled="1"
              data-emit-metadata="0"
              data-input-position="top"
              data-theme="light"
              data-lang="pl"
              crossorigin="anonymous"
              async>
      </script>
    
</div>

      
    
  </article>

  
  
    
<div class="page__related">
  
  <h2 class="page__related-title">Także może Ci się spodobać</h2>
  <div class="grid__wrapper">
    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/multithreading/multithreading-fundamentals/" rel="permalink">Fundamenty myślenia wielowątkowego
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2026-02-24T00:00:00+01:00">24 lutego 2026</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          6 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Podstawy są ważne, bez nich nie możemy ruszyć dalej z nauką, szczególnie, gdy chcemy opanować rzeczy o dużo większej złożoności, jak na przykład wielowątkowo...</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/clean%20code/gtest-mistakes/" rel="permalink">6 najczęstszych błędów z Google Test.
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2026-01-26T00:00:00+01:00">26 stycznia 2026</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          11 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Google Test to chyba najbardziej znany i używany framework testowy w projektach C++. Zawiera w sobie masę przydatnych narzędzi do tworzenia różnych rodzajów ...</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/unit-testing/handling-globals/" rel="permalink">Zależności globalne - jak poradzić sobie z nimi w unit testach
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-12-16T00:00:00+01:00">16 grudnia 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          7 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Każdy dobry unit test powinien nie tylko weryfikować nasz kod ale również odcinać zewnętrzne zależności, tak, aby przeprowadzenie testu odbywało się w izolac...</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/clean-code/dry-and-other-principles/" rel="permalink">DRY, YAGNI, KISS i inne. Uniwersalne zasady dla każdego programisty.
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-11-17T00:00:00+01:00">17 listopada 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          9 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Te tajemnicze akronimy skrywają w sobie dekady doświadczeń naszych programistycznych poprzedników. Choć brzmi to nieco patetycznie, tak właśnie jest. Zasady,...</p>
  </article>
</div>

    
  </div>
</div>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Wprowadź kryteria wyszukiwania...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Wprowadź kryteria wyszukiwania..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    <li style="justify-content: space-between; align-items: center;">
      <img src="/favicon.png" alt="Logo" style="">
    </li>

    
      <li><strong>Obserwuj:</strong></li>
    

    
      
        
          <li><a href="https://www.linkedin.com/in/tadeuszbiela/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://github.com/TadekBiela" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> RSS</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2026 <a href="https://cpptested.com">CppTested</a>. Powstało dzięki <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function () {
    var commentContainer = document.querySelector('#giscus-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');

    script.setAttribute('src', 'https://giscus.app/client.js');
    script.setAttribute('data-repo', '');
    script.setAttribute('data-repo-id', 'R_kgDOPEW3uQ');
    script.setAttribute('data-category', '');
    script.setAttribute('data-category-id', 'DIC_kwDOPEW3uc4CsbpH');
    script.setAttribute('data-mapping', 'pathname');
    script.setAttribute('data-strict', '0');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-emit-metadata', '0');
    script.setAttribute('data-input-position', 'top');
    script.setAttribute('data-theme', 'light');
    script.setAttribute('data-lang',  'pl');
    
    script.setAttribute('crossorigin', 'anonymous');

    script.setAttribute('async', '');

    commentContainer.appendChild(script);
  })();
</script>

  




  </body>
</html>
