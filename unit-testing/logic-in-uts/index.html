<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.0 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="pl" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Największy wróg unit testów - logika. - CppTested</title>
<meta name="description" content="Logika, przepływ sterowania, instrukcje warunkowe - to dzięki nim nasze programy mogą spełniać szeregi wymagań i oczekiwań. Dzięki nim możemy rozbudowywać nasz program, rozwijać obecne funkcjonalności oraz dodawać nowe. Każdy programista wie, że bez nich tworzenie oprogramowania nie mogłoby mieć miejsca. Czy zatem nasze unit testy, również powinny zawierać logikę? Zdecydowanie nie, i w tym wpisie wyjaśnię dlaczego, tym razem odpowiedź jest taka klarowna, a nie, jak to nieraz w naszej branży bywa - “to zależy”.  Logika zwiększa ryzyko błędu  Każde rozgałęzienie procesu przetwarzania w naszym kodzie zwiększa jego podatność na błędy. Unit testy to narzędzie do weryfikowania założeń względem pisanego przez nas oprogramowania. Powinny one być jasno zdefiniowane. Jeśli w testach pojawia się logika to najczęściej jest to droga na skróty, by zaoszczędzić trochę czasu na dokładniejsze przeanalizowanie wymagań względem konkretnych scenariuszy użycia testowanego kodu.  Wyobraźmy sobie klasę do naliczania rabatów DiscountCalculator. Zamiast napisać trzy proste testy, w poniższym “sprytnym” przykładzie użyta została nie tylko pętla for, ale również instrukcje warunkowe if/else, aby przetestować różne progi rabatowe w jednym miejscu.  TEST_F(DiscountCalculatorTest, calculate_CheckAllDiscounts_ShouldApplyCorrectRates) {     const std::vector&lt;double&gt; purchases { 50.0, 150.0, 300.0 };     DiscountCalculator calculator {};      for (const auto&amp; amount : purchases)     {         const auto result { calculator.calculate(amount) };          if (amount &lt; 100.0)         {             EXPECT_NEAR(0.0, result, 0.001);         }         else if (100.0 &lt;= amount &amp;&amp; amount &lt; 200.0)         {             EXPECT_NEAR(amount * 0.1, result, 0.001);         }         else         {             EXPECT_NEAR(amount * 0.2, result, 0.001);          }     } }   Dodanie logiki do testu powoduje szereg problemów. Jeśli test nie przejdzie, to nie tylko musimy debugować nasz kod, ale również kod testu. A tutaj prawidłowo napisane testy dla metody calculate.  TEST_F(DiscountCalculatorTest, calculate_TooLowAmount_ShouldReturnNoDiscount) {     const auto amount { 50.0 };     DiscountCalculator calculator {};      const auto result { calculator.calculate(amount) };      EXPECT_NEAR(0.0, result, 0.001); }  TEST_F(DiscountCalculatorTest, calculate_FirstThresholdAmount_ShouldReturn10PercentDiscount) {     const auto amount { 150.0 };     DiscountCalculator calculator {};      const auto result { calculator.calculate(amount) };      EXPECT_NEAR(15.0, result, 0.001); }  TEST_F(DiscountCalculatorTest, calculate_SecondThresholdAmount_ShouldReturn20PercentDiscount) {     const auto amount { 300.0 };     DiscountCalculator calculator {};      const auto result { calculator.calculate(amount) };      EXPECT_NEAR(60.0, result, 0.001); }   Jeśli unit testy nie mają prostej sekwencyjnej struktury tylko rozgałęziają się na różne scenariusze, to tracimy jedną z najważniejszych cech dobrych unit testów, powtarzalność. Tak w zasadzie to logika w testach łamie również inną zasadę z akronimu F.I.R.S.T. - I. Testy, przez wprowadzone instrukcje warunkowe, mogą utracić swoją niezależność względem innych testów. Zwłaszcza, gdy korzystają ze wspólnej metody narzędziowej klasy test siuty.  Dla przykładu testujemy klasę OrderProcessor. Mamy metodę narzędziową setupMocks, która w zależności od przekazanych flag, konfiguruje mocki dla różnych scenariuszy.  class OrderProcessorTest : public testing::Test { protected:     // Wspólna metoda narzędziowa z&amp;nbsp;ukrytą logiką sterującą     auto setupProcessor(bool isGoldCustomer, bool hasDiscount) -&gt; void     {         if (isGoldCustomer)         {             EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(Status::Gold));         }          if (hasDiscount)         {             EXPECT_CALL(discountServiceMock, apply(_)).WillOnce(Return(true));         }         else         {             // Brak zniżki może zmieniać stan mocka w&amp;nbsp;sposób,              // którego inny test się nie spodziewa             EXPECT_CALL(discountServiceMock, apply(_)).Times(0);         }     }      MockCustomerService customerServiceMock;     MockDiscountService discountServiceMock; };  TEST_F(OrderProcessorTest, process_GoldCustomerWithoutDiscount_ShouldWork) {     setupProcessor(true, false);     OrderProcessor processor { customerServiceMock, discountServiceMock };      const auto result { processor.process(Order{}) };      EXPECT_TRUE(result.success); }   To jest dokładnie ta sytuacja, o której wspominałem we wpisie o DRY i innych zasadach programowania. Nie zawsze stosowanie DRY w testach to dobry pomysł. Poniżej poprawna wersja.  class OrderProcessorTest : public testing::Test { protected:     auto setupProcessorForCustomerWithoutDiscount(const Status customerStatus) -&gt; void     {         EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(customerStatus));     }      auto setupProcessorForCustomerWithDiscount(const Status customerStatus) -&gt; void     {         EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(customerStatus));         EXPECT_CALL(discountServiceMock, apply(_)).WillOnce(Return(true));     }        MockCustomerService customerServiceMock;     MockDiscountService discountServiceMock; };  TEST_F(OrderProcessorTest, process_GoldCustomerWithoutDiscount_ShouldWork) {     setupProcessorForCustomerWithoutDiscount(Status::Gold);     OrderProcessor processor { customerServiceMock, discountServiceMock };      const auto result { processor.process(Order{}) };      EXPECT_TRUE(result.success); }   W tym przykładzie moglibyśmy w zasadzie, po prostu usunąć metody narzędziowe i bezpośrednio dodawać EXPECT_CALL do testów. Są jednak przypadki, gdzie takich instrukcji jest więcej i wtedy warto rozważyć stworzenie metody narzędziowej. To bardzo dobra technika, ciało testu się skraca, a dodatkowo dobrze dobrana nazwa metody dodaje więcej kontekstu. Pamiętaj tylko bez logiki! ;)  Powielanie błędów z kodu produkcyjnego  Częstym powodem dodawania logiki do unit testów jest chęć odwzorowania przepływu sterowania w testowanym kodzie. Naraża nas to jednak na powielenie błędów z produkcyjnego kodu. Unit testy powinny wykrywać defekty, nie powielać logikę doprowadzając do sytuacji, w której testy w zasadzie są kopią testowanego kodu.  Tym razem mamy klasę LoyaltyPointsCalculator, liczymy punkty lojalnościowe. Kto nie lubi ekstra rabatów ;) Logiką, w tym przypadku, jest kopia algorytmu z kodu produkcyjnego. Nie ma tam wprawdzie ifa, niemniej zamiast podać konkretną liczbę, nasz test liczy sobie oczekiwaną wartość podczas swojego wykonywania.  TEST_F(LoyaltyPointsTest, calculatePoints_LargeOrder_ShouldReturnPointsWithBonus) {     const double orderValue { 600.0 };     const double baseRate { 10.0 };     const double bonusMultiplier { 1.05 };     LoyaltyPointsCalculator calculator {};      EXPECT_NEAR((orderValue / baseRate) * bonusMultiplier, calculator.calculate(orderValue), 0.001); }   To nic innego jak fragment implementacji przeklejony do testu. Nie mamy żadnej gwarancji, że nasz test nie odziedziczył przypadkiem logicznego błędu, który miał przecież wykrywać. W asercji powinna się znaleźć pożądana wartość, a nie sposób jej wyliczania. Poniżej poprawiony test.  TEST_F(LoyaltyPointsTest, calculatePoints_LargeOrder_ShouldReturnPointsWithBonus) {     const auto orderValue { 600.0 };     LoyaltyPointsCalculator calculator {};      const auto result { calculator.calculate(orderValue) };      EXPECT_NEAR(63.0, result, 0.1); }   Możliwe, że zastanawiasz się jeszcze dlaczego podawać już obliczoną wartość. Przecież i tak trzeba było ją policzyć. Tak, zgadza się, jednak takich testów z pewnością napisalibyśmy więcej. Jeśli za każdym razem przekopiowalibyśmy logikę z kodu produkcyjnego do testów, to nic by one nie wykryły. Błąd natomiast zapewne wykryliby użytkownicy, co było by znacznie bardziej kosztowne i bolesne. Jeśli obliczamy wartości sami i wpisujemy je bezpośrednio do naszych testów to istnieje dużo mniejsza szansa, że za każdym razem obliczymy ją niepoprawnie.  Zmniejszenie czytelności  Logika, na przykład w postaci bloku switch/case może utrudniać nam odczytanie intencji testów. Nazwy są niejasne, mało konkretne. Odzwierciedlają tylko to, że pojedynczy unit test testuje więcej niż jeden scenariusz. Dlatego tak ciężko dobrać prawidłową nazwę. Tracimy kontekst bo jest on rozmywany przez logikę, która steruje częścią asercji w zależności od tego co testowana metoda zwróci.  Dla przykładu mamy klasę OrderNotifier, która między innymi nadaje priorytety otrzymanym zamówieniom. W zależności od statusu, priorytet będzie inny. Poniżej przykład wszechstronnego, “mega” unit testu.  TEST(OrderNotifierTest, determinePriority_MultipleStatuses_ShouldReturnCorrectPriority) {     std::vector&lt;OrderStatus&gt; statuses { OrderStatus::New, OrderStatus::Shipped, OrderStatus::Cancelled };     OrderNotifier notifier {};      for (const auto&amp; status : statuses)     {         const auto priority { notifier.determinePriority(status) };          switch (status)         {             case OrderStatus::New:                 EXPECT_EQ(Priority::Low, priority);                 break;             case OrderStatus::Shipped:                 EXPECT_EQ(Priority::High, priority);                 break;             case OrderStatus::Cancelled:                 EXPECT_EQ(Priority::Critical, priority);                 break;         }     } }   Pomimo, iż sama nazwa trzyma się standardu triple A to nie za wiele to daje. Nazwa jest po prostu zbyt ogólna. Jedyne czego możemy być pewni, to, że testuje metodę determinePriority klasy OrderNotifier. Z pewnością przyznasz, że to mało konkretne ;) Ciało testu również nie trzyma standardu AAA. Bloki Act i Assert są wymieszane. Jeśli test zfailuje to w logach będziemy musieli szukać odpowiedzi. Gdyby to były osobne testy, po samej nazwie wiedzielibyśmy, co poszło nie tak.  Zobacz jak to powinno wyglądać poprawnie.  TEST_F(OrderNotifierTest, determinePriority_NewOrder_ShouldReturnLowPriority) {     OrderNotifier notifier {};      const auto priority { notifier.determinePriority(OrderStatus::New) };      EXPECT_EQ(Priority::Low, priority); }  TEST_F(OrderNotifierTest, determinePriority_OrderShipped_ShouldReturnHighPriority) {     OrderNotifier notifier {};      const auto priority { notifier.determinePriority(OrderStatus::Shipped) };      EXPECT_EQ(Priority::High, priority); }  TEST_F(OrderNotifierTest, determinePriority_OrderCancelled_ShouldReturnCriticalPriority) {     OrderNotifier notifier {};      const auto priority { notifier.determinePriority(OrderStatus::Cancelled) };      EXPECT_EQ(Priority::Critical, priority); }   I teraz to się nazywają czytelne testy! Prawda? Wszystko widoczne jak na tacy. Proste i skuteczne.  Dopuszczalne rodzaje logiki  Istnieją pewne elementy logiki, które nie mają negatywnych skutków dla naszych unit testów i wręcz mogą poprawić ich czytelność - pętle. Ich stosowanie z pewnością będzie wskazane przy weryfikacji kontenerów. Niemniej, za każdym razem, gdy chcemy użyć pętli w unit testach powinniśmy sobie zadać pytanie: czy dodanie pętli jest niezbędne, by zachować czytelność i prostotę weryfikacji lub do realizacji konkretnego scenariusza testowego? Jeśli odpowiedź brzmi tak, śmiało użyj pętli.  TEST_F(ReportBatchProcessorTest, processReports_AllValidReports_EachReportIsMarkedAsProcessedAndNoErrors) {     const std::vector&lt;Report&gt; reports { { &quot;ID_1&quot; }, { &quot;ID_2&quot; }, { &quot;ID_3&quot; } };     ReportBatchProcessor processor { reports };      processor.processReports();      const auto results { processor.getProcessedReports() };     ASSERT_THAT(results, testing::SizeIs(reports.size()));     for (const auto&amp; report : results)     {         EXPECT_THAT(report.isProcessed(), testing::IsTrue());         EXPECT_THAT(report.errorCode(), testing::Eq(0));     } }   W powyższym przykładnie zastosowanie pętli for jak najbardziej jest poprawne. Moglibyśmy wprawdzie po prostu napisać 6 asercji zamiast dwóch w pętli. Jednak jeśli elementów w kontenerze byłoby więcej, kod testu niepotrzebnie by się wydłużył. Zauważ przy okazji jakich asercji użyłem: ASSERT_THAT i EXPECT_THAT. Znasz je może? Ja wcześniej nie znałem. Po kilku testach stwierdziłem, że warto się im przyjrzeć bliżej. Z pewnością przygotuje osobny post o optymalizacji czytelności wyników testów, gdy się niepowiodą, tak, aby sam komunikat Google Testa jasno wskazywał nam co poszło nie tak.  Podsumowanie  Mam nadzieję, że tym wpisem przekonałem Cię do niedodawania logiki to Twoich unit testów oraz uważniejszego code review swoich kolegów i koleżanek z zespołu. Ja sam wciąż zbyt często spotykam się z tym problemem i staram się dzielić wiedzą o tym jak pisać dobrej jakości unit testy. Co myślisz o tak rygorystycznym podejściu do braku logiki w unit testach? Uważasz to za przesadę, a może się ze mną zgadzasz? Koniecznie podziel się swoją opinią w komentarzu :)  Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów  LinkedIn">



<meta property="og:type" content="article">
<meta property="og:locale" content="pl">
<meta property="og:site_name" content="CppTested">
<meta property="og:title" content="Największy wróg unit testów - logika.">
<meta property="og:url" content="https://cpptested.com/unit-testing/logic-in-uts/">


  <meta property="og:description" content="Logika, przepływ sterowania, instrukcje warunkowe - to dzięki nim nasze programy mogą spełniać szeregi wymagań i oczekiwań. Dzięki nim możemy rozbudowywać nasz program, rozwijać obecne funkcjonalności oraz dodawać nowe. Każdy programista wie, że bez nich tworzenie oprogramowania nie mogłoby mieć miejsca. Czy zatem nasze unit testy, również powinny zawierać logikę? Zdecydowanie nie, i w tym wpisie wyjaśnię dlaczego, tym razem odpowiedź jest taka klarowna, a nie, jak to nieraz w naszej branży bywa - “to zależy”.  Logika zwiększa ryzyko błędu  Każde rozgałęzienie procesu przetwarzania w naszym kodzie zwiększa jego podatność na błędy. Unit testy to narzędzie do weryfikowania założeń względem pisanego przez nas oprogramowania. Powinny one być jasno zdefiniowane. Jeśli w testach pojawia się logika to najczęściej jest to droga na skróty, by zaoszczędzić trochę czasu na dokładniejsze przeanalizowanie wymagań względem konkretnych scenariuszy użycia testowanego kodu.  Wyobraźmy sobie klasę do naliczania rabatów DiscountCalculator. Zamiast napisać trzy proste testy, w poniższym “sprytnym” przykładzie użyta została nie tylko pętla for, ale również instrukcje warunkowe if/else, aby przetestować różne progi rabatowe w jednym miejscu.  TEST_F(DiscountCalculatorTest, calculate_CheckAllDiscounts_ShouldApplyCorrectRates) {     const std::vector&lt;double&gt; purchases { 50.0, 150.0, 300.0 };     DiscountCalculator calculator {};      for (const auto&amp; amount : purchases)     {         const auto result { calculator.calculate(amount) };          if (amount &lt; 100.0)         {             EXPECT_NEAR(0.0, result, 0.001);         }         else if (100.0 &lt;= amount &amp;&amp; amount &lt; 200.0)         {             EXPECT_NEAR(amount * 0.1, result, 0.001);         }         else         {             EXPECT_NEAR(amount * 0.2, result, 0.001);          }     } }   Dodanie logiki do testu powoduje szereg problemów. Jeśli test nie przejdzie, to nie tylko musimy debugować nasz kod, ale również kod testu. A tutaj prawidłowo napisane testy dla metody calculate.  TEST_F(DiscountCalculatorTest, calculate_TooLowAmount_ShouldReturnNoDiscount) {     const auto amount { 50.0 };     DiscountCalculator calculator {};      const auto result { calculator.calculate(amount) };      EXPECT_NEAR(0.0, result, 0.001); }  TEST_F(DiscountCalculatorTest, calculate_FirstThresholdAmount_ShouldReturn10PercentDiscount) {     const auto amount { 150.0 };     DiscountCalculator calculator {};      const auto result { calculator.calculate(amount) };      EXPECT_NEAR(15.0, result, 0.001); }  TEST_F(DiscountCalculatorTest, calculate_SecondThresholdAmount_ShouldReturn20PercentDiscount) {     const auto amount { 300.0 };     DiscountCalculator calculator {};      const auto result { calculator.calculate(amount) };      EXPECT_NEAR(60.0, result, 0.001); }   Jeśli unit testy nie mają prostej sekwencyjnej struktury tylko rozgałęziają się na różne scenariusze, to tracimy jedną z najważniejszych cech dobrych unit testów, powtarzalność. Tak w zasadzie to logika w testach łamie również inną zasadę z akronimu F.I.R.S.T. - I. Testy, przez wprowadzone instrukcje warunkowe, mogą utracić swoją niezależność względem innych testów. Zwłaszcza, gdy korzystają ze wspólnej metody narzędziowej klasy test siuty.  Dla przykładu testujemy klasę OrderProcessor. Mamy metodę narzędziową setupMocks, która w zależności od przekazanych flag, konfiguruje mocki dla różnych scenariuszy.  class OrderProcessorTest : public testing::Test { protected:     // Wspólna metoda narzędziowa z&amp;nbsp;ukrytą logiką sterującą     auto setupProcessor(bool isGoldCustomer, bool hasDiscount) -&gt; void     {         if (isGoldCustomer)         {             EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(Status::Gold));         }          if (hasDiscount)         {             EXPECT_CALL(discountServiceMock, apply(_)).WillOnce(Return(true));         }         else         {             // Brak zniżki może zmieniać stan mocka w&amp;nbsp;sposób,              // którego inny test się nie spodziewa             EXPECT_CALL(discountServiceMock, apply(_)).Times(0);         }     }      MockCustomerService customerServiceMock;     MockDiscountService discountServiceMock; };  TEST_F(OrderProcessorTest, process_GoldCustomerWithoutDiscount_ShouldWork) {     setupProcessor(true, false);     OrderProcessor processor { customerServiceMock, discountServiceMock };      const auto result { processor.process(Order{}) };      EXPECT_TRUE(result.success); }   To jest dokładnie ta sytuacja, o której wspominałem we wpisie o DRY i innych zasadach programowania. Nie zawsze stosowanie DRY w testach to dobry pomysł. Poniżej poprawna wersja.  class OrderProcessorTest : public testing::Test { protected:     auto setupProcessorForCustomerWithoutDiscount(const Status customerStatus) -&gt; void     {         EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(customerStatus));     }      auto setupProcessorForCustomerWithDiscount(const Status customerStatus) -&gt; void     {         EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(customerStatus));         EXPECT_CALL(discountServiceMock, apply(_)).WillOnce(Return(true));     }        MockCustomerService customerServiceMock;     MockDiscountService discountServiceMock; };  TEST_F(OrderProcessorTest, process_GoldCustomerWithoutDiscount_ShouldWork) {     setupProcessorForCustomerWithoutDiscount(Status::Gold);     OrderProcessor processor { customerServiceMock, discountServiceMock };      const auto result { processor.process(Order{}) };      EXPECT_TRUE(result.success); }   W tym przykładzie moglibyśmy w zasadzie, po prostu usunąć metody narzędziowe i bezpośrednio dodawać EXPECT_CALL do testów. Są jednak przypadki, gdzie takich instrukcji jest więcej i wtedy warto rozważyć stworzenie metody narzędziowej. To bardzo dobra technika, ciało testu się skraca, a dodatkowo dobrze dobrana nazwa metody dodaje więcej kontekstu. Pamiętaj tylko bez logiki! ;)  Powielanie błędów z kodu produkcyjnego  Częstym powodem dodawania logiki do unit testów jest chęć odwzorowania przepływu sterowania w testowanym kodzie. Naraża nas to jednak na powielenie błędów z produkcyjnego kodu. Unit testy powinny wykrywać defekty, nie powielać logikę doprowadzając do sytuacji, w której testy w zasadzie są kopią testowanego kodu.  Tym razem mamy klasę LoyaltyPointsCalculator, liczymy punkty lojalnościowe. Kto nie lubi ekstra rabatów ;) Logiką, w tym przypadku, jest kopia algorytmu z kodu produkcyjnego. Nie ma tam wprawdzie ifa, niemniej zamiast podać konkretną liczbę, nasz test liczy sobie oczekiwaną wartość podczas swojego wykonywania.  TEST_F(LoyaltyPointsTest, calculatePoints_LargeOrder_ShouldReturnPointsWithBonus) {     const double orderValue { 600.0 };     const double baseRate { 10.0 };     const double bonusMultiplier { 1.05 };     LoyaltyPointsCalculator calculator {};      EXPECT_NEAR((orderValue / baseRate) * bonusMultiplier, calculator.calculate(orderValue), 0.001); }   To nic innego jak fragment implementacji przeklejony do testu. Nie mamy żadnej gwarancji, że nasz test nie odziedziczył przypadkiem logicznego błędu, który miał przecież wykrywać. W asercji powinna się znaleźć pożądana wartość, a nie sposób jej wyliczania. Poniżej poprawiony test.  TEST_F(LoyaltyPointsTest, calculatePoints_LargeOrder_ShouldReturnPointsWithBonus) {     const auto orderValue { 600.0 };     LoyaltyPointsCalculator calculator {};      const auto result { calculator.calculate(orderValue) };      EXPECT_NEAR(63.0, result, 0.1); }   Możliwe, że zastanawiasz się jeszcze dlaczego podawać już obliczoną wartość. Przecież i tak trzeba było ją policzyć. Tak, zgadza się, jednak takich testów z pewnością napisalibyśmy więcej. Jeśli za każdym razem przekopiowalibyśmy logikę z kodu produkcyjnego do testów, to nic by one nie wykryły. Błąd natomiast zapewne wykryliby użytkownicy, co było by znacznie bardziej kosztowne i bolesne. Jeśli obliczamy wartości sami i wpisujemy je bezpośrednio do naszych testów to istnieje dużo mniejsza szansa, że za każdym razem obliczymy ją niepoprawnie.  Zmniejszenie czytelności  Logika, na przykład w postaci bloku switch/case może utrudniać nam odczytanie intencji testów. Nazwy są niejasne, mało konkretne. Odzwierciedlają tylko to, że pojedynczy unit test testuje więcej niż jeden scenariusz. Dlatego tak ciężko dobrać prawidłową nazwę. Tracimy kontekst bo jest on rozmywany przez logikę, która steruje częścią asercji w zależności od tego co testowana metoda zwróci.  Dla przykładu mamy klasę OrderNotifier, która między innymi nadaje priorytety otrzymanym zamówieniom. W zależności od statusu, priorytet będzie inny. Poniżej przykład wszechstronnego, “mega” unit testu.  TEST(OrderNotifierTest, determinePriority_MultipleStatuses_ShouldReturnCorrectPriority) {     std::vector&lt;OrderStatus&gt; statuses { OrderStatus::New, OrderStatus::Shipped, OrderStatus::Cancelled };     OrderNotifier notifier {};      for (const auto&amp; status : statuses)     {         const auto priority { notifier.determinePriority(status) };          switch (status)         {             case OrderStatus::New:                 EXPECT_EQ(Priority::Low, priority);                 break;             case OrderStatus::Shipped:                 EXPECT_EQ(Priority::High, priority);                 break;             case OrderStatus::Cancelled:                 EXPECT_EQ(Priority::Critical, priority);                 break;         }     } }   Pomimo, iż sama nazwa trzyma się standardu triple A to nie za wiele to daje. Nazwa jest po prostu zbyt ogólna. Jedyne czego możemy być pewni, to, że testuje metodę determinePriority klasy OrderNotifier. Z pewnością przyznasz, że to mało konkretne ;) Ciało testu również nie trzyma standardu AAA. Bloki Act i Assert są wymieszane. Jeśli test zfailuje to w logach będziemy musieli szukać odpowiedzi. Gdyby to były osobne testy, po samej nazwie wiedzielibyśmy, co poszło nie tak.  Zobacz jak to powinno wyglądać poprawnie.  TEST_F(OrderNotifierTest, determinePriority_NewOrder_ShouldReturnLowPriority) {     OrderNotifier notifier {};      const auto priority { notifier.determinePriority(OrderStatus::New) };      EXPECT_EQ(Priority::Low, priority); }  TEST_F(OrderNotifierTest, determinePriority_OrderShipped_ShouldReturnHighPriority) {     OrderNotifier notifier {};      const auto priority { notifier.determinePriority(OrderStatus::Shipped) };      EXPECT_EQ(Priority::High, priority); }  TEST_F(OrderNotifierTest, determinePriority_OrderCancelled_ShouldReturnCriticalPriority) {     OrderNotifier notifier {};      const auto priority { notifier.determinePriority(OrderStatus::Cancelled) };      EXPECT_EQ(Priority::Critical, priority); }   I teraz to się nazywają czytelne testy! Prawda? Wszystko widoczne jak na tacy. Proste i skuteczne.  Dopuszczalne rodzaje logiki  Istnieją pewne elementy logiki, które nie mają negatywnych skutków dla naszych unit testów i wręcz mogą poprawić ich czytelność - pętle. Ich stosowanie z pewnością będzie wskazane przy weryfikacji kontenerów. Niemniej, za każdym razem, gdy chcemy użyć pętli w unit testach powinniśmy sobie zadać pytanie: czy dodanie pętli jest niezbędne, by zachować czytelność i prostotę weryfikacji lub do realizacji konkretnego scenariusza testowego? Jeśli odpowiedź brzmi tak, śmiało użyj pętli.  TEST_F(ReportBatchProcessorTest, processReports_AllValidReports_EachReportIsMarkedAsProcessedAndNoErrors) {     const std::vector&lt;Report&gt; reports { { &quot;ID_1&quot; }, { &quot;ID_2&quot; }, { &quot;ID_3&quot; } };     ReportBatchProcessor processor { reports };      processor.processReports();      const auto results { processor.getProcessedReports() };     ASSERT_THAT(results, testing::SizeIs(reports.size()));     for (const auto&amp; report : results)     {         EXPECT_THAT(report.isProcessed(), testing::IsTrue());         EXPECT_THAT(report.errorCode(), testing::Eq(0));     } }   W powyższym przykładnie zastosowanie pętli for jak najbardziej jest poprawne. Moglibyśmy wprawdzie po prostu napisać 6 asercji zamiast dwóch w pętli. Jednak jeśli elementów w kontenerze byłoby więcej, kod testu niepotrzebnie by się wydłużył. Zauważ przy okazji jakich asercji użyłem: ASSERT_THAT i EXPECT_THAT. Znasz je może? Ja wcześniej nie znałem. Po kilku testach stwierdziłem, że warto się im przyjrzeć bliżej. Z pewnością przygotuje osobny post o optymalizacji czytelności wyników testów, gdy się niepowiodą, tak, aby sam komunikat Google Testa jasno wskazywał nam co poszło nie tak.  Podsumowanie  Mam nadzieję, że tym wpisem przekonałem Cię do niedodawania logiki to Twoich unit testów oraz uważniejszego code review swoich kolegów i koleżanek z zespołu. Ja sam wciąż zbyt często spotykam się z tym problemem i staram się dzielić wiedzą o tym jak pisać dobrej jakości unit testy. Co myślisz o tak rygorystycznym podejściu do braku logiki w unit testach? Uważasz to za przesadę, a może się ze mną zgadzasz? Koniecznie podziel się swoją opinią w komentarzu :)  Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów  LinkedIn">







  <meta property="article:published_time" content="2026-02-23T00:00:00+01:00">






<link rel="canonical" href="https://cpptested.com/unit-testing/logic-in-uts/">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="CppTested Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <!-- start custom head snippets -->

<script type="text/javascript" charset="UTF-8" src="//cdn.cookie-script.com/s/e646ffbf6c153feb4a722a4017c1873b.js"></script>

<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Największy wróg unit testów - logika. | CppTested</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Największy wróg unit testów - logika." />
<meta name="author" content="Tadeusz Biela" />
<meta property="og:locale" content="pl" />
<meta name="description" content="Logika, przepływ sterowania, instrukcje warunkowe - to dzięki nim nasze programy mogą spełniać szeregi wymagań i oczekiwań. Dzięki nim możemy rozbudowywać nasz program, rozwijać obecne funkcjonalności oraz dodawać nowe. Każdy programista wie, że bez nich tworzenie oprogramowania nie mogłoby mieć miejsca. Czy zatem nasze unit testy, również powinny zawierać logikę? Zdecydowanie nie, i w tym wpisie wyjaśnię dlaczego, tym razem odpowiedź jest taka klarowna, a nie, jak to nieraz w naszej branży bywa - “to zależy”. Logika zwiększa ryzyko błędu Każde rozgałęzienie procesu przetwarzania w naszym kodzie zwiększa jego podatność na błędy. Unit testy to narzędzie do weryfikowania założeń względem pisanego przez nas oprogramowania. Powinny one być jasno zdefiniowane. Jeśli w testach pojawia się logika to najczęściej jest to droga na skróty, by zaoszczędzić trochę czasu na dokładniejsze przeanalizowanie wymagań względem konkretnych scenariuszy użycia testowanego kodu. Wyobraźmy sobie klasę do naliczania rabatów DiscountCalculator. Zamiast napisać trzy proste testy, w poniższym “sprytnym” przykładzie użyta została nie tylko pętla for, ale również instrukcje warunkowe if/else, aby przetestować różne progi rabatowe w jednym miejscu. TEST_F(DiscountCalculatorTest, calculate_CheckAllDiscounts_ShouldApplyCorrectRates) { const std::vector&lt;double&gt; purchases { 50.0, 150.0, 300.0 }; DiscountCalculator calculator {}; for (const auto&amp; amount : purchases) { const auto result { calculator.calculate(amount) }; if (amount &lt; 100.0) { EXPECT_NEAR(0.0, result, 0.001); } else if (100.0 &lt;= amount &amp;&amp; amount &lt; 200.0) { EXPECT_NEAR(amount * 0.1, result, 0.001); } else { EXPECT_NEAR(amount * 0.2, result, 0.001); } } } Dodanie logiki do testu powoduje szereg problemów. Jeśli test nie przejdzie, to nie tylko musimy debugować nasz kod, ale również kod testu. A tutaj prawidłowo napisane testy dla metody calculate. TEST_F(DiscountCalculatorTest, calculate_TooLowAmount_ShouldReturnNoDiscount) { const auto amount { 50.0 }; DiscountCalculator calculator {}; const auto result { calculator.calculate(amount) }; EXPECT_NEAR(0.0, result, 0.001); } TEST_F(DiscountCalculatorTest, calculate_FirstThresholdAmount_ShouldReturn10PercentDiscount) { const auto amount { 150.0 }; DiscountCalculator calculator {}; const auto result { calculator.calculate(amount) }; EXPECT_NEAR(15.0, result, 0.001); } TEST_F(DiscountCalculatorTest, calculate_SecondThresholdAmount_ShouldReturn20PercentDiscount) { const auto amount { 300.0 }; DiscountCalculator calculator {}; const auto result { calculator.calculate(amount) }; EXPECT_NEAR(60.0, result, 0.001); } Jeśli unit testy nie mają prostej sekwencyjnej struktury tylko rozgałęziają się na różne scenariusze, to tracimy jedną z najważniejszych cech dobrych unit testów, powtarzalność. Tak w zasadzie to logika w testach łamie również inną zasadę z akronimu F.I.R.S.T. - I. Testy, przez wprowadzone instrukcje warunkowe, mogą utracić swoją niezależność względem innych testów. Zwłaszcza, gdy korzystają ze wspólnej metody narzędziowej klasy test siuty. Dla przykładu testujemy klasę OrderProcessor. Mamy metodę narzędziową setupMocks, która w zależności od przekazanych flag, konfiguruje mocki dla różnych scenariuszy. class OrderProcessorTest : public testing::Test { protected: // Wspólna metoda narzędziowa z&amp;nbsp;ukrytą logiką sterującą auto setupProcessor(bool isGoldCustomer, bool hasDiscount) -&gt; void { if (isGoldCustomer) { EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(Status::Gold)); } if (hasDiscount) { EXPECT_CALL(discountServiceMock, apply(_)).WillOnce(Return(true)); } else { // Brak zniżki może zmieniać stan mocka w&amp;nbsp;sposób, // którego inny test się nie spodziewa EXPECT_CALL(discountServiceMock, apply(_)).Times(0); } } MockCustomerService customerServiceMock; MockDiscountService discountServiceMock; }; TEST_F(OrderProcessorTest, process_GoldCustomerWithoutDiscount_ShouldWork) { setupProcessor(true, false); OrderProcessor processor { customerServiceMock, discountServiceMock }; const auto result { processor.process(Order{}) }; EXPECT_TRUE(result.success); } To jest dokładnie ta sytuacja, o której wspominałem we wpisie o DRY i innych zasadach programowania. Nie zawsze stosowanie DRY w testach to dobry pomysł. Poniżej poprawna wersja. class OrderProcessorTest : public testing::Test { protected: auto setupProcessorForCustomerWithoutDiscount(const Status customerStatus) -&gt; void { EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(customerStatus)); } auto setupProcessorForCustomerWithDiscount(const Status customerStatus) -&gt; void { EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(customerStatus)); EXPECT_CALL(discountServiceMock, apply(_)).WillOnce(Return(true)); } MockCustomerService customerServiceMock; MockDiscountService discountServiceMock; }; TEST_F(OrderProcessorTest, process_GoldCustomerWithoutDiscount_ShouldWork) { setupProcessorForCustomerWithoutDiscount(Status::Gold); OrderProcessor processor { customerServiceMock, discountServiceMock }; const auto result { processor.process(Order{}) }; EXPECT_TRUE(result.success); } W tym przykładzie moglibyśmy w zasadzie, po prostu usunąć metody narzędziowe i bezpośrednio dodawać EXPECT_CALL do testów. Są jednak przypadki, gdzie takich instrukcji jest więcej i wtedy warto rozważyć stworzenie metody narzędziowej. To bardzo dobra technika, ciało testu się skraca, a dodatkowo dobrze dobrana nazwa metody dodaje więcej kontekstu. Pamiętaj tylko bez logiki! ;) Powielanie błędów z kodu produkcyjnego Częstym powodem dodawania logiki do unit testów jest chęć odwzorowania przepływu sterowania w testowanym kodzie. Naraża nas to jednak na powielenie błędów z produkcyjnego kodu. Unit testy powinny wykrywać defekty, nie powielać logikę doprowadzając do sytuacji, w której testy w zasadzie są kopią testowanego kodu. Tym razem mamy klasę LoyaltyPointsCalculator, liczymy punkty lojalnościowe. Kto nie lubi ekstra rabatów ;) Logiką, w tym przypadku, jest kopia algorytmu z kodu produkcyjnego. Nie ma tam wprawdzie ifa, niemniej zamiast podać konkretną liczbę, nasz test liczy sobie oczekiwaną wartość podczas swojego wykonywania. TEST_F(LoyaltyPointsTest, calculatePoints_LargeOrder_ShouldReturnPointsWithBonus) { const double orderValue { 600.0 }; const double baseRate { 10.0 }; const double bonusMultiplier { 1.05 }; LoyaltyPointsCalculator calculator {}; EXPECT_NEAR((orderValue / baseRate) * bonusMultiplier, calculator.calculate(orderValue), 0.001); } To nic innego jak fragment implementacji przeklejony do testu. Nie mamy żadnej gwarancji, że nasz test nie odziedziczył przypadkiem logicznego błędu, który miał przecież wykrywać. W asercji powinna się znaleźć pożądana wartość, a nie sposób jej wyliczania. Poniżej poprawiony test. TEST_F(LoyaltyPointsTest, calculatePoints_LargeOrder_ShouldReturnPointsWithBonus) { const auto orderValue { 600.0 }; LoyaltyPointsCalculator calculator {}; const auto result { calculator.calculate(orderValue) }; EXPECT_NEAR(63.0, result, 0.1); } Możliwe, że zastanawiasz się jeszcze dlaczego podawać już obliczoną wartość. Przecież i tak trzeba było ją policzyć. Tak, zgadza się, jednak takich testów z pewnością napisalibyśmy więcej. Jeśli za każdym razem przekopiowalibyśmy logikę z kodu produkcyjnego do testów, to nic by one nie wykryły. Błąd natomiast zapewne wykryliby użytkownicy, co było by znacznie bardziej kosztowne i bolesne. Jeśli obliczamy wartości sami i wpisujemy je bezpośrednio do naszych testów to istnieje dużo mniejsza szansa, że za każdym razem obliczymy ją niepoprawnie. Zmniejszenie czytelności Logika, na przykład w postaci bloku switch/case może utrudniać nam odczytanie intencji testów. Nazwy są niejasne, mało konkretne. Odzwierciedlają tylko to, że pojedynczy unit test testuje więcej niż jeden scenariusz. Dlatego tak ciężko dobrać prawidłową nazwę. Tracimy kontekst bo jest on rozmywany przez logikę, która steruje częścią asercji w zależności od tego co testowana metoda zwróci. Dla przykładu mamy klasę OrderNotifier, która między innymi nadaje priorytety otrzymanym zamówieniom. W zależności od statusu, priorytet będzie inny. Poniżej przykład wszechstronnego, “mega” unit testu. TEST(OrderNotifierTest, determinePriority_MultipleStatuses_ShouldReturnCorrectPriority) { std::vector&lt;OrderStatus&gt; statuses { OrderStatus::New, OrderStatus::Shipped, OrderStatus::Cancelled }; OrderNotifier notifier {}; for (const auto&amp; status : statuses) { const auto priority { notifier.determinePriority(status) }; switch (status) { case OrderStatus::New: EXPECT_EQ(Priority::Low, priority); break; case OrderStatus::Shipped: EXPECT_EQ(Priority::High, priority); break; case OrderStatus::Cancelled: EXPECT_EQ(Priority::Critical, priority); break; } } } Pomimo, iż sama nazwa trzyma się standardu triple A to nie za wiele to daje. Nazwa jest po prostu zbyt ogólna. Jedyne czego możemy być pewni, to, że testuje metodę determinePriority klasy OrderNotifier. Z pewnością przyznasz, że to mało konkretne ;) Ciało testu również nie trzyma standardu AAA. Bloki Act i Assert są wymieszane. Jeśli test zfailuje to w logach będziemy musieli szukać odpowiedzi. Gdyby to były osobne testy, po samej nazwie wiedzielibyśmy, co poszło nie tak. Zobacz jak to powinno wyglądać poprawnie. TEST_F(OrderNotifierTest, determinePriority_NewOrder_ShouldReturnLowPriority) { OrderNotifier notifier {}; const auto priority { notifier.determinePriority(OrderStatus::New) }; EXPECT_EQ(Priority::Low, priority); } TEST_F(OrderNotifierTest, determinePriority_OrderShipped_ShouldReturnHighPriority) { OrderNotifier notifier {}; const auto priority { notifier.determinePriority(OrderStatus::Shipped) }; EXPECT_EQ(Priority::High, priority); } TEST_F(OrderNotifierTest, determinePriority_OrderCancelled_ShouldReturnCriticalPriority) { OrderNotifier notifier {}; const auto priority { notifier.determinePriority(OrderStatus::Cancelled) }; EXPECT_EQ(Priority::Critical, priority); } I teraz to się nazywają czytelne testy! Prawda? Wszystko widoczne jak na tacy. Proste i skuteczne. Dopuszczalne rodzaje logiki Istnieją pewne elementy logiki, które nie mają negatywnych skutków dla naszych unit testów i wręcz mogą poprawić ich czytelność - pętle. Ich stosowanie z pewnością będzie wskazane przy weryfikacji kontenerów. Niemniej, za każdym razem, gdy chcemy użyć pętli w unit testach powinniśmy sobie zadać pytanie: czy dodanie pętli jest niezbędne, by zachować czytelność i prostotę weryfikacji lub do realizacji konkretnego scenariusza testowego? Jeśli odpowiedź brzmi tak, śmiało użyj pętli. TEST_F(ReportBatchProcessorTest, processReports_AllValidReports_EachReportIsMarkedAsProcessedAndNoErrors) { const std::vector&lt;Report&gt; reports { { &quot;ID_1&quot; }, { &quot;ID_2&quot; }, { &quot;ID_3&quot; } }; ReportBatchProcessor processor { reports }; processor.processReports(); const auto results { processor.getProcessedReports() }; ASSERT_THAT(results, testing::SizeIs(reports.size())); for (const auto&amp; report : results) { EXPECT_THAT(report.isProcessed(), testing::IsTrue()); EXPECT_THAT(report.errorCode(), testing::Eq(0)); } } W powyższym przykładnie zastosowanie pętli for jak najbardziej jest poprawne. Moglibyśmy wprawdzie po prostu napisać 6 asercji zamiast dwóch w pętli. Jednak jeśli elementów w kontenerze byłoby więcej, kod testu niepotrzebnie by się wydłużył. Zauważ przy okazji jakich asercji użyłem: ASSERT_THAT i EXPECT_THAT. Znasz je może? Ja wcześniej nie znałem. Po kilku testach stwierdziłem, że warto się im przyjrzeć bliżej. Z pewnością przygotuje osobny post o optymalizacji czytelności wyników testów, gdy się niepowiodą, tak, aby sam komunikat Google Testa jasno wskazywał nam co poszło nie tak. Podsumowanie Mam nadzieję, że tym wpisem przekonałem Cię do niedodawania logiki to Twoich unit testów oraz uważniejszego code review swoich kolegów i koleżanek z zespołu. Ja sam wciąż zbyt często spotykam się z tym problemem i staram się dzielić wiedzą o tym jak pisać dobrej jakości unit testy. Co myślisz o tak rygorystycznym podejściu do braku logiki w unit testach? Uważasz to za przesadę, a może się ze mną zgadzasz? Koniecznie podziel się swoją opinią w komentarzu :) Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn" />
<meta property="og:description" content="Logika, przepływ sterowania, instrukcje warunkowe - to dzięki nim nasze programy mogą spełniać szeregi wymagań i oczekiwań. Dzięki nim możemy rozbudowywać nasz program, rozwijać obecne funkcjonalności oraz dodawać nowe. Każdy programista wie, że bez nich tworzenie oprogramowania nie mogłoby mieć miejsca. Czy zatem nasze unit testy, również powinny zawierać logikę? Zdecydowanie nie, i w tym wpisie wyjaśnię dlaczego, tym razem odpowiedź jest taka klarowna, a nie, jak to nieraz w naszej branży bywa - “to zależy”. Logika zwiększa ryzyko błędu Każde rozgałęzienie procesu przetwarzania w naszym kodzie zwiększa jego podatność na błędy. Unit testy to narzędzie do weryfikowania założeń względem pisanego przez nas oprogramowania. Powinny one być jasno zdefiniowane. Jeśli w testach pojawia się logika to najczęściej jest to droga na skróty, by zaoszczędzić trochę czasu na dokładniejsze przeanalizowanie wymagań względem konkretnych scenariuszy użycia testowanego kodu. Wyobraźmy sobie klasę do naliczania rabatów DiscountCalculator. Zamiast napisać trzy proste testy, w poniższym “sprytnym” przykładzie użyta została nie tylko pętla for, ale również instrukcje warunkowe if/else, aby przetestować różne progi rabatowe w jednym miejscu. TEST_F(DiscountCalculatorTest, calculate_CheckAllDiscounts_ShouldApplyCorrectRates) { const std::vector&lt;double&gt; purchases { 50.0, 150.0, 300.0 }; DiscountCalculator calculator {}; for (const auto&amp; amount : purchases) { const auto result { calculator.calculate(amount) }; if (amount &lt; 100.0) { EXPECT_NEAR(0.0, result, 0.001); } else if (100.0 &lt;= amount &amp;&amp; amount &lt; 200.0) { EXPECT_NEAR(amount * 0.1, result, 0.001); } else { EXPECT_NEAR(amount * 0.2, result, 0.001); } } } Dodanie logiki do testu powoduje szereg problemów. Jeśli test nie przejdzie, to nie tylko musimy debugować nasz kod, ale również kod testu. A tutaj prawidłowo napisane testy dla metody calculate. TEST_F(DiscountCalculatorTest, calculate_TooLowAmount_ShouldReturnNoDiscount) { const auto amount { 50.0 }; DiscountCalculator calculator {}; const auto result { calculator.calculate(amount) }; EXPECT_NEAR(0.0, result, 0.001); } TEST_F(DiscountCalculatorTest, calculate_FirstThresholdAmount_ShouldReturn10PercentDiscount) { const auto amount { 150.0 }; DiscountCalculator calculator {}; const auto result { calculator.calculate(amount) }; EXPECT_NEAR(15.0, result, 0.001); } TEST_F(DiscountCalculatorTest, calculate_SecondThresholdAmount_ShouldReturn20PercentDiscount) { const auto amount { 300.0 }; DiscountCalculator calculator {}; const auto result { calculator.calculate(amount) }; EXPECT_NEAR(60.0, result, 0.001); } Jeśli unit testy nie mają prostej sekwencyjnej struktury tylko rozgałęziają się na różne scenariusze, to tracimy jedną z najważniejszych cech dobrych unit testów, powtarzalność. Tak w zasadzie to logika w testach łamie również inną zasadę z akronimu F.I.R.S.T. - I. Testy, przez wprowadzone instrukcje warunkowe, mogą utracić swoją niezależność względem innych testów. Zwłaszcza, gdy korzystają ze wspólnej metody narzędziowej klasy test siuty. Dla przykładu testujemy klasę OrderProcessor. Mamy metodę narzędziową setupMocks, która w zależności od przekazanych flag, konfiguruje mocki dla różnych scenariuszy. class OrderProcessorTest : public testing::Test { protected: // Wspólna metoda narzędziowa z&amp;nbsp;ukrytą logiką sterującą auto setupProcessor(bool isGoldCustomer, bool hasDiscount) -&gt; void { if (isGoldCustomer) { EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(Status::Gold)); } if (hasDiscount) { EXPECT_CALL(discountServiceMock, apply(_)).WillOnce(Return(true)); } else { // Brak zniżki może zmieniać stan mocka w&amp;nbsp;sposób, // którego inny test się nie spodziewa EXPECT_CALL(discountServiceMock, apply(_)).Times(0); } } MockCustomerService customerServiceMock; MockDiscountService discountServiceMock; }; TEST_F(OrderProcessorTest, process_GoldCustomerWithoutDiscount_ShouldWork) { setupProcessor(true, false); OrderProcessor processor { customerServiceMock, discountServiceMock }; const auto result { processor.process(Order{}) }; EXPECT_TRUE(result.success); } To jest dokładnie ta sytuacja, o której wspominałem we wpisie o DRY i innych zasadach programowania. Nie zawsze stosowanie DRY w testach to dobry pomysł. Poniżej poprawna wersja. class OrderProcessorTest : public testing::Test { protected: auto setupProcessorForCustomerWithoutDiscount(const Status customerStatus) -&gt; void { EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(customerStatus)); } auto setupProcessorForCustomerWithDiscount(const Status customerStatus) -&gt; void { EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(customerStatus)); EXPECT_CALL(discountServiceMock, apply(_)).WillOnce(Return(true)); } MockCustomerService customerServiceMock; MockDiscountService discountServiceMock; }; TEST_F(OrderProcessorTest, process_GoldCustomerWithoutDiscount_ShouldWork) { setupProcessorForCustomerWithoutDiscount(Status::Gold); OrderProcessor processor { customerServiceMock, discountServiceMock }; const auto result { processor.process(Order{}) }; EXPECT_TRUE(result.success); } W tym przykładzie moglibyśmy w zasadzie, po prostu usunąć metody narzędziowe i bezpośrednio dodawać EXPECT_CALL do testów. Są jednak przypadki, gdzie takich instrukcji jest więcej i wtedy warto rozważyć stworzenie metody narzędziowej. To bardzo dobra technika, ciało testu się skraca, a dodatkowo dobrze dobrana nazwa metody dodaje więcej kontekstu. Pamiętaj tylko bez logiki! ;) Powielanie błędów z kodu produkcyjnego Częstym powodem dodawania logiki do unit testów jest chęć odwzorowania przepływu sterowania w testowanym kodzie. Naraża nas to jednak na powielenie błędów z produkcyjnego kodu. Unit testy powinny wykrywać defekty, nie powielać logikę doprowadzając do sytuacji, w której testy w zasadzie są kopią testowanego kodu. Tym razem mamy klasę LoyaltyPointsCalculator, liczymy punkty lojalnościowe. Kto nie lubi ekstra rabatów ;) Logiką, w tym przypadku, jest kopia algorytmu z kodu produkcyjnego. Nie ma tam wprawdzie ifa, niemniej zamiast podać konkretną liczbę, nasz test liczy sobie oczekiwaną wartość podczas swojego wykonywania. TEST_F(LoyaltyPointsTest, calculatePoints_LargeOrder_ShouldReturnPointsWithBonus) { const double orderValue { 600.0 }; const double baseRate { 10.0 }; const double bonusMultiplier { 1.05 }; LoyaltyPointsCalculator calculator {}; EXPECT_NEAR((orderValue / baseRate) * bonusMultiplier, calculator.calculate(orderValue), 0.001); } To nic innego jak fragment implementacji przeklejony do testu. Nie mamy żadnej gwarancji, że nasz test nie odziedziczył przypadkiem logicznego błędu, który miał przecież wykrywać. W asercji powinna się znaleźć pożądana wartość, a nie sposób jej wyliczania. Poniżej poprawiony test. TEST_F(LoyaltyPointsTest, calculatePoints_LargeOrder_ShouldReturnPointsWithBonus) { const auto orderValue { 600.0 }; LoyaltyPointsCalculator calculator {}; const auto result { calculator.calculate(orderValue) }; EXPECT_NEAR(63.0, result, 0.1); } Możliwe, że zastanawiasz się jeszcze dlaczego podawać już obliczoną wartość. Przecież i tak trzeba było ją policzyć. Tak, zgadza się, jednak takich testów z pewnością napisalibyśmy więcej. Jeśli za każdym razem przekopiowalibyśmy logikę z kodu produkcyjnego do testów, to nic by one nie wykryły. Błąd natomiast zapewne wykryliby użytkownicy, co było by znacznie bardziej kosztowne i bolesne. Jeśli obliczamy wartości sami i wpisujemy je bezpośrednio do naszych testów to istnieje dużo mniejsza szansa, że za każdym razem obliczymy ją niepoprawnie. Zmniejszenie czytelności Logika, na przykład w postaci bloku switch/case może utrudniać nam odczytanie intencji testów. Nazwy są niejasne, mało konkretne. Odzwierciedlają tylko to, że pojedynczy unit test testuje więcej niż jeden scenariusz. Dlatego tak ciężko dobrać prawidłową nazwę. Tracimy kontekst bo jest on rozmywany przez logikę, która steruje częścią asercji w zależności od tego co testowana metoda zwróci. Dla przykładu mamy klasę OrderNotifier, która między innymi nadaje priorytety otrzymanym zamówieniom. W zależności od statusu, priorytet będzie inny. Poniżej przykład wszechstronnego, “mega” unit testu. TEST(OrderNotifierTest, determinePriority_MultipleStatuses_ShouldReturnCorrectPriority) { std::vector&lt;OrderStatus&gt; statuses { OrderStatus::New, OrderStatus::Shipped, OrderStatus::Cancelled }; OrderNotifier notifier {}; for (const auto&amp; status : statuses) { const auto priority { notifier.determinePriority(status) }; switch (status) { case OrderStatus::New: EXPECT_EQ(Priority::Low, priority); break; case OrderStatus::Shipped: EXPECT_EQ(Priority::High, priority); break; case OrderStatus::Cancelled: EXPECT_EQ(Priority::Critical, priority); break; } } } Pomimo, iż sama nazwa trzyma się standardu triple A to nie za wiele to daje. Nazwa jest po prostu zbyt ogólna. Jedyne czego możemy być pewni, to, że testuje metodę determinePriority klasy OrderNotifier. Z pewnością przyznasz, że to mało konkretne ;) Ciało testu również nie trzyma standardu AAA. Bloki Act i Assert są wymieszane. Jeśli test zfailuje to w logach będziemy musieli szukać odpowiedzi. Gdyby to były osobne testy, po samej nazwie wiedzielibyśmy, co poszło nie tak. Zobacz jak to powinno wyglądać poprawnie. TEST_F(OrderNotifierTest, determinePriority_NewOrder_ShouldReturnLowPriority) { OrderNotifier notifier {}; const auto priority { notifier.determinePriority(OrderStatus::New) }; EXPECT_EQ(Priority::Low, priority); } TEST_F(OrderNotifierTest, determinePriority_OrderShipped_ShouldReturnHighPriority) { OrderNotifier notifier {}; const auto priority { notifier.determinePriority(OrderStatus::Shipped) }; EXPECT_EQ(Priority::High, priority); } TEST_F(OrderNotifierTest, determinePriority_OrderCancelled_ShouldReturnCriticalPriority) { OrderNotifier notifier {}; const auto priority { notifier.determinePriority(OrderStatus::Cancelled) }; EXPECT_EQ(Priority::Critical, priority); } I teraz to się nazywają czytelne testy! Prawda? Wszystko widoczne jak na tacy. Proste i skuteczne. Dopuszczalne rodzaje logiki Istnieją pewne elementy logiki, które nie mają negatywnych skutków dla naszych unit testów i wręcz mogą poprawić ich czytelność - pętle. Ich stosowanie z pewnością będzie wskazane przy weryfikacji kontenerów. Niemniej, za każdym razem, gdy chcemy użyć pętli w unit testach powinniśmy sobie zadać pytanie: czy dodanie pętli jest niezbędne, by zachować czytelność i prostotę weryfikacji lub do realizacji konkretnego scenariusza testowego? Jeśli odpowiedź brzmi tak, śmiało użyj pętli. TEST_F(ReportBatchProcessorTest, processReports_AllValidReports_EachReportIsMarkedAsProcessedAndNoErrors) { const std::vector&lt;Report&gt; reports { { &quot;ID_1&quot; }, { &quot;ID_2&quot; }, { &quot;ID_3&quot; } }; ReportBatchProcessor processor { reports }; processor.processReports(); const auto results { processor.getProcessedReports() }; ASSERT_THAT(results, testing::SizeIs(reports.size())); for (const auto&amp; report : results) { EXPECT_THAT(report.isProcessed(), testing::IsTrue()); EXPECT_THAT(report.errorCode(), testing::Eq(0)); } } W powyższym przykładnie zastosowanie pętli for jak najbardziej jest poprawne. Moglibyśmy wprawdzie po prostu napisać 6 asercji zamiast dwóch w pętli. Jednak jeśli elementów w kontenerze byłoby więcej, kod testu niepotrzebnie by się wydłużył. Zauważ przy okazji jakich asercji użyłem: ASSERT_THAT i EXPECT_THAT. Znasz je może? Ja wcześniej nie znałem. Po kilku testach stwierdziłem, że warto się im przyjrzeć bliżej. Z pewnością przygotuje osobny post o optymalizacji czytelności wyników testów, gdy się niepowiodą, tak, aby sam komunikat Google Testa jasno wskazywał nam co poszło nie tak. Podsumowanie Mam nadzieję, że tym wpisem przekonałem Cię do niedodawania logiki to Twoich unit testów oraz uważniejszego code review swoich kolegów i koleżanek z zespołu. Ja sam wciąż zbyt często spotykam się z tym problemem i staram się dzielić wiedzą o tym jak pisać dobrej jakości unit testy. Co myślisz o tak rygorystycznym podejściu do braku logiki w unit testach? Uważasz to za przesadę, a może się ze mną zgadzasz? Koniecznie podziel się swoją opinią w komentarzu :) Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn" />
<link rel="canonical" href="https://cpptested.com/unit-testing/logic-in-uts/" />
<meta property="og:url" content="https://cpptested.com/unit-testing/logic-in-uts/" />
<meta property="og:site_name" content="CppTested" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2026-02-23T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Największy wróg unit testów - logika." />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Tadeusz Biela"},"dateModified":"2026-02-23T00:00:00+01:00","datePublished":"2026-02-23T00:00:00+01:00","description":"Logika, przepływ sterowania, instrukcje warunkowe - to dzięki nim nasze programy mogą spełniać szeregi wymagań i oczekiwań. Dzięki nim możemy rozbudowywać nasz program, rozwijać obecne funkcjonalności oraz dodawać nowe. Każdy programista wie, że bez nich tworzenie oprogramowania nie mogłoby mieć miejsca. Czy zatem nasze unit testy, również powinny zawierać logikę? Zdecydowanie nie, i w tym wpisie wyjaśnię dlaczego, tym razem odpowiedź jest taka klarowna, a nie, jak to nieraz w naszej branży bywa - “to zależy”. Logika zwiększa ryzyko błędu Każde rozgałęzienie procesu przetwarzania w naszym kodzie zwiększa jego podatność na błędy. Unit testy to narzędzie do weryfikowania założeń względem pisanego przez nas oprogramowania. Powinny one być jasno zdefiniowane. Jeśli w testach pojawia się logika to najczęściej jest to droga na skróty, by zaoszczędzić trochę czasu na dokładniejsze przeanalizowanie wymagań względem konkretnych scenariuszy użycia testowanego kodu. Wyobraźmy sobie klasę do naliczania rabatów DiscountCalculator. Zamiast napisać trzy proste testy, w poniższym “sprytnym” przykładzie użyta została nie tylko pętla for, ale również instrukcje warunkowe if/else, aby przetestować różne progi rabatowe w jednym miejscu. TEST_F(DiscountCalculatorTest, calculate_CheckAllDiscounts_ShouldApplyCorrectRates) { const std::vector&lt;double&gt; purchases { 50.0, 150.0, 300.0 }; DiscountCalculator calculator {}; for (const auto&amp; amount : purchases) { const auto result { calculator.calculate(amount) }; if (amount &lt; 100.0) { EXPECT_NEAR(0.0, result, 0.001); } else if (100.0 &lt;= amount &amp;&amp; amount &lt; 200.0) { EXPECT_NEAR(amount * 0.1, result, 0.001); } else { EXPECT_NEAR(amount * 0.2, result, 0.001); } } } Dodanie logiki do testu powoduje szereg problemów. Jeśli test nie przejdzie, to nie tylko musimy debugować nasz kod, ale również kod testu. A tutaj prawidłowo napisane testy dla metody calculate. TEST_F(DiscountCalculatorTest, calculate_TooLowAmount_ShouldReturnNoDiscount) { const auto amount { 50.0 }; DiscountCalculator calculator {}; const auto result { calculator.calculate(amount) }; EXPECT_NEAR(0.0, result, 0.001); } TEST_F(DiscountCalculatorTest, calculate_FirstThresholdAmount_ShouldReturn10PercentDiscount) { const auto amount { 150.0 }; DiscountCalculator calculator {}; const auto result { calculator.calculate(amount) }; EXPECT_NEAR(15.0, result, 0.001); } TEST_F(DiscountCalculatorTest, calculate_SecondThresholdAmount_ShouldReturn20PercentDiscount) { const auto amount { 300.0 }; DiscountCalculator calculator {}; const auto result { calculator.calculate(amount) }; EXPECT_NEAR(60.0, result, 0.001); } Jeśli unit testy nie mają prostej sekwencyjnej struktury tylko rozgałęziają się na różne scenariusze, to tracimy jedną z najważniejszych cech dobrych unit testów, powtarzalność. Tak w zasadzie to logika w testach łamie również inną zasadę z akronimu F.I.R.S.T. - I. Testy, przez wprowadzone instrukcje warunkowe, mogą utracić swoją niezależność względem innych testów. Zwłaszcza, gdy korzystają ze wspólnej metody narzędziowej klasy test siuty. Dla przykładu testujemy klasę OrderProcessor. Mamy metodę narzędziową setupMocks, która w zależności od przekazanych flag, konfiguruje mocki dla różnych scenariuszy. class OrderProcessorTest : public testing::Test { protected: // Wspólna metoda narzędziowa z&amp;nbsp;ukrytą logiką sterującą auto setupProcessor(bool isGoldCustomer, bool hasDiscount) -&gt; void { if (isGoldCustomer) { EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(Status::Gold)); } if (hasDiscount) { EXPECT_CALL(discountServiceMock, apply(_)).WillOnce(Return(true)); } else { // Brak zniżki może zmieniać stan mocka w&amp;nbsp;sposób, // którego inny test się nie spodziewa EXPECT_CALL(discountServiceMock, apply(_)).Times(0); } } MockCustomerService customerServiceMock; MockDiscountService discountServiceMock; }; TEST_F(OrderProcessorTest, process_GoldCustomerWithoutDiscount_ShouldWork) { setupProcessor(true, false); OrderProcessor processor { customerServiceMock, discountServiceMock }; const auto result { processor.process(Order{}) }; EXPECT_TRUE(result.success); } To jest dokładnie ta sytuacja, o której wspominałem we wpisie o DRY i innych zasadach programowania. Nie zawsze stosowanie DRY w testach to dobry pomysł. Poniżej poprawna wersja. class OrderProcessorTest : public testing::Test { protected: auto setupProcessorForCustomerWithoutDiscount(const Status customerStatus) -&gt; void { EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(customerStatus)); } auto setupProcessorForCustomerWithDiscount(const Status customerStatus) -&gt; void { EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(customerStatus)); EXPECT_CALL(discountServiceMock, apply(_)).WillOnce(Return(true)); } MockCustomerService customerServiceMock; MockDiscountService discountServiceMock; }; TEST_F(OrderProcessorTest, process_GoldCustomerWithoutDiscount_ShouldWork) { setupProcessorForCustomerWithoutDiscount(Status::Gold); OrderProcessor processor { customerServiceMock, discountServiceMock }; const auto result { processor.process(Order{}) }; EXPECT_TRUE(result.success); } W tym przykładzie moglibyśmy w zasadzie, po prostu usunąć metody narzędziowe i bezpośrednio dodawać EXPECT_CALL do testów. Są jednak przypadki, gdzie takich instrukcji jest więcej i wtedy warto rozważyć stworzenie metody narzędziowej. To bardzo dobra technika, ciało testu się skraca, a dodatkowo dobrze dobrana nazwa metody dodaje więcej kontekstu. Pamiętaj tylko bez logiki! ;) Powielanie błędów z kodu produkcyjnego Częstym powodem dodawania logiki do unit testów jest chęć odwzorowania przepływu sterowania w testowanym kodzie. Naraża nas to jednak na powielenie błędów z produkcyjnego kodu. Unit testy powinny wykrywać defekty, nie powielać logikę doprowadzając do sytuacji, w której testy w zasadzie są kopią testowanego kodu. Tym razem mamy klasę LoyaltyPointsCalculator, liczymy punkty lojalnościowe. Kto nie lubi ekstra rabatów ;) Logiką, w tym przypadku, jest kopia algorytmu z kodu produkcyjnego. Nie ma tam wprawdzie ifa, niemniej zamiast podać konkretną liczbę, nasz test liczy sobie oczekiwaną wartość podczas swojego wykonywania. TEST_F(LoyaltyPointsTest, calculatePoints_LargeOrder_ShouldReturnPointsWithBonus) { const double orderValue { 600.0 }; const double baseRate { 10.0 }; const double bonusMultiplier { 1.05 }; LoyaltyPointsCalculator calculator {}; EXPECT_NEAR((orderValue / baseRate) * bonusMultiplier, calculator.calculate(orderValue), 0.001); } To nic innego jak fragment implementacji przeklejony do testu. Nie mamy żadnej gwarancji, że nasz test nie odziedziczył przypadkiem logicznego błędu, który miał przecież wykrywać. W asercji powinna się znaleźć pożądana wartość, a nie sposób jej wyliczania. Poniżej poprawiony test. TEST_F(LoyaltyPointsTest, calculatePoints_LargeOrder_ShouldReturnPointsWithBonus) { const auto orderValue { 600.0 }; LoyaltyPointsCalculator calculator {}; const auto result { calculator.calculate(orderValue) }; EXPECT_NEAR(63.0, result, 0.1); } Możliwe, że zastanawiasz się jeszcze dlaczego podawać już obliczoną wartość. Przecież i tak trzeba było ją policzyć. Tak, zgadza się, jednak takich testów z pewnością napisalibyśmy więcej. Jeśli za każdym razem przekopiowalibyśmy logikę z kodu produkcyjnego do testów, to nic by one nie wykryły. Błąd natomiast zapewne wykryliby użytkownicy, co było by znacznie bardziej kosztowne i bolesne. Jeśli obliczamy wartości sami i wpisujemy je bezpośrednio do naszych testów to istnieje dużo mniejsza szansa, że za każdym razem obliczymy ją niepoprawnie. Zmniejszenie czytelności Logika, na przykład w postaci bloku switch/case może utrudniać nam odczytanie intencji testów. Nazwy są niejasne, mało konkretne. Odzwierciedlają tylko to, że pojedynczy unit test testuje więcej niż jeden scenariusz. Dlatego tak ciężko dobrać prawidłową nazwę. Tracimy kontekst bo jest on rozmywany przez logikę, która steruje częścią asercji w zależności od tego co testowana metoda zwróci. Dla przykładu mamy klasę OrderNotifier, która między innymi nadaje priorytety otrzymanym zamówieniom. W zależności od statusu, priorytet będzie inny. Poniżej przykład wszechstronnego, “mega” unit testu. TEST(OrderNotifierTest, determinePriority_MultipleStatuses_ShouldReturnCorrectPriority) { std::vector&lt;OrderStatus&gt; statuses { OrderStatus::New, OrderStatus::Shipped, OrderStatus::Cancelled }; OrderNotifier notifier {}; for (const auto&amp; status : statuses) { const auto priority { notifier.determinePriority(status) }; switch (status) { case OrderStatus::New: EXPECT_EQ(Priority::Low, priority); break; case OrderStatus::Shipped: EXPECT_EQ(Priority::High, priority); break; case OrderStatus::Cancelled: EXPECT_EQ(Priority::Critical, priority); break; } } } Pomimo, iż sama nazwa trzyma się standardu triple A to nie za wiele to daje. Nazwa jest po prostu zbyt ogólna. Jedyne czego możemy być pewni, to, że testuje metodę determinePriority klasy OrderNotifier. Z pewnością przyznasz, że to mało konkretne ;) Ciało testu również nie trzyma standardu AAA. Bloki Act i Assert są wymieszane. Jeśli test zfailuje to w logach będziemy musieli szukać odpowiedzi. Gdyby to były osobne testy, po samej nazwie wiedzielibyśmy, co poszło nie tak. Zobacz jak to powinno wyglądać poprawnie. TEST_F(OrderNotifierTest, determinePriority_NewOrder_ShouldReturnLowPriority) { OrderNotifier notifier {}; const auto priority { notifier.determinePriority(OrderStatus::New) }; EXPECT_EQ(Priority::Low, priority); } TEST_F(OrderNotifierTest, determinePriority_OrderShipped_ShouldReturnHighPriority) { OrderNotifier notifier {}; const auto priority { notifier.determinePriority(OrderStatus::Shipped) }; EXPECT_EQ(Priority::High, priority); } TEST_F(OrderNotifierTest, determinePriority_OrderCancelled_ShouldReturnCriticalPriority) { OrderNotifier notifier {}; const auto priority { notifier.determinePriority(OrderStatus::Cancelled) }; EXPECT_EQ(Priority::Critical, priority); } I teraz to się nazywają czytelne testy! Prawda? Wszystko widoczne jak na tacy. Proste i skuteczne. Dopuszczalne rodzaje logiki Istnieją pewne elementy logiki, które nie mają negatywnych skutków dla naszych unit testów i wręcz mogą poprawić ich czytelność - pętle. Ich stosowanie z pewnością będzie wskazane przy weryfikacji kontenerów. Niemniej, za każdym razem, gdy chcemy użyć pętli w unit testach powinniśmy sobie zadać pytanie: czy dodanie pętli jest niezbędne, by zachować czytelność i prostotę weryfikacji lub do realizacji konkretnego scenariusza testowego? Jeśli odpowiedź brzmi tak, śmiało użyj pętli. TEST_F(ReportBatchProcessorTest, processReports_AllValidReports_EachReportIsMarkedAsProcessedAndNoErrors) { const std::vector&lt;Report&gt; reports { { &quot;ID_1&quot; }, { &quot;ID_2&quot; }, { &quot;ID_3&quot; } }; ReportBatchProcessor processor { reports }; processor.processReports(); const auto results { processor.getProcessedReports() }; ASSERT_THAT(results, testing::SizeIs(reports.size())); for (const auto&amp; report : results) { EXPECT_THAT(report.isProcessed(), testing::IsTrue()); EXPECT_THAT(report.errorCode(), testing::Eq(0)); } } W powyższym przykładnie zastosowanie pętli for jak najbardziej jest poprawne. Moglibyśmy wprawdzie po prostu napisać 6 asercji zamiast dwóch w pętli. Jednak jeśli elementów w kontenerze byłoby więcej, kod testu niepotrzebnie by się wydłużył. Zauważ przy okazji jakich asercji użyłem: ASSERT_THAT i EXPECT_THAT. Znasz je może? Ja wcześniej nie znałem. Po kilku testach stwierdziłem, że warto się im przyjrzeć bliżej. Z pewnością przygotuje osobny post o optymalizacji czytelności wyników testów, gdy się niepowiodą, tak, aby sam komunikat Google Testa jasno wskazywał nam co poszło nie tak. Podsumowanie Mam nadzieję, że tym wpisem przekonałem Cię do niedodawania logiki to Twoich unit testów oraz uważniejszego code review swoich kolegów i koleżanek z zespołu. Ja sam wciąż zbyt często spotykam się z tym problemem i staram się dzielić wiedzą o tym jak pisać dobrej jakości unit testy. Co myślisz o tak rygorystycznym podejściu do braku logiki w unit testach? Uważasz to za przesadę, a może się ze mną zgadzasz? Koniecznie podziel się swoją opinią w komentarzu :) Autor: Tadeusz Biela Programista C++ | Entuzjasta TDD | Fan unit testów LinkedIn","headline":"Największy wróg unit testów - logika.","mainEntityOfPage":{"@type":"WebPage","@id":"https://cpptested.com/unit-testing/logic-in-uts/"},"url":"https://cpptested.com/unit-testing/logic-in-uts/"}</script>
<!-- End Jekyll SEO tag -->


<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-HKF97SJC9Z"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HKF97SJC9Z');
</script>

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<link rel="icon" type="image/png" href="/favicon.png">

<!-- end custom head snippets -->

  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Przejdź do nawigacji</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Przejdź do treści</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Przejdź do stopki</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
	<a href="/" class="site-logo">
	  <span style="color: white; font-family: Courier, monospace;">Cpp</span>
  	  <span style="color: #28a745; font-family: Courier, monospace;">Tested</span>
	  <span class="blinking-cursor">|</span>
	</a>	
        <a class="site-title" href="/">
          CppTested
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a
                href="/posts/"
                
                
              >Wpisy</a>
            </li><li class="masthead__menu-item">
              <a
                href="/categories/"
                
                
              >Kategorie</a>
            </li><li class="masthead__menu-item">
              <a
                href="/tags/"
                
                
              >Tagi</a>
            </li><li class="masthead__menu-item">
              <a
                href="/about/"
                
                
              >O mnie</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Przełącz wyszukiwanie</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Przełącz menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Największy wróg unit testów - logika.">
    <meta itemprop="description" content="Logika, przepływ sterowania, instrukcje warunkowe - to dzięki nim nasze programy mogą spełniać szeregi wymagań i oczekiwań. Dzięki nim możemy rozbudowywać nasz program, rozwijać obecne funkcjonalności oraz dodawać nowe. Każdy programista wie, że bez nich tworzenie oprogramowania nie mogłoby mieć miejsca. Czy zatem nasze unit testy, również powinny zawierać logikę? Zdecydowanie nie, i w tym wpisie wyjaśnię dlaczego, tym razem odpowiedź jest taka klarowna, a nie, jak to nieraz w naszej branży bywa - “to zależy”.Logika zwiększa ryzyko błęduKażde rozgałęzienie procesu przetwarzania w naszym kodzie zwiększa jego podatność na błędy. Unit testy to narzędzie do weryfikowania założeń względem pisanego przez nas oprogramowania. Powinny one być jasno zdefiniowane. Jeśli w testach pojawia się logika to najczęściej jest to droga na skróty, by zaoszczędzić trochę czasu na dokładniejsze przeanalizowanie wymagań względem konkretnych scenariuszy użycia testowanego kodu.Wyobraźmy sobie klasę do naliczania rabatów DiscountCalculator. Zamiast napisać trzy proste testy, w poniższym “sprytnym” przykładzie użyta została nie tylko pętla for, ale również instrukcje warunkowe if/else, aby przetestować różne progi rabatowe w jednym miejscu.TEST_F(DiscountCalculatorTest, calculate_CheckAllDiscounts_ShouldApplyCorrectRates){    const std::vector&lt;double&gt; purchases { 50.0, 150.0, 300.0 };    DiscountCalculator calculator {};    for (const auto&amp; amount : purchases)    {        const auto result { calculator.calculate(amount) };        if (amount &lt; 100.0)        {            EXPECT_NEAR(0.0, result, 0.001);        }        else if (100.0 &lt;= amount &amp;&amp; amount &lt; 200.0)        {            EXPECT_NEAR(amount * 0.1, result, 0.001);        }        else        {            EXPECT_NEAR(amount * 0.2, result, 0.001);         }    }}Dodanie logiki do testu powoduje szereg problemów. Jeśli test nie przejdzie, to nie tylko musimy debugować nasz kod, ale również kod testu.A tutaj prawidłowo napisane testy dla metody calculate.TEST_F(DiscountCalculatorTest, calculate_TooLowAmount_ShouldReturnNoDiscount){    const auto amount { 50.0 };    DiscountCalculator calculator {};    const auto result { calculator.calculate(amount) };    EXPECT_NEAR(0.0, result, 0.001);}TEST_F(DiscountCalculatorTest, calculate_FirstThresholdAmount_ShouldReturn10PercentDiscount){    const auto amount { 150.0 };    DiscountCalculator calculator {};    const auto result { calculator.calculate(amount) };    EXPECT_NEAR(15.0, result, 0.001);}TEST_F(DiscountCalculatorTest, calculate_SecondThresholdAmount_ShouldReturn20PercentDiscount){    const auto amount { 300.0 };    DiscountCalculator calculator {};    const auto result { calculator.calculate(amount) };    EXPECT_NEAR(60.0, result, 0.001);}Jeśli unit testy nie mają prostej sekwencyjnej struktury tylko rozgałęziają się na różne scenariusze, to tracimy jedną z najważniejszych cech dobrych unit testów, powtarzalność. Tak w zasadzie to logika w testach łamie również inną zasadę z akronimu F.I.R.S.T. - I. Testy, przez wprowadzone instrukcje warunkowe, mogą utracić swoją niezależność względem innych testów. Zwłaszcza, gdy korzystają ze wspólnej metody narzędziowej klasy test siuty.Dla przykładu testujemy klasę OrderProcessor. Mamy metodę narzędziową setupMocks, która w zależności od przekazanych flag, konfiguruje mocki dla różnych scenariuszy.class OrderProcessorTest : public testing::Test{protected:    // Wspólna metoda narzędziowa z&amp;nbsp;ukrytą logiką sterującą    auto setupProcessor(bool isGoldCustomer, bool hasDiscount) -&gt; void    {        if (isGoldCustomer)        {            EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(Status::Gold));        }        if (hasDiscount)        {            EXPECT_CALL(discountServiceMock, apply(_)).WillOnce(Return(true));        }        else        {            // Brak zniżki może zmieniać stan mocka w&amp;nbsp;sposób,             // którego inny test się nie spodziewa            EXPECT_CALL(discountServiceMock, apply(_)).Times(0);        }    }    MockCustomerService customerServiceMock;    MockDiscountService discountServiceMock;};TEST_F(OrderProcessorTest, process_GoldCustomerWithoutDiscount_ShouldWork){    setupProcessor(true, false);    OrderProcessor processor { customerServiceMock, discountServiceMock };    const auto result { processor.process(Order{}) };    EXPECT_TRUE(result.success);}To jest dokładnie ta sytuacja, o której wspominałem we wpisie o DRY i innych zasadach programowania. Nie zawsze stosowanie DRY w testach to dobry pomysł. Poniżej poprawna wersja.class OrderProcessorTest : public testing::Test{protected:    auto setupProcessorForCustomerWithoutDiscount(const Status customerStatus) -&gt; void    {        EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(customerStatus));    }    auto setupProcessorForCustomerWithDiscount(const Status customerStatus) -&gt; void    {        EXPECT_CALL(customerServiceMock, getStatus(_)).WillRepeatedly(Return(customerStatus));        EXPECT_CALL(discountServiceMock, apply(_)).WillOnce(Return(true));    }      MockCustomerService customerServiceMock;    MockDiscountService discountServiceMock;};TEST_F(OrderProcessorTest, process_GoldCustomerWithoutDiscount_ShouldWork){    setupProcessorForCustomerWithoutDiscount(Status::Gold);    OrderProcessor processor { customerServiceMock, discountServiceMock };    const auto result { processor.process(Order{}) };    EXPECT_TRUE(result.success);}W tym przykładzie moglibyśmy w zasadzie, po prostu usunąć metody narzędziowe i bezpośrednio dodawać EXPECT_CALL do testów. Są jednak przypadki, gdzie takich instrukcji jest więcej i wtedy warto rozważyć stworzenie metody narzędziowej. To bardzo dobra technika, ciało testu się skraca, a dodatkowo dobrze dobrana nazwa metody dodaje więcej kontekstu. Pamiętaj tylko bez logiki! ;)Powielanie błędów z kodu produkcyjnegoCzęstym powodem dodawania logiki do unit testów jest chęć odwzorowania przepływu sterowania w testowanym kodzie. Naraża nas to jednak na powielenie błędów z produkcyjnego kodu. Unit testy powinny wykrywać defekty, nie powielać logikę doprowadzając do sytuacji, w której testy w zasadzie są kopią testowanego kodu.Tym razem mamy klasę LoyaltyPointsCalculator, liczymy punkty lojalnościowe. Kto nie lubi ekstra rabatów ;)Logiką, w tym przypadku, jest kopia algorytmu z kodu produkcyjnego. Nie ma tam wprawdzie ifa, niemniej zamiast podać konkretną liczbę, nasz test liczy sobie oczekiwaną wartość podczas swojego wykonywania.TEST_F(LoyaltyPointsTest, calculatePoints_LargeOrder_ShouldReturnPointsWithBonus){    const double orderValue { 600.0 };    const double baseRate { 10.0 };    const double bonusMultiplier { 1.05 };    LoyaltyPointsCalculator calculator {};    EXPECT_NEAR((orderValue / baseRate) * bonusMultiplier, calculator.calculate(orderValue), 0.001);}To nic innego jak fragment implementacji przeklejony do testu. Nie mamy żadnej gwarancji, że nasz test nie odziedziczył przypadkiem logicznego błędu, który miał przecież wykrywać. W asercji powinna się znaleźć pożądana wartość, a nie sposób jej wyliczania. Poniżej poprawiony test.TEST_F(LoyaltyPointsTest, calculatePoints_LargeOrder_ShouldReturnPointsWithBonus){    const auto orderValue { 600.0 };    LoyaltyPointsCalculator calculator {};    const auto result { calculator.calculate(orderValue) };    EXPECT_NEAR(63.0, result, 0.1);}Możliwe, że zastanawiasz się jeszcze dlaczego podawać już obliczoną wartość. Przecież i tak trzeba było ją policzyć. Tak, zgadza się, jednak takich testów z pewnością napisalibyśmy więcej. Jeśli za każdym razem przekopiowalibyśmy logikę z kodu produkcyjnego do testów, to nic by one nie wykryły. Błąd natomiast zapewne wykryliby użytkownicy, co było by znacznie bardziej kosztowne i bolesne. Jeśli obliczamy wartości sami i wpisujemy je bezpośrednio do naszych testów to istnieje dużo mniejsza szansa, że za każdym razem obliczymy ją niepoprawnie.Zmniejszenie czytelnościLogika, na przykład w postaci bloku switch/case może utrudniać nam odczytanie intencji testów. Nazwy są niejasne, mało konkretne. Odzwierciedlają tylko to, że pojedynczy unit test testuje więcej niż jeden scenariusz. Dlatego tak ciężko dobrać prawidłową nazwę. Tracimy kontekst bo jest on rozmywany przez logikę, która steruje częścią asercji w zależności od tego co testowana metoda zwróci.Dla przykładu mamy klasę OrderNotifier, która między innymi nadaje priorytety otrzymanym zamówieniom. W zależności od statusu, priorytet będzie inny. Poniżej przykład wszechstronnego, “mega” unit testu.TEST(OrderNotifierTest, determinePriority_MultipleStatuses_ShouldReturnCorrectPriority){    std::vector&lt;OrderStatus&gt; statuses { OrderStatus::New, OrderStatus::Shipped, OrderStatus::Cancelled };    OrderNotifier notifier {};    for (const auto&amp; status : statuses)    {        const auto priority { notifier.determinePriority(status) };        switch (status)        {            case OrderStatus::New:                EXPECT_EQ(Priority::Low, priority);                break;            case OrderStatus::Shipped:                EXPECT_EQ(Priority::High, priority);                break;            case OrderStatus::Cancelled:                EXPECT_EQ(Priority::Critical, priority);                break;        }    }}Pomimo, iż sama nazwa trzyma się standardu triple A to nie za wiele to daje. Nazwa jest po prostu zbyt ogólna. Jedyne czego możemy być pewni, to, że testuje metodę determinePriority klasy OrderNotifier. Z pewnością przyznasz, że to mało konkretne ;)Ciało testu również nie trzyma standardu AAA. Bloki Act i Assert są wymieszane. Jeśli test zfailuje to w logach będziemy musieli szukać odpowiedzi. Gdyby to były osobne testy, po samej nazwie wiedzielibyśmy, co poszło nie tak.Zobacz jak to powinno wyglądać poprawnie.TEST_F(OrderNotifierTest, determinePriority_NewOrder_ShouldReturnLowPriority){    OrderNotifier notifier {};    const auto priority { notifier.determinePriority(OrderStatus::New) };    EXPECT_EQ(Priority::Low, priority);}TEST_F(OrderNotifierTest, determinePriority_OrderShipped_ShouldReturnHighPriority){    OrderNotifier notifier {};    const auto priority { notifier.determinePriority(OrderStatus::Shipped) };    EXPECT_EQ(Priority::High, priority);}TEST_F(OrderNotifierTest, determinePriority_OrderCancelled_ShouldReturnCriticalPriority){    OrderNotifier notifier {};    const auto priority { notifier.determinePriority(OrderStatus::Cancelled) };    EXPECT_EQ(Priority::Critical, priority);}I teraz to się nazywają czytelne testy! Prawda? Wszystko widoczne jak na tacy. Proste i skuteczne.Dopuszczalne rodzaje logikiIstnieją pewne elementy logiki, które nie mają negatywnych skutków dla naszych unit testów i wręcz mogą poprawić ich czytelność - pętle. Ich stosowanie z pewnością będzie wskazane przy weryfikacji kontenerów. Niemniej, za każdym razem, gdy chcemy użyć pętli w unit testach powinniśmy sobie zadać pytanie: czy dodanie pętli jest niezbędne, by zachować czytelność i prostotę weryfikacji lub do realizacji konkretnego scenariusza testowego?Jeśli odpowiedź brzmi tak, śmiało użyj pętli.TEST_F(ReportBatchProcessorTest, processReports_AllValidReports_EachReportIsMarkedAsProcessedAndNoErrors){    const std::vector&lt;Report&gt; reports { { &quot;ID_1&quot; }, { &quot;ID_2&quot; }, { &quot;ID_3&quot; } };    ReportBatchProcessor processor { reports };    processor.processReports();    const auto results { processor.getProcessedReports() };    ASSERT_THAT(results, testing::SizeIs(reports.size()));    for (const auto&amp; report : results)    {        EXPECT_THAT(report.isProcessed(), testing::IsTrue());        EXPECT_THAT(report.errorCode(), testing::Eq(0));    }}W powyższym przykładnie zastosowanie pętli for jak najbardziej jest poprawne. Moglibyśmy wprawdzie po prostu napisać 6 asercji zamiast dwóch w pętli. Jednak jeśli elementów w kontenerze byłoby więcej, kod testu niepotrzebnie by się wydłużył. Zauważ przy okazji jakich asercji użyłem: ASSERT_THAT i EXPECT_THAT. Znasz je może? Ja wcześniej nie znałem. Po kilku testach stwierdziłem, że warto się im przyjrzeć bliżej. Z pewnością przygotuje osobny post o optymalizacji czytelności wyników testów, gdy się niepowiodą, tak, aby sam komunikat Google Testa jasno wskazywał nam co poszło nie tak.PodsumowanieMam nadzieję, że tym wpisem przekonałem Cię do niedodawania logiki to Twoich unit testów oraz uważniejszego code review swoich kolegów i koleżanek z zespołu. Ja sam wciąż zbyt często spotykam się z tym problemem i staram się dzielić wiedzą o tym jak pisać dobrej jakości unit testy. Co myślisz o tak rygorystycznym podejściu do braku logiki w unit testach? Uważasz to za przesadę, a może się ze mną zgadzasz? Koniecznie podziel się swoją opinią w komentarzu :)Autor: Tadeusz BielaProgramista C++ | Entuzjasta TDD | Fan unit testówLinkedIn">
    <meta itemprop="datePublished" content="2026-02-23T00:00:00+01:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">
            <a href="https://cpptested.com/unit-testing/logic-in-uts/" itemprop="url">Największy wróg unit testów - logika.
</a>
          </h1>
          

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2026-02-23T00:00:00+01:00">23 lutego 2026</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          6 minut(y)
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Spis treści</h4></header>
              <ul class="toc__menu"><li><a href="#logika-zwiększa-ryzyko-błędu">Logika zwiększa ryzyko błędu</a></li><li><a href="#powielanie-błędów-zkodu-produkcyjnego">Powielanie błędów z kodu produkcyjnego</a></li><li><a href="#zmniejszenie-czytelności">Zmniejszenie czytelności</a></li><li><a href="#dopuszczalne-rodzaje-logiki">Dopuszczalne rodzaje logiki</a></li><li><a href="#podsumowanie">Podsumowanie</a></li></ul>
            </nav>
          </aside>
        
        <p>Logika, przepływ sterowania, instrukcje warunkowe - to dzięki nim nasze programy mogą spełniać szeregi wymagań i oczekiwań. Dzięki nim możemy rozbudowywać nasz program, rozwijać obecne funkcjonalności oraz dodawać nowe. Każdy programista wie, że bez nich tworzenie oprogramowania nie mogłoby mieć miejsca. Czy zatem nasze unit testy, również powinny zawierać logikę? Zdecydowanie nie, i w tym wpisie wyjaśnię dlaczego, tym razem odpowiedź jest taka klarowna, a nie, jak to nieraz w naszej branży bywa - “to zależy”.</p>

<h3 id="logika-zwiększa-ryzyko-błędu">Logika zwiększa ryzyko błędu</h3>

<p>Każde rozgałęzienie procesu przetwarzania w naszym kodzie zwiększa jego podatność na błędy. Unit testy to narzędzie do weryfikowania założeń względem pisanego przez nas oprogramowania. Powinny one być jasno zdefiniowane. Jeśli w testach pojawia się logika to najczęściej jest to droga na skróty, by zaoszczędzić trochę czasu na dokładniejsze przeanalizowanie wymagań względem konkretnych scenariuszy użycia testowanego kodu.</p>

<p>Wyobraźmy sobie klasę do naliczania rabatów <strong>DiscountCalculator</strong>. Zamiast napisać trzy proste testy, w poniższym “sprytnym” przykładzie użyta została nie tylko pętla <strong>for</strong>, ale również instrukcje warunkowe <strong>if/else</strong>, aby przetestować różne progi rabatowe w jednym miejscu.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">DiscountCalculatorTest</span><span class="p">,</span> <span class="n">calculate_CheckAllDiscounts_ShouldApplyCorrectRates</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">purchases</span> <span class="p">{</span> <span class="mf">50.0</span><span class="p">,</span> <span class="mf">150.0</span><span class="p">,</span> <span class="mf">300.0</span> <span class="p">};</span>
    <span class="n">DiscountCalculator</span> <span class="n">calculator</span> <span class="p">{};</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">amount</span> <span class="o">:</span> <span class="n">purchases</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">result</span> <span class="p">{</span> <span class="n">calculator</span><span class="p">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="p">};</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">amount</span> <span class="o">&lt;</span> <span class="mf">100.0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">EXPECT_NEAR</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="mf">100.0</span> <span class="o">&lt;=</span> <span class="n">amount</span> <span class="o">&amp;&amp;</span> <span class="n">amount</span> <span class="o">&lt;</span> <span class="mf">200.0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">EXPECT_NEAR</span><span class="p">(</span><span class="n">amount</span> <span class="o">*</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">EXPECT_NEAR</span><span class="p">(</span><span class="n">amount</span> <span class="o">*</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">);</span> 
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dodanie logiki do testu powoduje szereg problemów. Jeśli test nie przejdzie, to nie tylko musimy debugować nasz kod, ale również kod testu.
A tutaj prawidłowo napisane testy dla metody <strong>calculate</strong>.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">DiscountCalculatorTest</span><span class="p">,</span> <span class="n">calculate_TooLowAmount_ShouldReturnNoDiscount</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">amount</span> <span class="p">{</span> <span class="mf">50.0</span> <span class="p">};</span>
    <span class="n">DiscountCalculator</span> <span class="n">calculator</span> <span class="p">{};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">result</span> <span class="p">{</span> <span class="n">calculator</span><span class="p">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">EXPECT_NEAR</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">DiscountCalculatorTest</span><span class="p">,</span> <span class="n">calculate_FirstThresholdAmount_ShouldReturn10PercentDiscount</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">amount</span> <span class="p">{</span> <span class="mf">150.0</span> <span class="p">};</span>
    <span class="n">DiscountCalculator</span> <span class="n">calculator</span> <span class="p">{};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">result</span> <span class="p">{</span> <span class="n">calculator</span><span class="p">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">EXPECT_NEAR</span><span class="p">(</span><span class="mf">15.0</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">DiscountCalculatorTest</span><span class="p">,</span> <span class="n">calculate_SecondThresholdAmount_ShouldReturn20PercentDiscount</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">amount</span> <span class="p">{</span> <span class="mf">300.0</span> <span class="p">};</span>
    <span class="n">DiscountCalculator</span> <span class="n">calculator</span> <span class="p">{};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">result</span> <span class="p">{</span> <span class="n">calculator</span><span class="p">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">EXPECT_NEAR</span><span class="p">(</span><span class="mf">60.0</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Jeśli unit testy nie mają prostej sekwencyjnej struktury tylko rozgałęziają się na różne scenariusze, to tracimy jedną z najważniejszych cech dobrych unit testów, powtarzalność. Tak w zasadzie to logika w testach łamie również inną zasadę z <a href="https://cpptested.com/unit-testing/first-reguly-ut/" target="_blank" rel="noopener">akronimu F.I.R.S.T.</a> - <strong>I</strong>. Testy, przez wprowadzone instrukcje warunkowe, mogą utracić swoją niezależność względem innych testów. Zwłaszcza, gdy korzystają ze wspólnej metody narzędziowej klasy test siuty.</p>

<p>Dla przykładu testujemy klasę <strong>OrderProcessor</strong>. Mamy metodę narzędziową <strong>setupMocks</strong>, która w zależności od przekazanych flag, konfiguruje mocki dla różnych scenariuszy.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">OrderProcessorTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">testing</span><span class="o">::</span><span class="n">Test</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="c1">// Wspólna metoda narzędziowa z&amp;nbsp;ukrytą logiką sterującą</span>
    <span class="k">auto</span> <span class="n">setupProcessor</span><span class="p">(</span><span class="kt">bool</span> <span class="n">isGoldCustomer</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">hasDiscount</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">isGoldCustomer</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">customerServiceMock</span><span class="p">,</span> <span class="n">getStatus</span><span class="p">(</span><span class="n">_</span><span class="p">)).</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="n">Status</span><span class="o">::</span><span class="n">Gold</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">hasDiscount</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">discountServiceMock</span><span class="p">,</span> <span class="n">apply</span><span class="p">(</span><span class="n">_</span><span class="p">)).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="c1">// Brak zniżki może zmieniać stan mocka w&amp;nbsp;sposób, </span>
            <span class="c1">// którego inny test się nie spodziewa</span>
            <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">discountServiceMock</span><span class="p">,</span> <span class="n">apply</span><span class="p">(</span><span class="n">_</span><span class="p">)).</span><span class="n">Times</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">MockCustomerService</span> <span class="n">customerServiceMock</span><span class="p">;</span>
    <span class="n">MockDiscountService</span> <span class="n">discountServiceMock</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">OrderProcessorTest</span><span class="p">,</span> <span class="n">process_GoldCustomerWithoutDiscount_ShouldWork</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">setupProcessor</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
    <span class="n">OrderProcessor</span> <span class="n">processor</span> <span class="p">{</span> <span class="n">customerServiceMock</span><span class="p">,</span> <span class="n">discountServiceMock</span> <span class="p">};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">result</span> <span class="p">{</span> <span class="n">processor</span><span class="p">.</span><span class="n">process</span><span class="p">(</span><span class="n">Order</span><span class="p">{})</span> <span class="p">};</span>

    <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">success</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To jest dokładnie ta sytuacja, o której wspominałem we <a href="https://cpptested.com/clean-code/dry-and-other-principles/" target="_blank" rel="noopener">wpisie o DRY i innych zasadach programowania</a>. Nie zawsze stosowanie DRY w testach to dobry pomysł. Poniżej poprawna wersja.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">OrderProcessorTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">testing</span><span class="o">::</span><span class="n">Test</span>
<span class="p">{</span>
<span class="nl">protected:</span>
    <span class="k">auto</span> <span class="n">setupProcessorForCustomerWithoutDiscount</span><span class="p">(</span><span class="k">const</span> <span class="n">Status</span> <span class="n">customerStatus</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span>
    <span class="p">{</span>
        <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">customerServiceMock</span><span class="p">,</span> <span class="n">getStatus</span><span class="p">(</span><span class="n">_</span><span class="p">)).</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="n">customerStatus</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">setupProcessorForCustomerWithDiscount</span><span class="p">(</span><span class="k">const</span> <span class="n">Status</span> <span class="n">customerStatus</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">void</span>
    <span class="p">{</span>
        <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">customerServiceMock</span><span class="p">,</span> <span class="n">getStatus</span><span class="p">(</span><span class="n">_</span><span class="p">)).</span><span class="n">WillRepeatedly</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="n">customerStatus</span><span class="p">));</span>
        <span class="n">EXPECT_CALL</span><span class="p">(</span><span class="n">discountServiceMock</span><span class="p">,</span> <span class="n">apply</span><span class="p">(</span><span class="n">_</span><span class="p">)).</span><span class="n">WillOnce</span><span class="p">(</span><span class="n">Return</span><span class="p">(</span><span class="nb">true</span><span class="p">));</span>
    <span class="p">}</span>
  
    <span class="n">MockCustomerService</span> <span class="n">customerServiceMock</span><span class="p">;</span>
    <span class="n">MockDiscountService</span> <span class="n">discountServiceMock</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">OrderProcessorTest</span><span class="p">,</span> <span class="n">process_GoldCustomerWithoutDiscount_ShouldWork</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">setupProcessorForCustomerWithoutDiscount</span><span class="p">(</span><span class="n">Status</span><span class="o">::</span><span class="n">Gold</span><span class="p">);</span>
    <span class="n">OrderProcessor</span> <span class="n">processor</span> <span class="p">{</span> <span class="n">customerServiceMock</span><span class="p">,</span> <span class="n">discountServiceMock</span> <span class="p">};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">result</span> <span class="p">{</span> <span class="n">processor</span><span class="p">.</span><span class="n">process</span><span class="p">(</span><span class="n">Order</span><span class="p">{})</span> <span class="p">};</span>

    <span class="n">EXPECT_TRUE</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">success</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>W tym przykładzie moglibyśmy w zasadzie, po prostu usunąć metody narzędziowe i bezpośrednio dodawać <strong>EXPECT_CALL</strong> do testów. Są jednak przypadki, gdzie takich instrukcji jest więcej i wtedy warto rozważyć stworzenie metody narzędziowej. To bardzo dobra technika, ciało testu się skraca, a dodatkowo dobrze dobrana nazwa metody dodaje więcej kontekstu. Pamiętaj tylko bez logiki! ;)</p>

<h3 id="powielanie-błędów-zkodu-produkcyjnego">Powielanie błędów z kodu produkcyjnego</h3>

<p>Częstym powodem dodawania logiki do unit testów jest chęć odwzorowania przepływu sterowania w testowanym kodzie. Naraża nas to jednak na powielenie błędów z produkcyjnego kodu. Unit testy powinny wykrywać defekty, nie powielać logikę doprowadzając do sytuacji, w której testy w zasadzie są kopią testowanego kodu.</p>

<p>Tym razem mamy klasę <strong>LoyaltyPointsCalculator</strong>, liczymy punkty lojalnościowe. Kto nie lubi ekstra rabatów ;)
Logiką, w tym przypadku, jest kopia algorytmu z kodu produkcyjnego. Nie ma tam wprawdzie <strong>if</strong>a, niemniej zamiast podać konkretną liczbę, nasz test liczy sobie oczekiwaną wartość podczas swojego wykonywania.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">LoyaltyPointsTest</span><span class="p">,</span> <span class="n">calculatePoints_LargeOrder_ShouldReturnPointsWithBonus</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">orderValue</span> <span class="p">{</span> <span class="mf">600.0</span> <span class="p">};</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">baseRate</span> <span class="p">{</span> <span class="mf">10.0</span> <span class="p">};</span>
    <span class="k">const</span> <span class="kt">double</span> <span class="n">bonusMultiplier</span> <span class="p">{</span> <span class="mf">1.05</span> <span class="p">};</span>
    <span class="n">LoyaltyPointsCalculator</span> <span class="n">calculator</span> <span class="p">{};</span>

    <span class="n">EXPECT_NEAR</span><span class="p">((</span><span class="n">orderValue</span> <span class="o">/</span> <span class="n">baseRate</span><span class="p">)</span> <span class="o">*</span> <span class="n">bonusMultiplier</span><span class="p">,</span> <span class="n">calculator</span><span class="p">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">orderValue</span><span class="p">),</span> <span class="mf">0.001</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To nic innego jak fragment implementacji przeklejony do testu. Nie mamy żadnej gwarancji, że nasz test nie odziedziczył przypadkiem logicznego błędu, który miał przecież wykrywać. W asercji powinna się znaleźć pożądana wartość, a nie sposób jej wyliczania. Poniżej poprawiony test.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">LoyaltyPointsTest</span><span class="p">,</span> <span class="n">calculatePoints_LargeOrder_ShouldReturnPointsWithBonus</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">orderValue</span> <span class="p">{</span> <span class="mf">600.0</span> <span class="p">};</span>
    <span class="n">LoyaltyPointsCalculator</span> <span class="n">calculator</span> <span class="p">{};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">result</span> <span class="p">{</span> <span class="n">calculator</span><span class="p">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">orderValue</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">EXPECT_NEAR</span><span class="p">(</span><span class="mf">63.0</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Możliwe, że zastanawiasz się jeszcze dlaczego podawać już obliczoną wartość. Przecież i tak trzeba było ją policzyć. Tak, zgadza się, jednak takich testów z pewnością napisalibyśmy więcej. Jeśli za każdym razem przekopiowalibyśmy logikę z kodu produkcyjnego do testów, to nic by one nie wykryły. Błąd natomiast zapewne wykryliby użytkownicy, co było by znacznie bardziej kosztowne i bolesne. Jeśli obliczamy wartości sami i wpisujemy je bezpośrednio do naszych testów to istnieje dużo mniejsza szansa, że za każdym razem obliczymy ją niepoprawnie.</p>

<h3 id="zmniejszenie-czytelności">Zmniejszenie czytelności</h3>

<p>Logika, na przykład w postaci bloku <strong>switch/case</strong> może utrudniać nam odczytanie intencji testów. Nazwy są niejasne, mało konkretne. Odzwierciedlają tylko to, że pojedynczy unit test testuje więcej niż jeden scenariusz. Dlatego tak ciężko dobrać prawidłową nazwę. Tracimy kontekst bo jest on rozmywany przez logikę, która steruje częścią asercji w zależności od tego co testowana metoda zwróci.</p>

<p>Dla przykładu mamy klasę <strong>OrderNotifier</strong>, która między innymi nadaje priorytety otrzymanym zamówieniom. W zależności od statusu, priorytet będzie inny. Poniżej przykład wszechstronnego, “mega” unit testu.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST</span><span class="p">(</span><span class="n">OrderNotifierTest</span><span class="p">,</span> <span class="n">determinePriority_MultipleStatuses_ShouldReturnCorrectPriority</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">OrderStatus</span><span class="o">&gt;</span> <span class="n">statuses</span> <span class="p">{</span> <span class="n">OrderStatus</span><span class="o">::</span><span class="n">New</span><span class="p">,</span> <span class="n">OrderStatus</span><span class="o">::</span><span class="n">Shipped</span><span class="p">,</span> <span class="n">OrderStatus</span><span class="o">::</span><span class="n">Cancelled</span> <span class="p">};</span>
    <span class="n">OrderNotifier</span> <span class="n">notifier</span> <span class="p">{};</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">status</span> <span class="o">:</span> <span class="n">statuses</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">priority</span> <span class="p">{</span> <span class="n">notifier</span><span class="p">.</span><span class="n">determinePriority</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="p">};</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">case</span> <span class="n">OrderStatus</span><span class="o">::</span><span class="n">New</span><span class="p">:</span>
                <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Priority</span><span class="o">::</span><span class="n">Low</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">OrderStatus</span><span class="o">::</span><span class="n">Shipped</span><span class="p">:</span>
                <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Priority</span><span class="o">::</span><span class="n">High</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">OrderStatus</span><span class="o">::</span><span class="n">Cancelled</span><span class="p">:</span>
                <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Priority</span><span class="o">::</span><span class="n">Critical</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Pomimo, iż sama nazwa trzyma się <a href="https://cpptested.com/unit-testing/AAA-golden-standard/" target="_blank" rel="noopener">standardu triple A</a> to nie za wiele to daje. Nazwa jest po prostu zbyt ogólna. Jedyne czego możemy być pewni, to, że testuje metodę <strong>determinePriority</strong> klasy <strong>OrderNotifier</strong>. Z pewnością przyznasz, że to mało konkretne ;)
Ciało testu również nie trzyma standardu AAA. Bloki <strong>Act</strong> i <strong>Assert</strong> są wymieszane. Jeśli test zfailuje to w logach będziemy musieli szukać odpowiedzi. Gdyby to były osobne testy, po samej nazwie wiedzielibyśmy, co poszło nie tak.</p>

<p>Zobacz jak to powinno wyglądać poprawnie.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">OrderNotifierTest</span><span class="p">,</span> <span class="n">determinePriority_NewOrder_ShouldReturnLowPriority</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">OrderNotifier</span> <span class="n">notifier</span> <span class="p">{};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">priority</span> <span class="p">{</span> <span class="n">notifier</span><span class="p">.</span><span class="n">determinePriority</span><span class="p">(</span><span class="n">OrderStatus</span><span class="o">::</span><span class="n">New</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Priority</span><span class="o">::</span><span class="n">Low</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">OrderNotifierTest</span><span class="p">,</span> <span class="n">determinePriority_OrderShipped_ShouldReturnHighPriority</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">OrderNotifier</span> <span class="n">notifier</span> <span class="p">{};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">priority</span> <span class="p">{</span> <span class="n">notifier</span><span class="p">.</span><span class="n">determinePriority</span><span class="p">(</span><span class="n">OrderStatus</span><span class="o">::</span><span class="n">Shipped</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Priority</span><span class="o">::</span><span class="n">High</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">OrderNotifierTest</span><span class="p">,</span> <span class="n">determinePriority_OrderCancelled_ShouldReturnCriticalPriority</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">OrderNotifier</span> <span class="n">notifier</span> <span class="p">{};</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">priority</span> <span class="p">{</span> <span class="n">notifier</span><span class="p">.</span><span class="n">determinePriority</span><span class="p">(</span><span class="n">OrderStatus</span><span class="o">::</span><span class="n">Cancelled</span><span class="p">)</span> <span class="p">};</span>

    <span class="n">EXPECT_EQ</span><span class="p">(</span><span class="n">Priority</span><span class="o">::</span><span class="n">Critical</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I teraz to się nazywają czytelne testy! Prawda? Wszystko widoczne jak na tacy. Proste i skuteczne.</p>

<h3 id="dopuszczalne-rodzaje-logiki">Dopuszczalne rodzaje logiki</h3>

<p>Istnieją pewne elementy logiki, które nie mają negatywnych skutków dla naszych unit testów i wręcz mogą poprawić ich czytelność - pętle. Ich stosowanie z pewnością będzie wskazane przy weryfikacji kontenerów. Niemniej, za każdym razem, gdy chcemy użyć pętli w unit testach powinniśmy sobie zadać pytanie: czy dodanie pętli jest niezbędne, by zachować czytelność i prostotę weryfikacji lub do realizacji konkretnego scenariusza testowego?
Jeśli odpowiedź brzmi tak, śmiało użyj pętli.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">TEST_F</span><span class="p">(</span><span class="n">ReportBatchProcessorTest</span><span class="p">,</span> <span class="n">processReports_AllValidReports_EachReportIsMarkedAsProcessedAndNoErrors</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Report</span><span class="o">&gt;</span> <span class="n">reports</span> <span class="p">{</span> <span class="p">{</span> <span class="s">"ID_1"</span> <span class="p">},</span> <span class="p">{</span> <span class="s">"ID_2"</span> <span class="p">},</span> <span class="p">{</span> <span class="s">"ID_3"</span> <span class="p">}</span> <span class="p">};</span>
    <span class="n">ReportBatchProcessor</span> <span class="n">processor</span> <span class="p">{</span> <span class="n">reports</span> <span class="p">};</span>

    <span class="n">processor</span><span class="p">.</span><span class="n">processReports</span><span class="p">();</span>

    <span class="k">const</span> <span class="k">auto</span> <span class="n">results</span> <span class="p">{</span> <span class="n">processor</span><span class="p">.</span><span class="n">getProcessedReports</span><span class="p">()</span> <span class="p">};</span>
    <span class="n">ASSERT_THAT</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">testing</span><span class="o">::</span><span class="n">SizeIs</span><span class="p">(</span><span class="n">reports</span><span class="p">.</span><span class="n">size</span><span class="p">()));</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">report</span> <span class="o">:</span> <span class="n">results</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">report</span><span class="p">.</span><span class="n">isProcessed</span><span class="p">(),</span> <span class="n">testing</span><span class="o">::</span><span class="n">IsTrue</span><span class="p">());</span>
        <span class="n">EXPECT_THAT</span><span class="p">(</span><span class="n">report</span><span class="p">.</span><span class="n">errorCode</span><span class="p">(),</span> <span class="n">testing</span><span class="o">::</span><span class="n">Eq</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>W powyższym przykładnie zastosowanie pętli <strong>for</strong> jak najbardziej jest poprawne. Moglibyśmy wprawdzie po prostu napisać 6 asercji zamiast dwóch w pętli. Jednak jeśli elementów w kontenerze byłoby więcej, kod testu niepotrzebnie by się wydłużył. Zauważ przy okazji jakich asercji użyłem: <strong>ASSERT_THAT</strong> i <strong>EXPECT_THAT</strong>. Znasz je może? Ja wcześniej nie znałem. Po kilku testach stwierdziłem, że warto się im przyjrzeć bliżej. Z pewnością przygotuje osobny post o optymalizacji czytelności wyników testów, gdy się niepowiodą, tak, aby sam komunikat Google Testa jasno wskazywał nam co poszło nie tak.</p>

<h3 id="podsumowanie">Podsumowanie</h3>

<p>Mam nadzieję, że tym wpisem przekonałem Cię do niedodawania logiki to Twoich unit testów oraz uważniejszego code review swoich kolegów i koleżanek z zespołu. Ja sam wciąż zbyt często spotykam się z tym problemem i staram się dzielić wiedzą o tym jak pisać dobrej jakości unit testy. Co myślisz o tak rygorystycznym podejściu do braku logiki w unit testach? Uważasz to za przesadę, a może się ze mną zgadzasz? Koniecznie podziel się swoją opinią w komentarzu :)</p>

<p><strong>Autor:</strong> Tadeusz Biela<br />
Programista C++ | Entuzjasta TDD | Fan unit testów</p>

<p><a href="https://www.linkedin.com/in/tadeuszbiela/" target="_blank" rel="noopener">LinkedIn</a></p>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tagi: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#clean-code" class="page__taxonomy-item p-category" rel="tag">clean code</a><span class="sep">, </span>
    
      <a href="/tags/#code-quality" class="page__taxonomy-item p-category" rel="tag">code quality</a><span class="sep">, </span>
    
      <a href="/tags/#developer-practices" class="page__taxonomy-item p-category" rel="tag">developer practices</a><span class="sep">, </span>
    
      <a href="/tags/#software-testing" class="page__taxonomy-item p-category" rel="tag">software testing</a>
    
    </span>
  </p>




  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Kategorie: </strong>
    <span itemprop="keywords">
    
      <a href="/categories/#unit-testing" class="page__taxonomy-item p-category" rel="tag">unit-testing</a>
    
    </span>
  </p>


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Ostatnia aktualizacja:</strong> <time class="dt-published" datetime="2026-02-23T00:00:00+01:00">23 lutego 2026</time></p>

      </footer>

      <section class="page__share">
  <h4 class="page__share-title">Udostępnij</h4>

  <a href="https://x.com/intent/tweet?text=Najwi%C4%99kszy+wr%C3%B3g+unit+test%C3%B3w+-+logika.%20https%3A%2F%2Fcpptested.com%2Funit-testing%2Flogic-in-uts%2F" class="btn btn--x" aria-label="Share on X" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Udostępnij X">
    <i class="fas fa-fw fa-share-alt" aria-hidden="true"></i><span> X</span>
  </a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fcpptested.com%2Funit-testing%2Flogic-in-uts%2F" class="btn btn--facebook" aria-label="Share on Facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Udostępnij Facebook">
    <i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span>
  </a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https://cpptested.com/unit-testing/logic-in-uts/" class="btn btn--linkedin" aria-label="Share on LinkedIn" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Udostępnij LinkedIn">
    <i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span>
  </a>
</section>


      
  <nav class="pagination">
    
      <a href="/clean%20code/gtest-mistakes/" class="pagination--pager" title="6 najczęstszych błędów z Google Test.">Poprzednia</a>
    
    
      <a href="#" class="pagination--pager disabled">Następna</a>
    
  </nav>


    </div>

    
      
        <div class="page__comments">
  
  
      <h4 class="page__comments-title">Zostaw komentarz</h4>
      <div class="giscus"></div>
      <script src="https://giscus.app/client.js"
              data-repo="TadekBiela/cpptested"
              data-repo-id="R_kgDOPEW3uQ"
              data-category="Announcements"
              data-category-id="DIC_kwDOPEW3uc4CsbpH"
              data-mapping="pathname"
              data-strict="0"
              data-reactions-enabled="1"
              data-emit-metadata="0"
              data-input-position="top"
              data-theme="light"
              data-lang="pl"
              crossorigin="anonymous"
              async>
      </script>
    
</div>

      
    
  </article>

  
  
    
<div class="page__related">
  
  <h2 class="page__related-title">Także może Ci się spodobać</h2>
  <div class="grid__wrapper">
    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/clean%20code/gtest-mistakes/" rel="permalink">6 najczęstszych błędów z Google Test.
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2026-01-26T00:00:00+01:00">26 stycznia 2026</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          11 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Google Test to chyba najbardziej znany i używany framework testowy w projektach C++. Zawiera w sobie masę przydatnych narzędzi do tworzenia różnych rodzajów ...</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/unit-testing/handling-globals/" rel="permalink">Zależności globalne - jak poradzić sobie z nimi w unit testach
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-12-16T00:00:00+01:00">16 grudnia 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          7 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Każdy dobry unit test powinien nie tylko weryfikować nasz kod ale również odcinać zewnętrzne zależności, tak, aby przeprowadzenie testu odbywało się w izolac...</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/clean-code/dry-and-other-principles/" rel="permalink">DRY, YAGNI, KISS i inne. Uniwersalne zasady dla każdego programisty.
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-11-17T00:00:00+01:00">17 listopada 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          12 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Te tajemnicze akronimy skrywają w sobie dekady doświadczeń naszych programistycznych poprzedników. Choć brzmi to nieco patetycznie, tak właśnie jest. Zasady,...</p>
  </article>
</div>

    
      
      



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/multithreading/exception-in-thread/" rel="permalink">Wątki i wyjątki. Jak radzić sobie z nieoczekiwanymi zachowaniami w wielowątkowym kodzie.
</a>
      
    </h2>
    

  <p class="page__meta">
    
      
      <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        
        <time datetime="2025-10-13T00:00:00+02:00">13 października 2025</time>
      </span>
    

    <span class="page__meta-sep"></span>

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-fw fa-clock" aria-hidden="true"></i>
        
          10 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Nieoczekiwane zachowanie czyli wyjątek to sytuacja, w której nasz kod zachował się w sposób, który normalnie nie występuje. Może być to wywołane problemami z...</p>
  </article>
</div>

    
  </div>
</div>

  
  
</div>

      
    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';" role="search">
    <label class="sr-only" for="search">
      Wprowadź kryteria wyszukiwania...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Wprowadź kryteria wyszukiwania..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    <li style="justify-content: space-between; align-items: center;">
      <img src="/favicon.png" alt="Logo" style="">
    </li>

    
      <li><strong>Obserwuj:</strong></li>
    

    
      
        
          <li><a href="https://www.linkedin.com/in/tadeuszbiela/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i> LinkedIn</a></li>
        
      
        
          <li><a href="https://github.com/TadekBiela" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> RSS</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2026 <a href="https://cpptested.com">CppTested</a>. Powstało dzięki <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




    <script>
  'use strict';

  (function () {
    var commentContainer = document.querySelector('#giscus-comments');

    if (!commentContainer) {
      return;
    }

    var script = document.createElement('script');

    script.setAttribute('src', 'https://giscus.app/client.js');
    script.setAttribute('data-repo', '');
    script.setAttribute('data-repo-id', 'R_kgDOPEW3uQ');
    script.setAttribute('data-category', '');
    script.setAttribute('data-category-id', 'DIC_kwDOPEW3uc4CsbpH');
    script.setAttribute('data-mapping', 'pathname');
    script.setAttribute('data-strict', '0');
    script.setAttribute('data-reactions-enabled', '1');
    script.setAttribute('data-emit-metadata', '0');
    script.setAttribute('data-input-position', 'top');
    script.setAttribute('data-theme', 'light');
    script.setAttribute('data-lang',  'pl');
    
    script.setAttribute('crossorigin', 'anonymous');

    script.setAttribute('async', '');

    commentContainer.appendChild(script);
  })();
</script>

  




  </body>
</html>
