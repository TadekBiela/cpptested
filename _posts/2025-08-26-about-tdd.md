---
title: "Czym jest TDD i czy warto je stosować?"
date: 2025-08-26
author: "Tadeusz Biela"
categories:
  - tdd
tags:
  - clean code
  - code quality
  - developer practices
  - refactoring
  - test driven development
---

Test Driven Development to metoda pracy, która bazuje głównie na&nbsp;unit testach. Tworzymy oprogramowanie w&nbsp;cyklach, przyrostowo, a&nbsp;każda zmiana poprzedzona jest testem.


### Czym jest TDD.

Dla niektórych TDD to zasada, najpierw test (**test first**), dla&nbsp;innych wręcz wszystkie testy trzeba napisać przed implementacją. Część będzie twierdziła, że&nbsp;to tylko zbędne ograniczenie podczas implementacji, hamujące postęp. W&nbsp;pewnym stopniu zgodzę się ze&nbsp;wszystkimi jednak przyjrzyjmy się jej&nbsp;bliżej.

Test Driven Development to metodologia stawiająca unit testy na&nbsp;kluczowym miejscu. Traktuje je jako część implementacji, rozwiązania, które mamy zaimplementować. Zasada **test first** to pierwszy krok w&nbsp;TDD, ale&nbsp;to nie wszystko. W&nbsp;miarę rozwoju implementacji zwiększa się nam też liczba testów. Jest&nbsp;to pewien dodatkowy narzut i&nbsp;wydłuża nam czas implementacji, jednak&nbsp;tylko pozornie. Nie&nbsp;tracimy go w&nbsp;tak dużym stopniu przy debugowaniu i&nbsp;próbie przetestowania naszego rozwiązania, gdy&nbsp;jest już gotowe, a&nbsp;testów jeszcze nie ma. Podczas rozwoju naszego kodu w&nbsp;metodologii TDD tworzymy testowalne rozwiązanie.

Metodologia TDD jest jedną z&nbsp;technik programowania ekstremalnego ([XP](https://en.wikipedia.org/wiki/Extreme_programming){:target="_blank" rel="noopener"} - eXtreme Programming). Jej&nbsp;autorem jest Kent Beck, znany&nbsp;i&nbsp;ceniony specjalista IT, choć&nbsp;sam siebie uważa za odtwórcę TDD :). O&nbsp;wszystkich technikach XP z&nbsp;pewnością napiszę osobny post bo&nbsp;warto je znać i&nbsp;stosować.


### Cykl pracy w&nbsp;TDD

We wpisie o&nbsp;[F.I.R.S.T.](https://cpptested.com/unit%20testing/first-reguly-ut/){:target="_blank" rel="noopener"} wspominałem o&nbsp;cyklu Red -> Green -> Refactor, używanym w&nbsp;Test Driven Development. Cykl&nbsp;ten to pewien rytm wyznaczający naszą pracę w&nbsp;tej metodologii. Zanim jednak siądziemy przed nasze IDE, zbierzmy najbardziej kluczowe wymagania i sporządzmy ich listę. Łatwiej nam będzie tworzyć kolejne przypadki testowe.

**Red** - każdy cykl rozpoczynamy od napisania testu. W&nbsp;tym miejscu będziemy formułować nowe wymaganie do naszego kodu. Piszemy jeden test, który&nbsp;ma sprawdzać następny krok rozwoju naszej implementacji. Nie&nbsp;tworzymy wszystkich testów naraz. Tylko&nbsp;jeden, ograniczając zakres zmian. Pierwszy test najprawdopodobniej wywoła błąd kompilacji - nasz kod jeszcze nie istnieje. To&nbsp;też jest wynik Red. Zaczynamy pisać testy od najprostszych przypadków, zwiększając złożoność w&nbsp;kolejnych krokach.

**Green** - kiedy test jest już gotowy i&nbsp;nie przechodzi, czas&nbsp;dopisać brakującą implementację tak, aby&nbsp;kod spełniał wymagania testu. Nie&nbsp;więcej. Ważne jest to, że&nbsp;potrzebujemy implementacji, która&nbsp;ma za zadanie sprawić, aby&nbsp;test przeszedł. Nie&nbsp;musi być to od razu gotowe rozwiązanie. Dopisz tylko tyle kodu, ile&nbsp;wystarczy, aby&nbsp;test się "zazielenił".

**Refactor** - tutaj jest miejsce na&nbsp;poprawki i&nbsp;pracę z&nbsp;kodem. Na&nbsp;początku ten krok może być niezbyt pomocny. Jednak warto się choć chwilę zatrzymać i&nbsp;zastanowić. Refaktoring nie musi dotyczyć tylko implementacji. Jak&nbsp;najbardziej możemy popracować też nad testami. Tak, aby&nbsp;zarówno kod, jak&nbsp;i&nbsp;testy trzymały pewien poziom. Unit&nbsp;testy to nie dziki zachód, też&nbsp;powinny spełniać dobre praktyki, jak&nbsp;DRY czy AAA (o tym złotym standardzie napiszę z&nbsp;pewnością post).

Pracując w&nbsp;cyklach, częstu uruchamiamy testy. Mamy więc pewność, że&nbsp;nasz kod działa, a&nbsp;w&nbsp;przypadku pomyłki, szybko ją zlokalizujemy i&nbsp;naprawimy. W&nbsp;tradycyjnym podejściu, najtrudniej jest napisać pierwszy unit test. Sporo czasu potrzebujemy na&nbsp;odcięcie zależności. W&nbsp;TDD, pierwszy test jest prosty, mocno ograniczony. Dzięki temu łatwiej pokonać syndrom "pustej kartki" (wersja dla progamistów - "pustego ekranu" :) ).


### Zalety TDD

Podczas nauki i&nbsp;pracy w&nbsp;TDD zauważyłem sporo zalet, które&nbsp;mogą nie być widoczne na&nbsp;początku, gdy&nbsp;jeszcze nie mamy doświadczenia w&nbsp;tej metodologii.

**1)** Praca w&nbsp;TDD prowadzi do generowania kodu łatwego w&nbsp;testowaniu.
W&nbsp;przypadku tradycyjnego pisania implementacji. Wpierw tworzymy kod, a&nbsp;gdy już uznamy, że&nbsp;robi to, co&nbsp;wydaje nam się, że&nbsp;powinien robić, staramy się go otestować. Tracimy sporo czasu lub korzystamy ze złych praktyk, by&nbsp;odciąć zależności, aby&nbsp;móc go przetestować.

**2)** Koniec ze statusem naszego taska w&nbsp;stylu: "Mam już gotowe, tylko&nbsp;testy muszę dopisać". Po&nbsp;czym mijają kolejne dni, a&nbsp;zadanie wciąż nie jest ukończone.
Ta zaleta mocno łączy się z&nbsp;pierwszym punktem. Tutaj chcę zwrócić uwagę bardziej na&nbsp;nasz odbiór przez resztę zespołu, zwłaszcza kadrę zarządzającą. Gdy&nbsp;mówimy, że&nbsp;coś jest gotowe, to&nbsp;jest i&nbsp;tyle. Stajemy się bardziej wiarygodni i&nbsp;profesjonalni.

**3)** Zyskujemy zaufanie, że&nbsp;nasza implementacja działa.
Oczywiście musimy zagwarantować, że&nbsp;wszystkie przypadki testowe są uwzględnione. Nie&nbsp;tylko tak zwany "happy path".

**4)** Konkretyzujemy wymagania, zanim&nbsp;kod jest napisany.
W&nbsp;tradycyjnym podejściu, gdy&nbsp;otrzymujemy lub wybieramy zadanie, tworzy się nam w&nbsp;głowie wstępny koncept, co&nbsp;nowa implementacja ma robić i&nbsp;jak ma to robić. Ten&nbsp;koncept może jednak być błędny, a&nbsp;my możemy dojść do momentu, w&nbsp;którym kod jest gotowy, ale&nbsp;nie do końca robi to, co&nbsp;powinien. W&nbsp;TDD najpierw siadamy do testu i&nbsp;zanim napiszemy choćby linijkę implementacji, musimy dowiedzieć się, jakie&nbsp;wymagania nasz kod powinien spełniać.

**5)** Plastyczność kodu. Dzięki&nbsp;temu, że&nbsp;nasze zmiany są już otestowane, możemy eksperymentować podczas refaktoryzacji z&nbsp;różnymi rozwiązaniami bez obaw, że&nbsp;coś zepsujemy.
Odkrycie tej zalety TDD zajęło mi trochę czasu, ale&nbsp;było niczym przebłysk. Gdy już wszystkie testy są napisane, a&nbsp;pierwsza wersja rozwiązania działa i&nbsp;przechodzi je wszystkie, możemy próbować poprawić różne parametry naszego kodu, by&nbsp;zwiększyć czytelność, modularność czy zoptymalizować najważniejsze fragmenty.

**6)** Poczucie ciągłego postępu - zwiększona satysfakcja.
Gdy kolejny test zmienia swój wynik z&nbsp;czerwonego na zielony, ta&nbsp;prosta rzecz naprawdę cieszy. Odczuwamy, że&nbsp;idziemy do przodu. Ta&nbsp;zaleta jest bardziej na podłożu psychologicznym. Niemniej, jest&nbsp;bardzo cenną zaletą sprawiającą, że&nbsp;nasza codzienna praca jest po prostu przyjemniejsza.

### Wady TDD

TDD nie jest jednak lekiem na&nbsp;wszystko. To&nbsp;narzędzie, jak&nbsp;każde inne, ma&nbsp;pewien zakres zastosowań. W&nbsp;pewnych sytuacjach jednak nie należy go stosować.

**1)** W&nbsp;mojej ocenie TDD nie jest łatwe do nauki.
Aby móc w&nbsp;pełni czerpać z&nbsp;tej metodologii, trzeba przestawić swój sposób myślenia o&nbsp;pisaniu kodu. TDD&nbsp;wymaga innego trybu pracy i&nbsp;na początku jest to pewnego rodzaju wysiłek intelektualny. Jeśli&nbsp;nie zna się w&nbsp;pełni tego narzędzia, można się zniechęcić do jego stosowania. Ja&nbsp;tak miałem. Na początku myślałem, że&nbsp;jest to prosta zasada test first. Nie raz porzucałem ją na&nbsp;wczesnym etapie nauki. Po&nbsp;kilku podejściach i&nbsp;dokształceniu się z&nbsp;dobrych źródeł, udało mi się opanować TDD i&nbsp;stałem się jego entuzjastą.

**2)** Cykl Red -> Green -> Refactor nie sprawdza się przy rozwiązaniach, które&nbsp;są zbyt małe i&nbsp;oczywiste.
Czasem natrafiamy na&nbsp;takie przypadki, gdzie&nbsp;implementacja nasuwa się sama. Jeśli&nbsp;tylko dobrze znamy wymagania, po&nbsp;napisaniu pierwszego testu możemy od razu stworzyć pełną implementację. Następnie dopisać testy, by&nbsp;mieć pewność, że&nbsp;nie popełniliśmy błędu, i&nbsp;to jest w&nbsp;porządku! TDD ma nam pomagać w&nbsp;naszej pracy, a&nbsp;nie być świętą zasadą, której&nbsp;należy zawsze się trzymać.

**3)** Dodatkowy narzut czasowy.
Gotowe rozwiązanie naszego problemu powstaje wolniej, gdyż&nbsp;część czasu musimy poświęcić na napisanie unit testów. Nie&nbsp;jest to jednak duża wada, gdyż czas ten zwraca nam się w&nbsp;dłuższej perspektywie. Warto&nbsp;jednak mieć tego świadomość. W przypadku bardzo krótkich projektów, np. hackathon, TDD może nie być dobrym wyborem.

### Podsumowanie

Porównując zalety i&nbsp;wady TDD myślę, że&nbsp;można stwierdzić, że&nbsp;zdecydowanie więcej jest tych pierwszych. Jeśli wciąż Cię nie przekonałem. Po&nbsp;prostu spróbuj - jednak nie raz czy dwa. Daj&nbsp;tej metodologii trochę czasu, a&nbsp;gwarantuję, że&nbsp;odczujesz różnicę.

W&nbsp;tym wpisie chciałem przybliżyć i&nbsp;w&nbsp;prostych słowach opisać, na&nbsp;czym polega praca w&nbsp;TDD. Jestem przekonany, że&nbsp;opanowanie tej metodologii wzniesie każdego programistę, nie tylko C++, na&nbsp;wyższy poziom i&nbsp;jest warte wysiłku jego nauki i&nbsp;praktyki. Jeśli chcesz poznać bliżej TDD to polecam sięgnąć do źródła, czyli&nbsp;"ojca" TDD, Kenta&nbsp;Becka. Napisał on świetną książkę - [TDD. Sztuka tworzenia dobrego kodu](https://lubimyczytac.pl/ksiazka/223586/tdd-sztuka-tworzenia-dobrego-kodu){:target="_blank" rel="noopener"}


**Autor:** Tadeusz Biela  
Programista C++ | Entuzjasta TDD | Fan unit testów

[LinkedIn](https://www.linkedin.com/in/tadeuszbiela/){:target="_blank" rel="noopener"}
